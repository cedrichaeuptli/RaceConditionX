
RaceConditionX.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003d7a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000044  00802000  00003d7a  00003e0e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000c81  00802044  00802044  00003e52  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003e52  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003e84  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000770  00000000  00000000  00003ec4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e81a  00000000  00000000  00004634  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004e55  00000000  00000000  00012e4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004e7a  00000000  00000000  00017ca3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000017f8  00000000  00000000  0001cb20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000570c  00000000  00000000  0001e318  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009225  00000000  00000000  00023a24  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000820  00000000  00000000  0002cc49  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 22 01 	jmp	0x244	; 0x244 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      1c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 54 05 	jmp	0xaa8	; 0xaa8 <__vector_14>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      90:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      94:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      98:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      9c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      fc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     100:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     104:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     108:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     10c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     110:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     114:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     118:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     11c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     120:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     124:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     128:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     12c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     130:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     134:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     138:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     13c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     140:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     144:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     148:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     14c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     150:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     154:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     158:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     15c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     160:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     164:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     168:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     16c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     170:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     174:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     178:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     17c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     180:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     184:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     188:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     18c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     190:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     194:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     198:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     19c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b0:	0c 94 df 15 	jmp	0x2bbe	; 0x2bbe <__vector_108>
     1b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1fc:	c2 12       	cpse	r12, r18
     1fe:	c2 12       	cpse	r12, r18
     200:	c2 12       	cpse	r12, r18
     202:	0f 13       	cpse	r16, r31
     204:	f7 12       	cpse	r15, r23
     206:	0c 13       	cpse	r16, r28
     208:	c2 12       	cpse	r12, r18
     20a:	c2 12       	cpse	r12, r18
     20c:	0f 13       	cpse	r16, r31
     20e:	f7 12       	cpse	r15, r23

00000210 <__trampolines_start>:
     210:	0c 94 c2 12 	jmp	0x2584	; 0x2584 <prvTimerTask+0x178>
     214:	0c 94 a3 14 	jmp	0x2946	; 0x2946 <vButtonHandler2>
     218:	0c 94 3f 03 	jmp	0x67e	; 0x67e <vEventGroupSetBitsCallback>
     21c:	0c 94 59 14 	jmp	0x28b2	; 0x28b2 <vButtonHandler1>
     220:	0c 94 3b 15 	jmp	0x2a76	; 0x2a76 <vButtonHandler4>
     224:	0c 94 ee 14 	jmp	0x29dc	; 0x29dc <vButtonHandler3>
     228:	0c 94 0f 13 	jmp	0x261e	; 0x261e <prvTimerTask+0x212>
     22c:	0c 94 7e 17 	jmp	0x2efc	; 0x2efc <vDisplayUpdateTask>
     230:	0c 94 93 13 	jmp	0x2726	; 0x2726 <vDisplayTask>
     234:	0c 94 0c 13 	jmp	0x2618	; 0x2618 <prvTimerTask+0x20c>
     238:	0c 94 f7 12 	jmp	0x25ee	; 0x25ee <prvTimerTask+0x1e2>
     23c:	0c 94 06 12 	jmp	0x240c	; 0x240c <prvTimerTask>
     240:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <prvIdleTask>

00000244 <__ctors_end>:
     244:	11 24       	eor	r1, r1
     246:	1f be       	out	0x3f, r1	; 63
     248:	cf ef       	ldi	r28, 0xFF	; 255
     24a:	cd bf       	out	0x3d, r28	; 61
     24c:	df e3       	ldi	r29, 0x3F	; 63
     24e:	de bf       	out	0x3e, r29	; 62
     250:	00 e0       	ldi	r16, 0x00	; 0
     252:	0c bf       	out	0x3c, r16	; 60

00000254 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     254:	e5 ec       	ldi	r30, 0xC5	; 197
     256:	fc e2       	ldi	r31, 0x2C	; 44
     258:	8a ea       	ldi	r24, 0xAA	; 170
     25a:	90 e4       	ldi	r25, 0x40	; 64
     25c:	81 93       	st	Z+, r24
     25e:	e0 30       	cpi	r30, 0x00	; 0
     260:	f9 07       	cpc	r31, r25
     262:	e0 f3       	brcs	.-8      	; 0x25c <init_mem+0x8>

00000264 <__do_copy_data>:
     264:	10 e2       	ldi	r17, 0x20	; 32
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b0 e2       	ldi	r27, 0x20	; 32
     26a:	ea e7       	ldi	r30, 0x7A	; 122
     26c:	fd e3       	ldi	r31, 0x3D	; 61
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a4 34       	cpi	r26, 0x44	; 68
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	2c e2       	ldi	r18, 0x2C	; 44
     280:	a4 e4       	ldi	r26, 0x44	; 68
     282:	b0 e2       	ldi	r27, 0x20	; 32
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	a5 3c       	cpi	r26, 0xC5	; 197
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <main>
     292:	0c 94 bb 1e 	jmp	0x3d76	; 0x3d76 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     29a:	0f 93       	push	r16
     29c:	cf 93       	push	r28
     29e:	df 93       	push	r29
     2a0:	1f 92       	push	r1
     2a2:	cd b7       	in	r28, 0x3d	; 61
     2a4:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     2a6:	2f b7       	in	r18, 0x3f	; 63
     2a8:	29 83       	std	Y+1, r18	; 0x01
     2aa:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     2ac:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     2ae:	fc 01       	movw	r30, r24
     2b0:	08 ed       	ldi	r16, 0xD8	; 216
     2b2:	04 bf       	out	0x34, r16	; 52
     2b4:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     2b6:	89 81       	ldd	r24, Y+1	; 0x01
     2b8:	8f bf       	out	0x3f, r24	; 63
#endif
}
     2ba:	0f 90       	pop	r0
     2bc:	df 91       	pop	r29
     2be:	cf 91       	pop	r28
     2c0:	0f 91       	pop	r16
     2c2:	08 95       	ret

000002c4 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     2c4:	61 11       	cpse	r22, r1
     2c6:	02 c0       	rjmp	.+4      	; 0x2cc <CLKSYS_XOSC_Config+0x8>
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	01 c0       	rjmp	.+2      	; 0x2ce <CLKSYS_XOSC_Config+0xa>
     2cc:	90 e2       	ldi	r25, 0x20	; 32
     2ce:	84 2b       	or	r24, r20
     2d0:	89 2b       	or	r24, r25
     2d2:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     2d6:	08 95       	ret

000002d8 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     2d8:	6f 71       	andi	r22, 0x1F	; 31
     2da:	86 2b       	or	r24, r22
     2dc:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     2e0:	08 95       	ret

000002e2 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     2e2:	e0 e5       	ldi	r30, 0x50	; 80
     2e4:	f0 e0       	ldi	r31, 0x00	; 0
     2e6:	90 81       	ld	r25, Z
     2e8:	28 2f       	mov	r18, r24
     2ea:	20 95       	com	r18
     2ec:	92 23       	and	r25, r18
     2ee:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     2f0:	90 81       	ld	r25, Z
	return clkEnabled;
}
     2f2:	89 23       	and	r24, r25
     2f4:	08 95       	ret

000002f6 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     2f6:	68 2b       	or	r22, r24
     2f8:	81 e4       	ldi	r24, 0x41	; 65
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	0e 94 4d 01 	call	0x29a	; 0x29a <CCPWrite>
     300:	08 95       	ret

00000302 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     302:	0f 93       	push	r16
     304:	1f 93       	push	r17
     306:	cf 93       	push	r28
     308:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     30a:	00 e4       	ldi	r16, 0x40	; 64
     30c:	10 e0       	ldi	r17, 0x00	; 0
     30e:	f8 01       	movw	r30, r16
     310:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     312:	68 7f       	andi	r22, 0xF8	; 248
     314:	68 2b       	or	r22, r24
     316:	80 e4       	ldi	r24, 0x40	; 64
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 4d 01 	call	0x29a	; 0x29a <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     31e:	f8 01       	movw	r30, r16
     320:	80 81       	ld	r24, Z
	return clkCtrl;
}
     322:	8c 23       	and	r24, r28
     324:	cf 91       	pop	r28
     326:	1f 91       	pop	r17
     328:	0f 91       	pop	r16
     32a:	08 95       	ret

0000032c <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     32c:	fc 01       	movw	r30, r24
     32e:	90 81       	ld	r25, Z
     330:	90 7f       	andi	r25, 0xF0	; 240
     332:	69 2b       	or	r22, r25
     334:	60 83       	st	Z, r22
     336:	08 95       	ret

00000338 <TC0_ConfigWGM>:
     338:	fc 01       	movw	r30, r24
     33a:	91 81       	ldd	r25, Z+1	; 0x01
     33c:	98 7f       	andi	r25, 0xF8	; 248
     33e:	69 2b       	or	r22, r25
     340:	61 83       	std	Z+1, r22	; 0x01
     342:	08 95       	ret

00000344 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     344:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     346:	96 81       	ldd	r25, Z+6	; 0x06
     348:	9c 7f       	andi	r25, 0xFC	; 252
     34a:	69 2b       	or	r22, r25
     34c:	66 83       	std	Z+6, r22	; 0x06
     34e:	08 95       	ret

00000350 <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     350:	00 00       	nop
     352:	88 ed       	ldi	r24, 0xD8	; 216
     354:	84 bf       	out	0x34, r24	; 52
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     35c:	08 95       	ret

0000035e <vApplicationStackOverflowHook>:
     35e:	0e 94 a8 01 	call	0x350	; 0x350 <software_reset>
     362:	08 95       	ret

00000364 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	80 e1       	ldi	r24, 0x10	; 16
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	0e 94 4f 03 	call	0x69e	; 0x69e <pvPortMalloc>
     370:	ec 01       	movw	r28, r24
     372:	00 97       	sbiw	r24, 0x00	; 0
     374:	41 f0       	breq	.+16     	; 0x386 <xEventGroupCreate+0x22>
     376:	fc 01       	movw	r30, r24
     378:	11 92       	st	Z+, r1
     37a:	11 92       	st	Z+, r1
     37c:	11 92       	st	Z+, r1
     37e:	11 92       	st	Z+, r1
     380:	cf 01       	movw	r24, r30
     382:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
     386:	ce 01       	movw	r24, r28
     388:	df 91       	pop	r29
     38a:	cf 91       	pop	r28
     38c:	08 95       	ret

0000038e <xEventGroupWaitBits>:
     38e:	2f 92       	push	r2
     390:	3f 92       	push	r3
     392:	4f 92       	push	r4
     394:	5f 92       	push	r5
     396:	6f 92       	push	r6
     398:	7f 92       	push	r7
     39a:	8f 92       	push	r8
     39c:	9f 92       	push	r9
     39e:	af 92       	push	r10
     3a0:	bf 92       	push	r11
     3a2:	cf 92       	push	r12
     3a4:	df 92       	push	r13
     3a6:	ef 92       	push	r14
     3a8:	ff 92       	push	r15
     3aa:	0f 93       	push	r16
     3ac:	1f 93       	push	r17
     3ae:	cf 93       	push	r28
     3b0:	df 93       	push	r29
     3b2:	ec 01       	movw	r28, r24
     3b4:	4a 01       	movw	r8, r20
     3b6:	5b 01       	movw	r10, r22
     3b8:	62 2e       	mov	r6, r18
     3ba:	70 2e       	mov	r7, r16
     3bc:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
     3c0:	28 80       	ld	r2, Y
     3c2:	39 80       	ldd	r3, Y+1	; 0x01
     3c4:	4a 80       	ldd	r4, Y+2	; 0x02
     3c6:	5b 80       	ldd	r5, Y+3	; 0x03
     3c8:	01 11       	cpse	r16, r1
     3ca:	0d c0       	rjmp	.+26     	; 0x3e6 <xEventGroupWaitBits+0x58>
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	b2 01       	movw	r22, r4
     3d0:	a1 01       	movw	r20, r2
     3d2:	48 21       	and	r20, r8
     3d4:	59 21       	and	r21, r9
     3d6:	6a 21       	and	r22, r10
     3d8:	7b 21       	and	r23, r11
     3da:	45 2b       	or	r20, r21
     3dc:	46 2b       	or	r20, r22
     3de:	47 2b       	or	r20, r23
     3e0:	79 f4       	brne	.+30     	; 0x400 <__LOCK_REGION_LENGTH__>
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	0d c0       	rjmp	.+26     	; 0x400 <__LOCK_REGION_LENGTH__>
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	b2 01       	movw	r22, r4
     3ea:	a1 01       	movw	r20, r2
     3ec:	48 21       	and	r20, r8
     3ee:	59 21       	and	r21, r9
     3f0:	6a 21       	and	r22, r10
     3f2:	7b 21       	and	r23, r11
     3f4:	48 15       	cp	r20, r8
     3f6:	59 05       	cpc	r21, r9
     3f8:	6a 05       	cpc	r22, r10
     3fa:	7b 05       	cpc	r23, r11
     3fc:	09 f0       	breq	.+2      	; 0x400 <__LOCK_REGION_LENGTH__>
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	88 23       	and	r24, r24
     402:	81 f0       	breq	.+32     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     404:	66 20       	and	r6, r6
     406:	09 f4       	brne	.+2      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     408:	70 c0       	rjmp	.+224    	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     40a:	80 94       	com	r8
     40c:	90 94       	com	r9
     40e:	a0 94       	com	r10
     410:	b0 94       	com	r11
     412:	82 20       	and	r8, r2
     414:	93 20       	and	r9, r3
     416:	a4 20       	and	r10, r4
     418:	b5 20       	and	r11, r5
     41a:	88 82       	st	Y, r8
     41c:	99 82       	std	Y+1, r9	; 0x01
     41e:	aa 82       	std	Y+2, r10	; 0x02
     420:	bb 82       	std	Y+3, r11	; 0x03
     422:	63 c0       	rjmp	.+198    	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     424:	c1 14       	cp	r12, r1
     426:	d1 04       	cpc	r13, r1
     428:	e1 04       	cpc	r14, r1
     42a:	f1 04       	cpc	r15, r1
     42c:	09 f4       	brne	.+2      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
     42e:	5d c0       	rjmp	.+186    	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     430:	66 20       	and	r6, r6
     432:	29 f0       	breq	.+10     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
     434:	40 e0       	ldi	r20, 0x00	; 0
     436:	50 e0       	ldi	r21, 0x00	; 0
     438:	60 e0       	ldi	r22, 0x00	; 0
     43a:	71 e0       	ldi	r23, 0x01	; 1
     43c:	03 c0       	rjmp	.+6      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	ba 01       	movw	r22, r20
     444:	71 10       	cpse	r7, r1
     446:	74 60       	ori	r23, 0x04	; 4
     448:	48 29       	or	r20, r8
     44a:	59 29       	or	r21, r9
     44c:	6a 29       	or	r22, r10
     44e:	7b 29       	or	r23, r11
     450:	97 01       	movw	r18, r14
     452:	86 01       	movw	r16, r12
     454:	ce 01       	movw	r24, r28
     456:	04 96       	adiw	r24, 0x04	; 4
     458:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vTaskPlaceOnUnorderedEventList>
     45c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     460:	81 11       	cpse	r24, r1
     462:	02 c0       	rjmp	.+4      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
     464:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
     468:	0e 94 43 10 	call	0x2086	; 0x2086 <uxTaskResetEventItemValue>
     46c:	91 fd       	sbrc	r25, 1
     46e:	39 c0       	rjmp	.+114    	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>
     470:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     474:	ff 93       	push	r31
     476:	f8 7f       	andi	r31, 0xF8	; 248
     478:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     47c:	68 81       	ld	r22, Y
     47e:	79 81       	ldd	r23, Y+1	; 0x01
     480:	8a 81       	ldd	r24, Y+2	; 0x02
     482:	9b 81       	ldd	r25, Y+3	; 0x03
     484:	71 10       	cpse	r7, r1
     486:	0d c0       	rjmp	.+26     	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     488:	21 e0       	ldi	r18, 0x01	; 1
     48a:	75 01       	movw	r14, r10
     48c:	64 01       	movw	r12, r8
     48e:	c6 22       	and	r12, r22
     490:	d7 22       	and	r13, r23
     492:	e8 22       	and	r14, r24
     494:	f9 22       	and	r15, r25
     496:	cd 28       	or	r12, r13
     498:	ce 28       	or	r12, r14
     49a:	cf 28       	or	r12, r15
     49c:	79 f4       	brne	.+30     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	0d c0       	rjmp	.+26     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
     4a2:	21 e0       	ldi	r18, 0x01	; 1
     4a4:	75 01       	movw	r14, r10
     4a6:	64 01       	movw	r12, r8
     4a8:	c6 22       	and	r12, r22
     4aa:	d7 22       	and	r13, r23
     4ac:	e8 22       	and	r14, r24
     4ae:	f9 22       	and	r15, r25
     4b0:	c8 14       	cp	r12, r8
     4b2:	d9 04       	cpc	r13, r9
     4b4:	ea 04       	cpc	r14, r10
     4b6:	fb 04       	cpc	r15, r11
     4b8:	09 f0       	breq	.+2      	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
     4ba:	20 e0       	ldi	r18, 0x00	; 0
     4bc:	22 23       	and	r18, r18
     4be:	71 f0       	breq	.+28     	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
     4c0:	66 20       	and	r6, r6
     4c2:	61 f0       	breq	.+24     	; 0x4dc <__LOCK_REGION_LENGTH__+0xdc>
     4c4:	80 94       	com	r8
     4c6:	90 94       	com	r9
     4c8:	a0 94       	com	r10
     4ca:	b0 94       	com	r11
     4cc:	86 22       	and	r8, r22
     4ce:	97 22       	and	r9, r23
     4d0:	a8 22       	and	r10, r24
     4d2:	b9 22       	and	r11, r25
     4d4:	88 82       	st	Y, r8
     4d6:	99 82       	std	Y+1, r9	; 0x01
     4d8:	aa 82       	std	Y+2, r10	; 0x02
     4da:	bb 82       	std	Y+3, r11	; 0x03
     4dc:	ff 91       	pop	r31
     4de:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     4e2:	1b 01       	movw	r2, r22
     4e4:	2c 01       	movw	r4, r24
     4e6:	55 24       	eor	r5, r5
     4e8:	02 c0       	rjmp	.+4      	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
     4ea:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     4ee:	c2 01       	movw	r24, r4
     4f0:	b1 01       	movw	r22, r2
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	ff 90       	pop	r15
     4fc:	ef 90       	pop	r14
     4fe:	df 90       	pop	r13
     500:	cf 90       	pop	r12
     502:	bf 90       	pop	r11
     504:	af 90       	pop	r10
     506:	9f 90       	pop	r9
     508:	8f 90       	pop	r8
     50a:	7f 90       	pop	r7
     50c:	6f 90       	pop	r6
     50e:	5f 90       	pop	r5
     510:	4f 90       	pop	r4
     512:	3f 90       	pop	r3
     514:	2f 90       	pop	r2
     516:	08 95       	ret

00000518 <xEventGroupClearBits>:
     518:	0f 93       	push	r16
     51a:	1f 93       	push	r17
     51c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     520:	ff 93       	push	r31
     522:	f8 7f       	andi	r31, 0xF8	; 248
     524:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     528:	fc 01       	movw	r30, r24
     52a:	00 81       	ld	r16, Z
     52c:	11 81       	ldd	r17, Z+1	; 0x01
     52e:	22 81       	ldd	r18, Z+2	; 0x02
     530:	33 81       	ldd	r19, Z+3	; 0x03
     532:	40 95       	com	r20
     534:	50 95       	com	r21
     536:	60 95       	com	r22
     538:	70 95       	com	r23
     53a:	40 23       	and	r20, r16
     53c:	51 23       	and	r21, r17
     53e:	62 23       	and	r22, r18
     540:	73 23       	and	r23, r19
     542:	40 83       	st	Z, r20
     544:	51 83       	std	Z+1, r21	; 0x01
     546:	62 83       	std	Z+2, r22	; 0x02
     548:	73 83       	std	Z+3, r23	; 0x03
     54a:	ff 91       	pop	r31
     54c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     550:	c9 01       	movw	r24, r18
     552:	b8 01       	movw	r22, r16
     554:	1f 91       	pop	r17
     556:	0f 91       	pop	r16
     558:	08 95       	ret

0000055a <xEventGroupSetBits>:
     55a:	4f 92       	push	r4
     55c:	5f 92       	push	r5
     55e:	6f 92       	push	r6
     560:	7f 92       	push	r7
     562:	af 92       	push	r10
     564:	bf 92       	push	r11
     566:	cf 92       	push	r12
     568:	df 92       	push	r13
     56a:	ef 92       	push	r14
     56c:	ff 92       	push	r15
     56e:	0f 93       	push	r16
     570:	1f 93       	push	r17
     572:	cf 93       	push	r28
     574:	df 93       	push	r29
     576:	ec 01       	movw	r28, r24
     578:	6a 01       	movw	r12, r20
     57a:	7b 01       	movw	r14, r22
     57c:	8c 01       	movw	r16, r24
     57e:	09 5f       	subi	r16, 0xF9	; 249
     580:	1f 4f       	sbci	r17, 0xFF	; 255
     582:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
     586:	eb 85       	ldd	r30, Y+11	; 0x0b
     588:	fc 85       	ldd	r31, Y+12	; 0x0c
     58a:	88 81       	ld	r24, Y
     58c:	99 81       	ldd	r25, Y+1	; 0x01
     58e:	aa 81       	ldd	r26, Y+2	; 0x02
     590:	bb 81       	ldd	r27, Y+3	; 0x03
     592:	c8 2a       	or	r12, r24
     594:	d9 2a       	or	r13, r25
     596:	ea 2a       	or	r14, r26
     598:	fb 2a       	or	r15, r27
     59a:	c8 82       	st	Y, r12
     59c:	d9 82       	std	Y+1, r13	; 0x01
     59e:	ea 82       	std	Y+2, r14	; 0x02
     5a0:	fb 82       	std	Y+3, r15	; 0x03
     5a2:	0e 17       	cp	r16, r30
     5a4:	1f 07       	cpc	r17, r31
     5a6:	09 f4       	brne	.+2      	; 0x5aa <xEventGroupSetBits+0x50>
     5a8:	42 c0       	rjmp	.+132    	; 0x62e <xEventGroupSetBits+0xd4>
     5aa:	c1 2c       	mov	r12, r1
     5ac:	d1 2c       	mov	r13, r1
     5ae:	76 01       	movw	r14, r12
     5b0:	a4 80       	ldd	r10, Z+4	; 0x04
     5b2:	b5 80       	ldd	r11, Z+5	; 0x05
     5b4:	80 81       	ld	r24, Z
     5b6:	91 81       	ldd	r25, Z+1	; 0x01
     5b8:	a2 81       	ldd	r26, Z+2	; 0x02
     5ba:	b3 81       	ldd	r27, Z+3	; 0x03
     5bc:	ac 01       	movw	r20, r24
     5be:	bd 01       	movw	r22, r26
     5c0:	77 27       	eor	r23, r23
     5c2:	b2 fd       	sbrc	r27, 2
     5c4:	0f c0       	rjmp	.+30     	; 0x5e4 <xEventGroupSetBits+0x8a>
     5c6:	48 80       	ld	r4, Y
     5c8:	59 80       	ldd	r5, Y+1	; 0x01
     5ca:	6a 80       	ldd	r6, Y+2	; 0x02
     5cc:	7b 80       	ldd	r7, Y+3	; 0x03
     5ce:	44 22       	and	r4, r20
     5d0:	55 22       	and	r5, r21
     5d2:	66 22       	and	r6, r22
     5d4:	77 22       	and	r7, r23
     5d6:	21 e0       	ldi	r18, 0x01	; 1
     5d8:	45 28       	or	r4, r5
     5da:	46 28       	or	r4, r6
     5dc:	47 28       	or	r4, r7
     5de:	89 f4       	brne	.+34     	; 0x602 <xEventGroupSetBits+0xa8>
     5e0:	20 e0       	ldi	r18, 0x00	; 0
     5e2:	0f c0       	rjmp	.+30     	; 0x602 <xEventGroupSetBits+0xa8>
     5e4:	48 80       	ld	r4, Y
     5e6:	59 80       	ldd	r5, Y+1	; 0x01
     5e8:	6a 80       	ldd	r6, Y+2	; 0x02
     5ea:	7b 80       	ldd	r7, Y+3	; 0x03
     5ec:	44 22       	and	r4, r20
     5ee:	55 22       	and	r5, r21
     5f0:	66 22       	and	r6, r22
     5f2:	77 22       	and	r7, r23
     5f4:	21 e0       	ldi	r18, 0x01	; 1
     5f6:	44 16       	cp	r4, r20
     5f8:	55 06       	cpc	r5, r21
     5fa:	66 06       	cpc	r6, r22
     5fc:	77 06       	cpc	r7, r23
     5fe:	09 f0       	breq	.+2      	; 0x602 <xEventGroupSetBits+0xa8>
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	22 23       	and	r18, r18
     604:	71 f0       	breq	.+28     	; 0x622 <xEventGroupSetBits+0xc8>
     606:	b0 ff       	sbrs	r27, 0
     608:	04 c0       	rjmp	.+8      	; 0x612 <xEventGroupSetBits+0xb8>
     60a:	c4 2a       	or	r12, r20
     60c:	d5 2a       	or	r13, r21
     60e:	e6 2a       	or	r14, r22
     610:	f7 2a       	or	r15, r23
     612:	48 81       	ld	r20, Y
     614:	59 81       	ldd	r21, Y+1	; 0x01
     616:	6a 81       	ldd	r22, Y+2	; 0x02
     618:	7b 81       	ldd	r23, Y+3	; 0x03
     61a:	72 60       	ori	r23, 0x02	; 2
     61c:	cf 01       	movw	r24, r30
     61e:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <vTaskRemoveFromUnorderedEventList>
     622:	ea 2d       	mov	r30, r10
     624:	fb 2d       	mov	r31, r11
     626:	0e 17       	cp	r16, r30
     628:	1f 07       	cpc	r17, r31
     62a:	11 f6       	brne	.-124    	; 0x5b0 <xEventGroupSetBits+0x56>
     62c:	03 c0       	rjmp	.+6      	; 0x634 <xEventGroupSetBits+0xda>
     62e:	c1 2c       	mov	r12, r1
     630:	d1 2c       	mov	r13, r1
     632:	76 01       	movw	r14, r12
     634:	c0 94       	com	r12
     636:	d0 94       	com	r13
     638:	e0 94       	com	r14
     63a:	f0 94       	com	r15
     63c:	88 81       	ld	r24, Y
     63e:	99 81       	ldd	r25, Y+1	; 0x01
     640:	aa 81       	ldd	r26, Y+2	; 0x02
     642:	bb 81       	ldd	r27, Y+3	; 0x03
     644:	c8 22       	and	r12, r24
     646:	d9 22       	and	r13, r25
     648:	ea 22       	and	r14, r26
     64a:	fb 22       	and	r15, r27
     64c:	c8 82       	st	Y, r12
     64e:	d9 82       	std	Y+1, r13	; 0x01
     650:	ea 82       	std	Y+2, r14	; 0x02
     652:	fb 82       	std	Y+3, r15	; 0x03
     654:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     658:	68 81       	ld	r22, Y
     65a:	79 81       	ldd	r23, Y+1	; 0x01
     65c:	8a 81       	ldd	r24, Y+2	; 0x02
     65e:	9b 81       	ldd	r25, Y+3	; 0x03
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	1f 91       	pop	r17
     666:	0f 91       	pop	r16
     668:	ff 90       	pop	r15
     66a:	ef 90       	pop	r14
     66c:	df 90       	pop	r13
     66e:	cf 90       	pop	r12
     670:	bf 90       	pop	r11
     672:	af 90       	pop	r10
     674:	7f 90       	pop	r7
     676:	6f 90       	pop	r6
     678:	5f 90       	pop	r5
     67a:	4f 90       	pop	r4
     67c:	08 95       	ret

0000067e <vEventGroupSetBitsCallback>:
     67e:	0e 94 ad 02 	call	0x55a	; 0x55a <xEventGroupSetBits>
     682:	08 95       	ret

00000684 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     684:	0f 93       	push	r16
     686:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     688:	89 01       	movw	r16, r18
     68a:	9a 01       	movw	r18, r20
     68c:	ab 01       	movw	r20, r22
     68e:	bc 01       	movw	r22, r24
     690:	8f e3       	ldi	r24, 0x3F	; 63
     692:	93 e0       	ldi	r25, 0x03	; 3
     694:	0e 94 35 13 	call	0x266a	; 0x266a <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     698:	1f 91       	pop	r17
     69a:	0f 91       	pop	r16
     69c:	08 95       	ret

0000069e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6a4:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     6a8:	20 91 44 20 	lds	r18, 0x2044	; 0x802044 <__data_end>
     6ac:	30 91 45 20 	lds	r19, 0x2045	; 0x802045 <__data_end+0x1>
     6b0:	c9 01       	movw	r24, r18
     6b2:	8c 0f       	add	r24, r28
     6b4:	9d 1f       	adc	r25, r29
     6b6:	88 3b       	cpi	r24, 0xB8	; 184
     6b8:	4b e0       	ldi	r20, 0x0B	; 11
     6ba:	94 07       	cpc	r25, r20
     6bc:	58 f4       	brcc	.+22     	; 0x6d4 <pvPortMalloc+0x36>
     6be:	28 17       	cp	r18, r24
     6c0:	39 07       	cpc	r19, r25
     6c2:	58 f4       	brcc	.+22     	; 0x6da <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     6c4:	e9 01       	movw	r28, r18
     6c6:	ca 5b       	subi	r28, 0xBA	; 186
     6c8:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     6ca:	80 93 44 20 	sts	0x2044, r24	; 0x802044 <__data_end>
     6ce:	90 93 45 20 	sts	0x2045, r25	; 0x802045 <__data_end+0x1>
     6d2:	05 c0       	rjmp	.+10     	; 0x6de <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     6d4:	c0 e0       	ldi	r28, 0x00	; 0
     6d6:	d0 e0       	ldi	r29, 0x00	; 0
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <pvPortMalloc+0x40>
     6da:	c0 e0       	ldi	r28, 0x00	; 0
     6dc:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     6de:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     6e2:	ce 01       	movw	r24, r28
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ea:	08 95       	ret

000006ec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6ec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ee:	03 96       	adiw	r24, 0x03	; 3
     6f0:	81 83       	std	Z+1, r24	; 0x01
     6f2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6f4:	4f ef       	ldi	r20, 0xFF	; 255
     6f6:	5f ef       	ldi	r21, 0xFF	; 255
     6f8:	ba 01       	movw	r22, r20
     6fa:	43 83       	std	Z+3, r20	; 0x03
     6fc:	54 83       	std	Z+4, r21	; 0x04
     6fe:	65 83       	std	Z+5, r22	; 0x05
     700:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     702:	87 83       	std	Z+7, r24	; 0x07
     704:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     706:	81 87       	std	Z+9, r24	; 0x09
     708:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     70a:	10 82       	st	Z, r1
     70c:	08 95       	ret

0000070e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     70e:	fc 01       	movw	r30, r24
     710:	12 86       	std	Z+10, r1	; 0x0a
     712:	13 86       	std	Z+11, r1	; 0x0b
     714:	08 95       	ret

00000716 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     716:	cf 93       	push	r28
     718:	df 93       	push	r29
     71a:	9c 01       	movw	r18, r24
     71c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     71e:	dc 01       	movw	r26, r24
     720:	11 96       	adiw	r26, 0x01	; 1
     722:	cd 91       	ld	r28, X+
     724:	dc 91       	ld	r29, X
     726:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     728:	c4 83       	std	Z+4, r28	; 0x04
     72a:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     72c:	8e 81       	ldd	r24, Y+6	; 0x06
     72e:	9f 81       	ldd	r25, Y+7	; 0x07
     730:	86 83       	std	Z+6, r24	; 0x06
     732:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     734:	8e 81       	ldd	r24, Y+6	; 0x06
     736:	9f 81       	ldd	r25, Y+7	; 0x07
     738:	dc 01       	movw	r26, r24
     73a:	14 96       	adiw	r26, 0x04	; 4
     73c:	6d 93       	st	X+, r22
     73e:	7c 93       	st	X, r23
     740:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     742:	6e 83       	std	Y+6, r22	; 0x06
     744:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     746:	22 87       	std	Z+10, r18	; 0x0a
     748:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     74a:	f9 01       	movw	r30, r18
     74c:	80 81       	ld	r24, Z
     74e:	8f 5f       	subi	r24, 0xFF	; 255
     750:	80 83       	st	Z, r24
}
     752:	df 91       	pop	r29
     754:	cf 91       	pop	r28
     756:	08 95       	ret

00000758 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     758:	0f 93       	push	r16
     75a:	1f 93       	push	r17
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     762:	08 81       	ld	r16, Y
     764:	19 81       	ldd	r17, Y+1	; 0x01
     766:	2a 81       	ldd	r18, Y+2	; 0x02
     768:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     76a:	0f 3f       	cpi	r16, 0xFF	; 255
     76c:	4f ef       	ldi	r20, 0xFF	; 255
     76e:	14 07       	cpc	r17, r20
     770:	24 07       	cpc	r18, r20
     772:	34 07       	cpc	r19, r20
     774:	21 f4       	brne	.+8      	; 0x77e <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     776:	fc 01       	movw	r30, r24
     778:	a1 85       	ldd	r26, Z+9	; 0x09
     77a:	b2 85       	ldd	r27, Z+10	; 0x0a
     77c:	11 c0       	rjmp	.+34     	; 0x7a0 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     77e:	dc 01       	movw	r26, r24
     780:	13 96       	adiw	r26, 0x03	; 3
     782:	01 c0       	rjmp	.+2      	; 0x786 <vListInsert+0x2e>
     784:	df 01       	movw	r26, r30
     786:	14 96       	adiw	r26, 0x04	; 4
     788:	ed 91       	ld	r30, X+
     78a:	fc 91       	ld	r31, X
     78c:	15 97       	sbiw	r26, 0x05	; 5
     78e:	40 81       	ld	r20, Z
     790:	51 81       	ldd	r21, Z+1	; 0x01
     792:	62 81       	ldd	r22, Z+2	; 0x02
     794:	73 81       	ldd	r23, Z+3	; 0x03
     796:	04 17       	cp	r16, r20
     798:	15 07       	cpc	r17, r21
     79a:	26 07       	cpc	r18, r22
     79c:	37 07       	cpc	r19, r23
     79e:	90 f7       	brcc	.-28     	; 0x784 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     7a0:	14 96       	adiw	r26, 0x04	; 4
     7a2:	ed 91       	ld	r30, X+
     7a4:	fc 91       	ld	r31, X
     7a6:	15 97       	sbiw	r26, 0x05	; 5
     7a8:	ec 83       	std	Y+4, r30	; 0x04
     7aa:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     7ac:	c6 83       	std	Z+6, r28	; 0x06
     7ae:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     7b0:	ae 83       	std	Y+6, r26	; 0x06
     7b2:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     7b4:	14 96       	adiw	r26, 0x04	; 4
     7b6:	cd 93       	st	X+, r28
     7b8:	dc 93       	st	X, r29
     7ba:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7bc:	8a 87       	std	Y+10, r24	; 0x0a
     7be:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     7c0:	fc 01       	movw	r30, r24
     7c2:	20 81       	ld	r18, Z
     7c4:	2f 5f       	subi	r18, 0xFF	; 255
     7c6:	20 83       	st	Z, r18
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	1f 91       	pop	r17
     7ce:	0f 91       	pop	r16
     7d0:	08 95       	ret

000007d2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     7d8:	a2 85       	ldd	r26, Z+10	; 0x0a
     7da:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7dc:	c4 81       	ldd	r28, Z+4	; 0x04
     7de:	d5 81       	ldd	r29, Z+5	; 0x05
     7e0:	86 81       	ldd	r24, Z+6	; 0x06
     7e2:	97 81       	ldd	r25, Z+7	; 0x07
     7e4:	8e 83       	std	Y+6, r24	; 0x06
     7e6:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7e8:	c6 81       	ldd	r28, Z+6	; 0x06
     7ea:	d7 81       	ldd	r29, Z+7	; 0x07
     7ec:	84 81       	ldd	r24, Z+4	; 0x04
     7ee:	95 81       	ldd	r25, Z+5	; 0x05
     7f0:	8c 83       	std	Y+4, r24	; 0x04
     7f2:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7f4:	11 96       	adiw	r26, 0x01	; 1
     7f6:	8d 91       	ld	r24, X+
     7f8:	9c 91       	ld	r25, X
     7fa:	12 97       	sbiw	r26, 0x02	; 2
     7fc:	e8 17       	cp	r30, r24
     7fe:	f9 07       	cpc	r31, r25
     800:	31 f4       	brne	.+12     	; 0x80e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     802:	86 81       	ldd	r24, Z+6	; 0x06
     804:	97 81       	ldd	r25, Z+7	; 0x07
     806:	11 96       	adiw	r26, 0x01	; 1
     808:	8d 93       	st	X+, r24
     80a:	9c 93       	st	X, r25
     80c:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     80e:	12 86       	std	Z+10, r1	; 0x0a
     810:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     812:	8c 91       	ld	r24, X
     814:	81 50       	subi	r24, 0x01	; 1
     816:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     818:	8c 91       	ld	r24, X
}
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     820:	e0 ea       	ldi	r30, 0xA0	; 160
     822:	f0 e0       	ldi	r31, 0x00	; 0
     824:	82 81       	ldd	r24, Z+2	; 0x02
     826:	92 81       	ldd	r25, Z+2	; 0x02
     828:	98 7f       	andi	r25, 0xF8	; 248
     82a:	92 83       	std	Z+2, r25	; 0x02
     82c:	08 95       	ret

0000082e <pxPortInitialiseStack>:
     82e:	cf 92       	push	r12
     830:	df 92       	push	r13
     832:	ef 92       	push	r14
     834:	ff 92       	push	r15
     836:	31 e1       	ldi	r19, 0x11	; 17
     838:	fc 01       	movw	r30, r24
     83a:	30 83       	st	Z, r19
     83c:	31 97       	sbiw	r30, 0x01	; 1
     83e:	22 e2       	ldi	r18, 0x22	; 34
     840:	20 83       	st	Z, r18
     842:	31 97       	sbiw	r30, 0x01	; 1
     844:	a3 e3       	ldi	r26, 0x33	; 51
     846:	a0 83       	st	Z, r26
     848:	6b 01       	movw	r12, r22
     84a:	e1 2c       	mov	r14, r1
     84c:	f1 2c       	mov	r15, r1
     84e:	31 97       	sbiw	r30, 0x01	; 1
     850:	60 83       	st	Z, r22
     852:	31 97       	sbiw	r30, 0x01	; 1
     854:	d0 82       	st	Z, r13
     856:	31 97       	sbiw	r30, 0x01	; 1
     858:	e0 82       	st	Z, r14
     85a:	31 97       	sbiw	r30, 0x01	; 1
     85c:	61 e3       	ldi	r22, 0x31	; 49
     85e:	60 83       	st	Z, r22
     860:	31 97       	sbiw	r30, 0x01	; 1
     862:	60 e8       	ldi	r22, 0x80	; 128
     864:	60 83       	st	Z, r22
     866:	31 97       	sbiw	r30, 0x01	; 1
     868:	67 e8       	ldi	r22, 0x87	; 135
     86a:	60 83       	st	Z, r22
     86c:	31 97       	sbiw	r30, 0x01	; 1
     86e:	10 82       	st	Z, r1
     870:	31 97       	sbiw	r30, 0x01	; 1
     872:	10 82       	st	Z, r1
     874:	31 97       	sbiw	r30, 0x01	; 1
     876:	62 e0       	ldi	r22, 0x02	; 2
     878:	60 83       	st	Z, r22
     87a:	31 97       	sbiw	r30, 0x01	; 1
     87c:	63 e0       	ldi	r22, 0x03	; 3
     87e:	60 83       	st	Z, r22
     880:	31 97       	sbiw	r30, 0x01	; 1
     882:	64 e0       	ldi	r22, 0x04	; 4
     884:	60 83       	st	Z, r22
     886:	31 97       	sbiw	r30, 0x01	; 1
     888:	65 e0       	ldi	r22, 0x05	; 5
     88a:	60 83       	st	Z, r22
     88c:	31 97       	sbiw	r30, 0x01	; 1
     88e:	66 e0       	ldi	r22, 0x06	; 6
     890:	60 83       	st	Z, r22
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	67 e0       	ldi	r22, 0x07	; 7
     896:	60 83       	st	Z, r22
     898:	31 97       	sbiw	r30, 0x01	; 1
     89a:	68 e0       	ldi	r22, 0x08	; 8
     89c:	60 83       	st	Z, r22
     89e:	31 97       	sbiw	r30, 0x01	; 1
     8a0:	69 e0       	ldi	r22, 0x09	; 9
     8a2:	60 83       	st	Z, r22
     8a4:	31 97       	sbiw	r30, 0x01	; 1
     8a6:	60 e1       	ldi	r22, 0x10	; 16
     8a8:	60 83       	st	Z, r22
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	30 83       	st	Z, r19
     8ae:	31 97       	sbiw	r30, 0x01	; 1
     8b0:	32 e1       	ldi	r19, 0x12	; 18
     8b2:	30 83       	st	Z, r19
     8b4:	31 97       	sbiw	r30, 0x01	; 1
     8b6:	33 e1       	ldi	r19, 0x13	; 19
     8b8:	30 83       	st	Z, r19
     8ba:	31 97       	sbiw	r30, 0x01	; 1
     8bc:	34 e1       	ldi	r19, 0x14	; 20
     8be:	30 83       	st	Z, r19
     8c0:	31 97       	sbiw	r30, 0x01	; 1
     8c2:	35 e1       	ldi	r19, 0x15	; 21
     8c4:	30 83       	st	Z, r19
     8c6:	31 97       	sbiw	r30, 0x01	; 1
     8c8:	36 e1       	ldi	r19, 0x16	; 22
     8ca:	30 83       	st	Z, r19
     8cc:	31 97       	sbiw	r30, 0x01	; 1
     8ce:	37 e1       	ldi	r19, 0x17	; 23
     8d0:	30 83       	st	Z, r19
     8d2:	31 97       	sbiw	r30, 0x01	; 1
     8d4:	38 e1       	ldi	r19, 0x18	; 24
     8d6:	30 83       	st	Z, r19
     8d8:	31 97       	sbiw	r30, 0x01	; 1
     8da:	39 e1       	ldi	r19, 0x19	; 25
     8dc:	30 83       	st	Z, r19
     8de:	31 97       	sbiw	r30, 0x01	; 1
     8e0:	30 e2       	ldi	r19, 0x20	; 32
     8e2:	30 83       	st	Z, r19
     8e4:	31 97       	sbiw	r30, 0x01	; 1
     8e6:	31 e2       	ldi	r19, 0x21	; 33
     8e8:	30 83       	st	Z, r19
     8ea:	31 97       	sbiw	r30, 0x01	; 1
     8ec:	20 83       	st	Z, r18
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	23 e2       	ldi	r18, 0x23	; 35
     8f2:	20 83       	st	Z, r18
     8f4:	6a 01       	movw	r12, r20
     8f6:	31 97       	sbiw	r30, 0x01	; 1
     8f8:	40 83       	st	Z, r20
     8fa:	31 97       	sbiw	r30, 0x01	; 1
     8fc:	d0 82       	st	Z, r13
     8fe:	31 97       	sbiw	r30, 0x01	; 1
     900:	26 e2       	ldi	r18, 0x26	; 38
     902:	20 83       	st	Z, r18
     904:	31 97       	sbiw	r30, 0x01	; 1
     906:	27 e2       	ldi	r18, 0x27	; 39
     908:	20 83       	st	Z, r18
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	28 e2       	ldi	r18, 0x28	; 40
     90e:	20 83       	st	Z, r18
     910:	31 97       	sbiw	r30, 0x01	; 1
     912:	29 e2       	ldi	r18, 0x29	; 41
     914:	20 83       	st	Z, r18
     916:	31 97       	sbiw	r30, 0x01	; 1
     918:	20 e3       	ldi	r18, 0x30	; 48
     91a:	20 83       	st	Z, r18
     91c:	88 97       	sbiw	r24, 0x28	; 40
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <xPortStartScheduler>:
     928:	83 ef       	ldi	r24, 0xF3	; 243
     92a:	91 e0       	ldi	r25, 0x01	; 1
     92c:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     930:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     934:	65 e0       	ldi	r22, 0x05	; 5
     936:	80 e0       	ldi	r24, 0x00	; 0
     938:	98 e0       	ldi	r25, 0x08	; 8
     93a:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigClockSource>
     93e:	61 e0       	ldi	r22, 0x01	; 1
     940:	80 e0       	ldi	r24, 0x00	; 0
     942:	98 e0       	ldi	r25, 0x08	; 8
     944:	0e 94 a2 01 	call	0x344	; 0x344 <TC0_SetOverflowIntLevel>
     948:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
     94c:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
     950:	0d 90       	ld	r0, X+
     952:	0d be       	out	0x3d, r0	; 61
     954:	0d 90       	ld	r0, X+
     956:	0e be       	out	0x3e, r0	; 62
     958:	ef 91       	pop	r30
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	bf 91       	pop	r27
     960:	af 91       	pop	r26
     962:	9f 91       	pop	r25
     964:	8f 91       	pop	r24
     966:	7f 91       	pop	r23
     968:	6f 91       	pop	r22
     96a:	5f 91       	pop	r21
     96c:	4f 91       	pop	r20
     96e:	3f 91       	pop	r19
     970:	2f 91       	pop	r18
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	ff 90       	pop	r15
     978:	ef 90       	pop	r14
     97a:	df 90       	pop	r13
     97c:	cf 90       	pop	r12
     97e:	bf 90       	pop	r11
     980:	af 90       	pop	r10
     982:	9f 90       	pop	r9
     984:	8f 90       	pop	r8
     986:	7f 90       	pop	r7
     988:	6f 90       	pop	r6
     98a:	5f 90       	pop	r5
     98c:	4f 90       	pop	r4
     98e:	3f 90       	pop	r3
     990:	2f 90       	pop	r2
     992:	1f 90       	pop	r1
     994:	0f 90       	pop	r0
     996:	ff 91       	pop	r31
     998:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     99c:	ff 91       	pop	r31
     99e:	ff bf       	out	0x3f, r31	; 63
     9a0:	ff 91       	pop	r31
     9a2:	08 95       	ret
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	08 95       	ret

000009a8 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9a8:	ff 93       	push	r31
     9aa:	ff b7       	in	r31, 0x3f	; 63
     9ac:	ff 93       	push	r31
     9ae:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     9b2:	ff 93       	push	r31
     9b4:	f8 7f       	andi	r31, 0xF8	; 248
     9b6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     9ba:	0f 92       	push	r0
     9bc:	1f 92       	push	r1
     9be:	11 24       	eor	r1, r1
     9c0:	2f 92       	push	r2
     9c2:	3f 92       	push	r3
     9c4:	4f 92       	push	r4
     9c6:	5f 92       	push	r5
     9c8:	6f 92       	push	r6
     9ca:	7f 92       	push	r7
     9cc:	8f 92       	push	r8
     9ce:	9f 92       	push	r9
     9d0:	af 92       	push	r10
     9d2:	bf 92       	push	r11
     9d4:	cf 92       	push	r12
     9d6:	df 92       	push	r13
     9d8:	ef 92       	push	r14
     9da:	ff 92       	push	r15
     9dc:	0f 93       	push	r16
     9de:	1f 93       	push	r17
     9e0:	2f 93       	push	r18
     9e2:	3f 93       	push	r19
     9e4:	4f 93       	push	r20
     9e6:	5f 93       	push	r21
     9e8:	6f 93       	push	r22
     9ea:	7f 93       	push	r23
     9ec:	8f 93       	push	r24
     9ee:	9f 93       	push	r25
     9f0:	af 93       	push	r26
     9f2:	bf 93       	push	r27
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	ef 93       	push	r30
     9fa:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
     9fe:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
     a02:	0d b6       	in	r0, 0x3d	; 61
     a04:	0d 92       	st	X+, r0
     a06:	0e b6       	in	r0, 0x3e	; 62
     a08:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a0a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a0e:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
     a12:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
     a16:	0d 90       	ld	r0, X+
     a18:	0d be       	out	0x3d, r0	; 61
     a1a:	0d 90       	ld	r0, X+
     a1c:	0e be       	out	0x3e, r0	; 62
     a1e:	ef 91       	pop	r30
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	bf 91       	pop	r27
     a26:	af 91       	pop	r26
     a28:	9f 91       	pop	r25
     a2a:	8f 91       	pop	r24
     a2c:	7f 91       	pop	r23
     a2e:	6f 91       	pop	r22
     a30:	5f 91       	pop	r21
     a32:	4f 91       	pop	r20
     a34:	3f 91       	pop	r19
     a36:	2f 91       	pop	r18
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	ff 90       	pop	r15
     a3e:	ef 90       	pop	r14
     a40:	df 90       	pop	r13
     a42:	cf 90       	pop	r12
     a44:	bf 90       	pop	r11
     a46:	af 90       	pop	r10
     a48:	9f 90       	pop	r9
     a4a:	8f 90       	pop	r8
     a4c:	7f 90       	pop	r7
     a4e:	6f 90       	pop	r6
     a50:	5f 90       	pop	r5
     a52:	4f 90       	pop	r4
     a54:	3f 90       	pop	r3
     a56:	2f 90       	pop	r2
     a58:	1f 90       	pop	r1
     a5a:	0f 90       	pop	r0
     a5c:	ff 91       	pop	r31
     a5e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     a62:	ff 91       	pop	r31
     a64:	ff bf       	out	0x3f, r31	; 63
     a66:	ff 91       	pop	r31
	asm volatile ( "ret" );
     a68:	08 95       	ret

00000a6a <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     a6a:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     a6c:	90 91 bc 2c 	lds	r25, 0x2CBC	; 0x802cbc <intTaskSwitchPending>
     a70:	89 2b       	or	r24, r25
     a72:	80 93 bc 2c 	sts	0x2CBC, r24	; 0x802cbc <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     a76:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a7a:	91 30       	cpi	r25, 0x01	; 1
     a7c:	41 f0       	breq	.+16     	; 0xa8e <portTaskSwitchContext+0x24>
     a7e:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a82:	92 30       	cpi	r25, 0x02	; 2
     a84:	21 f0       	breq	.+8      	; 0xa8e <portTaskSwitchContext+0x24>
     a86:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     a8a:	94 30       	cpi	r25, 0x04	; 4
     a8c:	59 f4       	brne	.+22     	; 0xaa4 <portTaskSwitchContext+0x3a>
     a8e:	88 23       	and	r24, r24
     a90:	49 f0       	breq	.+18     	; 0xaa4 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     a92:	0e 94 10 04 	call	0x820	; 0x820 <_portSetInterruptMaskFromIsr>
     a96:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     a98:	10 92 bc 2c 	sts	0x2CBC, r1	; 0x802cbc <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     a9c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     aa0:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     aa8:	ff 93       	push	r31
     aaa:	ff b7       	in	r31, 0x3f	; 63
     aac:	ff 93       	push	r31
     aae:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ab2:	ff 93       	push	r31
     ab4:	f8 7f       	andi	r31, 0xF8	; 248
     ab6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     aba:	0f 92       	push	r0
     abc:	1f 92       	push	r1
     abe:	11 24       	eor	r1, r1
     ac0:	2f 92       	push	r2
     ac2:	3f 92       	push	r3
     ac4:	4f 92       	push	r4
     ac6:	5f 92       	push	r5
     ac8:	6f 92       	push	r6
     aca:	7f 92       	push	r7
     acc:	8f 92       	push	r8
     ace:	9f 92       	push	r9
     ad0:	af 92       	push	r10
     ad2:	bf 92       	push	r11
     ad4:	cf 92       	push	r12
     ad6:	df 92       	push	r13
     ad8:	ef 92       	push	r14
     ada:	ff 92       	push	r15
     adc:	0f 93       	push	r16
     ade:	1f 93       	push	r17
     ae0:	2f 93       	push	r18
     ae2:	3f 93       	push	r19
     ae4:	4f 93       	push	r20
     ae6:	5f 93       	push	r21
     ae8:	6f 93       	push	r22
     aea:	7f 93       	push	r23
     aec:	8f 93       	push	r24
     aee:	9f 93       	push	r25
     af0:	af 93       	push	r26
     af2:	bf 93       	push	r27
     af4:	cf 93       	push	r28
     af6:	df 93       	push	r29
     af8:	ef 93       	push	r30
     afa:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
     afe:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
     b02:	0d b6       	in	r0, 0x3d	; 61
     b04:	0d 92       	st	X+, r0
     b06:	0e b6       	in	r0, 0x3e	; 62
     b08:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     b0a:	0e 94 10 04 	call	0x820	; 0x820 <_portSetInterruptMaskFromIsr>
     b0e:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     b10:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     b14:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	0e 94 35 05 	call	0xa6a	; 0xa6a <portTaskSwitchContext>
     b1e:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
     b22:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
     b26:	0d 90       	ld	r0, X+
     b28:	0d be       	out	0x3d, r0	; 61
     b2a:	0d 90       	ld	r0, X+
     b2c:	0e be       	out	0x3e, r0	; 62
     b2e:	ef 91       	pop	r30
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	bf 91       	pop	r27
     b36:	af 91       	pop	r26
     b38:	9f 91       	pop	r25
     b3a:	8f 91       	pop	r24
     b3c:	7f 91       	pop	r23
     b3e:	6f 91       	pop	r22
     b40:	5f 91       	pop	r21
     b42:	4f 91       	pop	r20
     b44:	3f 91       	pop	r19
     b46:	2f 91       	pop	r18
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	ff 90       	pop	r15
     b4e:	ef 90       	pop	r14
     b50:	df 90       	pop	r13
     b52:	cf 90       	pop	r12
     b54:	bf 90       	pop	r11
     b56:	af 90       	pop	r10
     b58:	9f 90       	pop	r9
     b5a:	8f 90       	pop	r8
     b5c:	7f 90       	pop	r7
     b5e:	6f 90       	pop	r6
     b60:	5f 90       	pop	r5
     b62:	4f 90       	pop	r4
     b64:	3f 90       	pop	r3
     b66:	2f 90       	pop	r2
     b68:	1f 90       	pop	r1
     b6a:	0f 90       	pop	r0
     b6c:	ff 91       	pop	r31
     b6e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b72:	ff 91       	pop	r31
     b74:	ff bf       	out	0x3f, r31	; 63
     b76:	ff 91       	pop	r31
     b78:	18 95       	reti

00000b7a <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     b7a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b7e:	ff 93       	push	r31
     b80:	f8 7f       	andi	r31, 0xF8	; 248
     b82:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b86:	fc 01       	movw	r30, r24
     b88:	96 8d       	ldd	r25, Z+30	; 0x1e
     b8a:	ff 91       	pop	r31
     b8c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	91 11       	cpse	r25, r1
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	08 95       	ret

00000b98 <prvIsQueueFull>:
     b98:	dc 01       	movw	r26, r24
     b9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b9e:	ff 93       	push	r31
     ba0:	f8 7f       	andi	r31, 0xF8	; 248
     ba2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba6:	5e 96       	adiw	r26, 0x1e	; 30
     ba8:	9c 91       	ld	r25, X
     baa:	5e 97       	sbiw	r26, 0x1e	; 30
     bac:	ff 91       	pop	r31
     bae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     bb2:	81 e0       	ldi	r24, 0x01	; 1
     bb4:	5f 96       	adiw	r26, 0x1f	; 31
     bb6:	2c 91       	ld	r18, X
     bb8:	29 13       	cpse	r18, r25
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	08 95       	ret

00000bbe <prvCopyDataToQueue>:
     bbe:	0f 93       	push	r16
     bc0:	1f 93       	push	r17
     bc2:	cf 93       	push	r28
     bc4:	df 93       	push	r29
     bc6:	ec 01       	movw	r28, r24
     bc8:	04 2f       	mov	r16, r20
     bca:	1e 8d       	ldd	r17, Y+30	; 0x1e
     bcc:	48 a1       	ldd	r20, Y+32	; 0x20
     bce:	41 11       	cpse	r20, r1
     bd0:	0c c0       	rjmp	.+24     	; 0xbea <prvCopyDataToQueue+0x2c>
     bd2:	88 81       	ld	r24, Y
     bd4:	99 81       	ldd	r25, Y+1	; 0x01
     bd6:	89 2b       	or	r24, r25
     bd8:	09 f0       	breq	.+2      	; 0xbdc <prvCopyDataToQueue+0x1e>
     bda:	42 c0       	rjmp	.+132    	; 0xc60 <prvCopyDataToQueue+0xa2>
     bdc:	8a 81       	ldd	r24, Y+2	; 0x02
     bde:	9b 81       	ldd	r25, Y+3	; 0x03
     be0:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <xTaskPriorityDisinherit>
     be4:	1a 82       	std	Y+2, r1	; 0x02
     be6:	1b 82       	std	Y+3, r1	; 0x03
     be8:	42 c0       	rjmp	.+132    	; 0xc6e <prvCopyDataToQueue+0xb0>
     bea:	01 11       	cpse	r16, r1
     bec:	17 c0       	rjmp	.+46     	; 0xc1c <prvCopyDataToQueue+0x5e>
     bee:	50 e0       	ldi	r21, 0x00	; 0
     bf0:	8c 81       	ldd	r24, Y+4	; 0x04
     bf2:	9d 81       	ldd	r25, Y+5	; 0x05
     bf4:	0e 94 76 1e 	call	0x3cec	; 0x3cec <memcpy>
     bf8:	28 a1       	ldd	r18, Y+32	; 0x20
     bfa:	8c 81       	ldd	r24, Y+4	; 0x04
     bfc:	9d 81       	ldd	r25, Y+5	; 0x05
     bfe:	82 0f       	add	r24, r18
     c00:	91 1d       	adc	r25, r1
     c02:	8c 83       	std	Y+4, r24	; 0x04
     c04:	9d 83       	std	Y+5, r25	; 0x05
     c06:	2a 81       	ldd	r18, Y+2	; 0x02
     c08:	3b 81       	ldd	r19, Y+3	; 0x03
     c0a:	82 17       	cp	r24, r18
     c0c:	93 07       	cpc	r25, r19
     c0e:	50 f1       	brcs	.+84     	; 0xc64 <prvCopyDataToQueue+0xa6>
     c10:	88 81       	ld	r24, Y
     c12:	99 81       	ldd	r25, Y+1	; 0x01
     c14:	8c 83       	std	Y+4, r24	; 0x04
     c16:	9d 83       	std	Y+5, r25	; 0x05
     c18:	80 e0       	ldi	r24, 0x00	; 0
     c1a:	29 c0       	rjmp	.+82     	; 0xc6e <prvCopyDataToQueue+0xb0>
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	8e 81       	ldd	r24, Y+6	; 0x06
     c20:	9f 81       	ldd	r25, Y+7	; 0x07
     c22:	0e 94 76 1e 	call	0x3cec	; 0x3cec <memcpy>
     c26:	88 a1       	ldd	r24, Y+32	; 0x20
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	91 95       	neg	r25
     c2c:	81 95       	neg	r24
     c2e:	91 09       	sbc	r25, r1
     c30:	2e 81       	ldd	r18, Y+6	; 0x06
     c32:	3f 81       	ldd	r19, Y+7	; 0x07
     c34:	28 0f       	add	r18, r24
     c36:	39 1f       	adc	r19, r25
     c38:	2e 83       	std	Y+6, r18	; 0x06
     c3a:	3f 83       	std	Y+7, r19	; 0x07
     c3c:	48 81       	ld	r20, Y
     c3e:	59 81       	ldd	r21, Y+1	; 0x01
     c40:	24 17       	cp	r18, r20
     c42:	35 07       	cpc	r19, r21
     c44:	30 f4       	brcc	.+12     	; 0xc52 <prvCopyDataToQueue+0x94>
     c46:	2a 81       	ldd	r18, Y+2	; 0x02
     c48:	3b 81       	ldd	r19, Y+3	; 0x03
     c4a:	82 0f       	add	r24, r18
     c4c:	93 1f       	adc	r25, r19
     c4e:	8e 83       	std	Y+6, r24	; 0x06
     c50:	9f 83       	std	Y+7, r25	; 0x07
     c52:	02 30       	cpi	r16, 0x02	; 2
     c54:	49 f4       	brne	.+18     	; 0xc68 <prvCopyDataToQueue+0xaa>
     c56:	11 23       	and	r17, r17
     c58:	49 f0       	breq	.+18     	; 0xc6c <prvCopyDataToQueue+0xae>
     c5a:	11 50       	subi	r17, 0x01	; 1
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	07 c0       	rjmp	.+14     	; 0xc6e <prvCopyDataToQueue+0xb0>
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	05 c0       	rjmp	.+10     	; 0xc6e <prvCopyDataToQueue+0xb0>
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	03 c0       	rjmp	.+6      	; 0xc6e <prvCopyDataToQueue+0xb0>
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	01 c0       	rjmp	.+2      	; 0xc6e <prvCopyDataToQueue+0xb0>
     c6c:	80 e0       	ldi	r24, 0x00	; 0
     c6e:	1f 5f       	subi	r17, 0xFF	; 255
     c70:	1e 8f       	std	Y+30, r17	; 0x1e
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	08 95       	ret

00000c7c <prvCopyDataFromQueue>:
     c7c:	fc 01       	movw	r30, r24
     c7e:	40 a1       	ldd	r20, Z+32	; 0x20
     c80:	44 23       	and	r20, r20
     c82:	a9 f0       	breq	.+42     	; 0xcae <prvCopyDataFromQueue+0x32>
     c84:	50 e0       	ldi	r21, 0x00	; 0
     c86:	26 81       	ldd	r18, Z+6	; 0x06
     c88:	37 81       	ldd	r19, Z+7	; 0x07
     c8a:	24 0f       	add	r18, r20
     c8c:	35 1f       	adc	r19, r21
     c8e:	26 83       	std	Z+6, r18	; 0x06
     c90:	37 83       	std	Z+7, r19	; 0x07
     c92:	82 81       	ldd	r24, Z+2	; 0x02
     c94:	93 81       	ldd	r25, Z+3	; 0x03
     c96:	28 17       	cp	r18, r24
     c98:	39 07       	cpc	r19, r25
     c9a:	20 f0       	brcs	.+8      	; 0xca4 <prvCopyDataFromQueue+0x28>
     c9c:	80 81       	ld	r24, Z
     c9e:	91 81       	ldd	r25, Z+1	; 0x01
     ca0:	86 83       	std	Z+6, r24	; 0x06
     ca2:	97 83       	std	Z+7, r25	; 0x07
     ca4:	cb 01       	movw	r24, r22
     ca6:	66 81       	ldd	r22, Z+6	; 0x06
     ca8:	77 81       	ldd	r23, Z+7	; 0x07
     caa:	0e 94 76 1e 	call	0x3cec	; 0x3cec <memcpy>
     cae:	08 95       	ret

00000cb0 <prvUnlockQueue>:
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	8c 01       	movw	r16, r24
     cbc:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cc0:	ff 93       	push	r31
     cc2:	f8 7f       	andi	r31, 0xF8	; 248
     cc4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cc8:	fc 01       	movw	r30, r24
     cca:	c2 a1       	ldd	r28, Z+34	; 0x22
     ccc:	1c 16       	cp	r1, r28
     cce:	ac f4       	brge	.+42     	; 0xcfa <prvUnlockQueue+0x4a>
     cd0:	83 89       	ldd	r24, Z+19	; 0x13
     cd2:	81 11       	cpse	r24, r1
     cd4:	06 c0       	rjmp	.+12     	; 0xce2 <prvUnlockQueue+0x32>
     cd6:	11 c0       	rjmp	.+34     	; 0xcfa <prvUnlockQueue+0x4a>
     cd8:	f8 01       	movw	r30, r16
     cda:	83 89       	ldd	r24, Z+19	; 0x13
     cdc:	81 11       	cpse	r24, r1
     cde:	05 c0       	rjmp	.+10     	; 0xcea <prvUnlockQueue+0x3a>
     ce0:	0c c0       	rjmp	.+24     	; 0xcfa <prvUnlockQueue+0x4a>
     ce2:	78 01       	movw	r14, r16
     ce4:	f3 e1       	ldi	r31, 0x13	; 19
     ce6:	ef 0e       	add	r14, r31
     ce8:	f1 1c       	adc	r15, r1
     cea:	c7 01       	movw	r24, r14
     cec:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
     cf0:	81 11       	cpse	r24, r1
     cf2:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskMissedYield>
     cf6:	c1 50       	subi	r28, 0x01	; 1
     cf8:	79 f7       	brne	.-34     	; 0xcd8 <prvUnlockQueue+0x28>
     cfa:	8f ef       	ldi	r24, 0xFF	; 255
     cfc:	f8 01       	movw	r30, r16
     cfe:	82 a3       	std	Z+34, r24	; 0x22
     d00:	ff 91       	pop	r31
     d02:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d06:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d0a:	ff 93       	push	r31
     d0c:	f8 7f       	andi	r31, 0xF8	; 248
     d0e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d12:	f8 01       	movw	r30, r16
     d14:	c1 a1       	ldd	r28, Z+33	; 0x21
     d16:	1c 16       	cp	r1, r28
     d18:	ac f4       	brge	.+42     	; 0xd44 <prvUnlockQueue+0x94>
     d1a:	80 85       	ldd	r24, Z+8	; 0x08
     d1c:	81 11       	cpse	r24, r1
     d1e:	06 c0       	rjmp	.+12     	; 0xd2c <prvUnlockQueue+0x7c>
     d20:	11 c0       	rjmp	.+34     	; 0xd44 <prvUnlockQueue+0x94>
     d22:	f8 01       	movw	r30, r16
     d24:	80 85       	ldd	r24, Z+8	; 0x08
     d26:	81 11       	cpse	r24, r1
     d28:	05 c0       	rjmp	.+10     	; 0xd34 <prvUnlockQueue+0x84>
     d2a:	0c c0       	rjmp	.+24     	; 0xd44 <prvUnlockQueue+0x94>
     d2c:	78 01       	movw	r14, r16
     d2e:	f8 e0       	ldi	r31, 0x08	; 8
     d30:	ef 0e       	add	r14, r31
     d32:	f1 1c       	adc	r15, r1
     d34:	c7 01       	movw	r24, r14
     d36:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
     d3a:	81 11       	cpse	r24, r1
     d3c:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskMissedYield>
     d40:	c1 50       	subi	r28, 0x01	; 1
     d42:	79 f7       	brne	.-34     	; 0xd22 <prvUnlockQueue+0x72>
     d44:	8f ef       	ldi	r24, 0xFF	; 255
     d46:	f8 01       	movw	r30, r16
     d48:	81 a3       	std	Z+33, r24	; 0x21
     d4a:	ff 91       	pop	r31
     d4c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d50:	cf 91       	pop	r28
     d52:	1f 91       	pop	r17
     d54:	0f 91       	pop	r16
     d56:	ff 90       	pop	r15
     d58:	ef 90       	pop	r14
     d5a:	08 95       	ret

00000d5c <xQueueGenericReset>:
     d5c:	cf 93       	push	r28
     d5e:	df 93       	push	r29
     d60:	ec 01       	movw	r28, r24
     d62:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d66:	ff 93       	push	r31
     d68:	f8 7f       	andi	r31, 0xF8	; 248
     d6a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d6e:	48 81       	ld	r20, Y
     d70:	59 81       	ldd	r21, Y+1	; 0x01
     d72:	28 a1       	ldd	r18, Y+32	; 0x20
     d74:	30 e0       	ldi	r19, 0x00	; 0
     d76:	7f 8d       	ldd	r23, Y+31	; 0x1f
     d78:	72 9f       	mul	r23, r18
     d7a:	c0 01       	movw	r24, r0
     d7c:	73 9f       	mul	r23, r19
     d7e:	90 0d       	add	r25, r0
     d80:	11 24       	eor	r1, r1
     d82:	fa 01       	movw	r30, r20
     d84:	e8 0f       	add	r30, r24
     d86:	f9 1f       	adc	r31, r25
     d88:	ea 83       	std	Y+2, r30	; 0x02
     d8a:	fb 83       	std	Y+3, r31	; 0x03
     d8c:	1e 8e       	std	Y+30, r1	; 0x1e
     d8e:	4c 83       	std	Y+4, r20	; 0x04
     d90:	5d 83       	std	Y+5, r21	; 0x05
     d92:	82 1b       	sub	r24, r18
     d94:	93 0b       	sbc	r25, r19
     d96:	84 0f       	add	r24, r20
     d98:	95 1f       	adc	r25, r21
     d9a:	8e 83       	std	Y+6, r24	; 0x06
     d9c:	9f 83       	std	Y+7, r25	; 0x07
     d9e:	8f ef       	ldi	r24, 0xFF	; 255
     da0:	89 a3       	std	Y+33, r24	; 0x21
     da2:	8a a3       	std	Y+34, r24	; 0x22
     da4:	61 11       	cpse	r22, r1
     da6:	0c c0       	rjmp	.+24     	; 0xdc0 <xQueueGenericReset+0x64>
     da8:	88 85       	ldd	r24, Y+8	; 0x08
     daa:	88 23       	and	r24, r24
     dac:	89 f0       	breq	.+34     	; 0xdd0 <xQueueGenericReset+0x74>
     dae:	ce 01       	movw	r24, r28
     db0:	08 96       	adiw	r24, 0x08	; 8
     db2:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
     db6:	88 23       	and	r24, r24
     db8:	59 f0       	breq	.+22     	; 0xdd0 <xQueueGenericReset+0x74>
     dba:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
     dbe:	08 c0       	rjmp	.+16     	; 0xdd0 <xQueueGenericReset+0x74>
     dc0:	ce 01       	movw	r24, r28
     dc2:	08 96       	adiw	r24, 0x08	; 8
     dc4:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
     dc8:	ce 01       	movw	r24, r28
     dca:	43 96       	adiw	r24, 0x13	; 19
     dcc:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
     dd0:	ff 91       	pop	r31
     dd2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	08 95       	ret

00000dde <xQueueGenericCreate>:
     dde:	ff 92       	push	r15
     de0:	0f 93       	push	r16
     de2:	1f 93       	push	r17
     de4:	cf 93       	push	r28
     de6:	df 93       	push	r29
     de8:	08 2f       	mov	r16, r24
     dea:	16 2f       	mov	r17, r22
     dec:	f4 2e       	mov	r15, r20
     dee:	66 23       	and	r22, r22
     df0:	c9 f0       	breq	.+50     	; 0xe24 <xQueueGenericCreate+0x46>
     df2:	86 9f       	mul	r24, r22
     df4:	c0 01       	movw	r24, r0
     df6:	11 24       	eor	r1, r1
     df8:	85 96       	adiw	r24, 0x25	; 37
     dfa:	0e 94 4f 03 	call	0x69e	; 0x69e <pvPortMalloc>
     dfe:	ec 01       	movw	r28, r24
     e00:	00 97       	sbiw	r24, 0x00	; 0
     e02:	49 f4       	brne	.+18     	; 0xe16 <xQueueGenericCreate+0x38>
     e04:	16 c0       	rjmp	.+44     	; 0xe32 <xQueueGenericCreate+0x54>
     e06:	0f 8f       	std	Y+31, r16	; 0x1f
     e08:	18 a3       	std	Y+32, r17	; 0x20
     e0a:	61 e0       	ldi	r22, 0x01	; 1
     e0c:	ce 01       	movw	r24, r28
     e0e:	0e 94 ae 06 	call	0xd5c	; 0xd5c <xQueueGenericReset>
     e12:	fc a2       	std	Y+36, r15	; 0x24
     e14:	0e c0       	rjmp	.+28     	; 0xe32 <xQueueGenericCreate+0x54>
     e16:	85 96       	adiw	r24, 0x25	; 37
     e18:	88 83       	st	Y, r24
     e1a:	99 83       	std	Y+1, r25	; 0x01
     e1c:	f4 cf       	rjmp	.-24     	; 0xe06 <xQueueGenericCreate+0x28>
     e1e:	c8 83       	st	Y, r28
     e20:	d9 83       	std	Y+1, r29	; 0x01
     e22:	f1 cf       	rjmp	.-30     	; 0xe06 <xQueueGenericCreate+0x28>
     e24:	85 e2       	ldi	r24, 0x25	; 37
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	0e 94 4f 03 	call	0x69e	; 0x69e <pvPortMalloc>
     e2c:	ec 01       	movw	r28, r24
     e2e:	89 2b       	or	r24, r25
     e30:	b1 f7       	brne	.-20     	; 0xe1e <xQueueGenericCreate+0x40>
     e32:	ce 01       	movw	r24, r28
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	1f 91       	pop	r17
     e3a:	0f 91       	pop	r16
     e3c:	ff 90       	pop	r15
     e3e:	08 95       	ret

00000e40 <xQueueGenericSend>:
     e40:	af 92       	push	r10
     e42:	bf 92       	push	r11
     e44:	cf 92       	push	r12
     e46:	df 92       	push	r13
     e48:	ef 92       	push	r14
     e4a:	ff 92       	push	r15
     e4c:	0f 93       	push	r16
     e4e:	1f 93       	push	r17
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	cd b7       	in	r28, 0x3d	; 61
     e56:	de b7       	in	r29, 0x3e	; 62
     e58:	29 97       	sbiw	r28, 0x09	; 9
     e5a:	cd bf       	out	0x3d, r28	; 61
     e5c:	de bf       	out	0x3e, r29	; 62
     e5e:	7c 01       	movw	r14, r24
     e60:	5b 01       	movw	r10, r22
     e62:	2e 83       	std	Y+6, r18	; 0x06
     e64:	3f 83       	std	Y+7, r19	; 0x07
     e66:	48 87       	std	Y+8, r20	; 0x08
     e68:	59 87       	std	Y+9, r21	; 0x09
     e6a:	10 e0       	ldi	r17, 0x00	; 0
     e6c:	6c 01       	movw	r12, r24
     e6e:	88 e0       	ldi	r24, 0x08	; 8
     e70:	c8 0e       	add	r12, r24
     e72:	d1 1c       	adc	r13, r1
     e74:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e78:	ff 93       	push	r31
     e7a:	f8 7f       	andi	r31, 0xF8	; 248
     e7c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e80:	f7 01       	movw	r30, r14
     e82:	96 8d       	ldd	r25, Z+30	; 0x1e
     e84:	87 8d       	ldd	r24, Z+31	; 0x1f
     e86:	98 17       	cp	r25, r24
     e88:	10 f0       	brcs	.+4      	; 0xe8e <xQueueGenericSend+0x4e>
     e8a:	02 30       	cpi	r16, 0x02	; 2
     e8c:	d1 f4       	brne	.+52     	; 0xec2 <xQueueGenericSend+0x82>
     e8e:	40 2f       	mov	r20, r16
     e90:	b5 01       	movw	r22, r10
     e92:	c7 01       	movw	r24, r14
     e94:	0e 94 df 05 	call	0xbbe	; 0xbbe <prvCopyDataToQueue>
     e98:	f7 01       	movw	r30, r14
     e9a:	93 89       	ldd	r25, Z+19	; 0x13
     e9c:	99 23       	and	r25, r25
     e9e:	49 f0       	breq	.+18     	; 0xeb2 <xQueueGenericSend+0x72>
     ea0:	c7 01       	movw	r24, r14
     ea2:	43 96       	adiw	r24, 0x13	; 19
     ea4:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
     ea8:	88 23       	and	r24, r24
     eaa:	31 f0       	breq	.+12     	; 0xeb8 <xQueueGenericSend+0x78>
     eac:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
     eb0:	03 c0       	rjmp	.+6      	; 0xeb8 <xQueueGenericSend+0x78>
     eb2:	81 11       	cpse	r24, r1
     eb4:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
     eb8:	ff 91       	pop	r31
     eba:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	57 c0       	rjmp	.+174    	; 0xf70 <xQueueGenericSend+0x130>
     ec2:	8e 81       	ldd	r24, Y+6	; 0x06
     ec4:	9f 81       	ldd	r25, Y+7	; 0x07
     ec6:	a8 85       	ldd	r26, Y+8	; 0x08
     ec8:	b9 85       	ldd	r27, Y+9	; 0x09
     eca:	89 2b       	or	r24, r25
     ecc:	8a 2b       	or	r24, r26
     ece:	8b 2b       	or	r24, r27
     ed0:	29 f4       	brne	.+10     	; 0xedc <xQueueGenericSend+0x9c>
     ed2:	ff 91       	pop	r31
     ed4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	4a c0       	rjmp	.+148    	; 0xf70 <xQueueGenericSend+0x130>
     edc:	11 11       	cpse	r17, r1
     ede:	05 c0       	rjmp	.+10     	; 0xeea <xQueueGenericSend+0xaa>
     ee0:	ce 01       	movw	r24, r28
     ee2:	01 96       	adiw	r24, 0x01	; 1
     ee4:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <vTaskInternalSetTimeOutState>
     ee8:	11 e0       	ldi	r17, 0x01	; 1
     eea:	ff 91       	pop	r31
     eec:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ef0:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
     ef4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ef8:	ff 93       	push	r31
     efa:	f8 7f       	andi	r31, 0xF8	; 248
     efc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f00:	f7 01       	movw	r30, r14
     f02:	81 a1       	ldd	r24, Z+33	; 0x21
     f04:	8f 3f       	cpi	r24, 0xFF	; 255
     f06:	09 f4       	brne	.+2      	; 0xf0a <xQueueGenericSend+0xca>
     f08:	11 a2       	std	Z+33, r1	; 0x21
     f0a:	f7 01       	movw	r30, r14
     f0c:	82 a1       	ldd	r24, Z+34	; 0x22
     f0e:	8f 3f       	cpi	r24, 0xFF	; 255
     f10:	09 f4       	brne	.+2      	; 0xf14 <xQueueGenericSend+0xd4>
     f12:	12 a2       	std	Z+34, r1	; 0x22
     f14:	ff 91       	pop	r31
     f16:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f1a:	be 01       	movw	r22, r28
     f1c:	6a 5f       	subi	r22, 0xFA	; 250
     f1e:	7f 4f       	sbci	r23, 0xFF	; 255
     f20:	ce 01       	movw	r24, r28
     f22:	01 96       	adiw	r24, 0x01	; 1
     f24:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <xTaskCheckForTimeOut>
     f28:	81 11       	cpse	r24, r1
     f2a:	1c c0       	rjmp	.+56     	; 0xf64 <xQueueGenericSend+0x124>
     f2c:	c7 01       	movw	r24, r14
     f2e:	0e 94 cc 05 	call	0xb98	; 0xb98 <prvIsQueueFull>
     f32:	88 23       	and	r24, r24
     f34:	89 f0       	breq	.+34     	; 0xf58 <xQueueGenericSend+0x118>
     f36:	4e 81       	ldd	r20, Y+6	; 0x06
     f38:	5f 81       	ldd	r21, Y+7	; 0x07
     f3a:	68 85       	ldd	r22, Y+8	; 0x08
     f3c:	79 85       	ldd	r23, Y+9	; 0x09
     f3e:	c6 01       	movw	r24, r12
     f40:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskPlaceOnEventList>
     f44:	c7 01       	movw	r24, r14
     f46:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
     f4a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     f4e:	81 11       	cpse	r24, r1
     f50:	91 cf       	rjmp	.-222    	; 0xe74 <xQueueGenericSend+0x34>
     f52:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
     f56:	8e cf       	rjmp	.-228    	; 0xe74 <xQueueGenericSend+0x34>
     f58:	c7 01       	movw	r24, r14
     f5a:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
     f5e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     f62:	88 cf       	rjmp	.-240    	; 0xe74 <xQueueGenericSend+0x34>
     f64:	c7 01       	movw	r24, r14
     f66:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
     f6a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     f6e:	80 e0       	ldi	r24, 0x00	; 0
     f70:	29 96       	adiw	r28, 0x09	; 9
     f72:	cd bf       	out	0x3d, r28	; 61
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	df 91       	pop	r29
     f78:	cf 91       	pop	r28
     f7a:	1f 91       	pop	r17
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	df 90       	pop	r13
     f84:	cf 90       	pop	r12
     f86:	bf 90       	pop	r11
     f88:	af 90       	pop	r10
     f8a:	08 95       	ret

00000f8c <xQueueCreateMutex>:
     f8c:	0f 93       	push	r16
     f8e:	cf 93       	push	r28
     f90:	df 93       	push	r29
     f92:	48 2f       	mov	r20, r24
     f94:	60 e0       	ldi	r22, 0x00	; 0
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	0e 94 ef 06 	call	0xdde	; 0xdde <xQueueGenericCreate>
     f9c:	ec 01       	movw	r28, r24
     f9e:	00 97       	sbiw	r24, 0x00	; 0
     fa0:	69 f0       	breq	.+26     	; 0xfbc <xQueueCreateMutex+0x30>
     fa2:	1a 82       	std	Y+2, r1	; 0x02
     fa4:	1b 82       	std	Y+3, r1	; 0x03
     fa6:	18 82       	st	Y, r1
     fa8:	19 82       	std	Y+1, r1	; 0x01
     faa:	1e 82       	std	Y+6, r1	; 0x06
     fac:	00 e0       	ldi	r16, 0x00	; 0
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	a9 01       	movw	r20, r18
     fb4:	60 e0       	ldi	r22, 0x00	; 0
     fb6:	70 e0       	ldi	r23, 0x00	; 0
     fb8:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
     fbc:	ce 01       	movw	r24, r28
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	0f 91       	pop	r16
     fc4:	08 95       	ret

00000fc6 <xQueueGenericSendFromISR>:
     fc6:	af 92       	push	r10
     fc8:	bf 92       	push	r11
     fca:	cf 92       	push	r12
     fcc:	df 92       	push	r13
     fce:	ff 92       	push	r15
     fd0:	0f 93       	push	r16
     fd2:	1f 93       	push	r17
     fd4:	cf 93       	push	r28
     fd6:	df 93       	push	r29
     fd8:	ec 01       	movw	r28, r24
     fda:	6b 01       	movw	r12, r22
     fdc:	5a 01       	movw	r10, r20
     fde:	02 2f       	mov	r16, r18
     fe0:	0e 94 10 04 	call	0x820	; 0x820 <_portSetInterruptMaskFromIsr>
     fe4:	f8 2e       	mov	r15, r24
     fe6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     fe8:	8f 8d       	ldd	r24, Y+31	; 0x1f
     fea:	98 17       	cp	r25, r24
     fec:	10 f0       	brcs	.+4      	; 0xff2 <xQueueGenericSendFromISR+0x2c>
     fee:	02 30       	cpi	r16, 0x02	; 2
     ff0:	e1 f4       	brne	.+56     	; 0x102a <xQueueGenericSendFromISR+0x64>
     ff2:	1a a1       	ldd	r17, Y+34	; 0x22
     ff4:	40 2f       	mov	r20, r16
     ff6:	b6 01       	movw	r22, r12
     ff8:	ce 01       	movw	r24, r28
     ffa:	0e 94 df 05 	call	0xbbe	; 0xbbe <prvCopyDataToQueue>
     ffe:	1f 3f       	cpi	r17, 0xFF	; 255
    1000:	81 f4       	brne	.+32     	; 0x1022 <xQueueGenericSendFromISR+0x5c>
    1002:	8b 89       	ldd	r24, Y+19	; 0x13
    1004:	88 23       	and	r24, r24
    1006:	99 f0       	breq	.+38     	; 0x102e <xQueueGenericSendFromISR+0x68>
    1008:	ce 01       	movw	r24, r28
    100a:	43 96       	adiw	r24, 0x13	; 19
    100c:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
    1010:	88 23       	and	r24, r24
    1012:	79 f0       	breq	.+30     	; 0x1032 <xQueueGenericSendFromISR+0x6c>
    1014:	a1 14       	cp	r10, r1
    1016:	b1 04       	cpc	r11, r1
    1018:	71 f0       	breq	.+28     	; 0x1036 <xQueueGenericSendFromISR+0x70>
    101a:	81 e0       	ldi	r24, 0x01	; 1
    101c:	f5 01       	movw	r30, r10
    101e:	80 83       	st	Z, r24
    1020:	0b c0       	rjmp	.+22     	; 0x1038 <xQueueGenericSendFromISR+0x72>
    1022:	1f 5f       	subi	r17, 0xFF	; 255
    1024:	1a a3       	std	Y+34, r17	; 0x22
    1026:	81 e0       	ldi	r24, 0x01	; 1
    1028:	07 c0       	rjmp	.+14     	; 0x1038 <xQueueGenericSendFromISR+0x72>
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	05 c0       	rjmp	.+10     	; 0x1038 <xQueueGenericSendFromISR+0x72>
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	03 c0       	rjmp	.+6      	; 0x1038 <xQueueGenericSendFromISR+0x72>
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <xQueueGenericSendFromISR+0x72>
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	1f 91       	pop	r17
    1042:	0f 91       	pop	r16
    1044:	ff 90       	pop	r15
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	bf 90       	pop	r11
    104c:	af 90       	pop	r10
    104e:	08 95       	ret

00001050 <xQueueReceive>:
    1050:	af 92       	push	r10
    1052:	bf 92       	push	r11
    1054:	cf 92       	push	r12
    1056:	df 92       	push	r13
    1058:	ef 92       	push	r14
    105a:	ff 92       	push	r15
    105c:	0f 93       	push	r16
    105e:	1f 93       	push	r17
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	cd b7       	in	r28, 0x3d	; 61
    1066:	de b7       	in	r29, 0x3e	; 62
    1068:	29 97       	sbiw	r28, 0x09	; 9
    106a:	cd bf       	out	0x3d, r28	; 61
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	8c 01       	movw	r16, r24
    1070:	5b 01       	movw	r10, r22
    1072:	2e 83       	std	Y+6, r18	; 0x06
    1074:	3f 83       	std	Y+7, r19	; 0x07
    1076:	48 87       	std	Y+8, r20	; 0x08
    1078:	59 87       	std	Y+9, r21	; 0x09
    107a:	e1 2c       	mov	r14, r1
    107c:	6c 01       	movw	r12, r24
    107e:	83 e1       	ldi	r24, 0x13	; 19
    1080:	c8 0e       	add	r12, r24
    1082:	d1 1c       	adc	r13, r1
    1084:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1088:	ff 93       	push	r31
    108a:	f8 7f       	andi	r31, 0xF8	; 248
    108c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1090:	f8 01       	movw	r30, r16
    1092:	f6 8c       	ldd	r15, Z+30	; 0x1e
    1094:	ff 20       	and	r15, r15
    1096:	b1 f0       	breq	.+44     	; 0x10c4 <xQueueReceive+0x74>
    1098:	b5 01       	movw	r22, r10
    109a:	c8 01       	movw	r24, r16
    109c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvCopyDataFromQueue>
    10a0:	fa 94       	dec	r15
    10a2:	f8 01       	movw	r30, r16
    10a4:	f6 8e       	std	Z+30, r15	; 0x1e
    10a6:	80 85       	ldd	r24, Z+8	; 0x08
    10a8:	88 23       	and	r24, r24
    10aa:	39 f0       	breq	.+14     	; 0x10ba <xQueueReceive+0x6a>
    10ac:	c8 01       	movw	r24, r16
    10ae:	08 96       	adiw	r24, 0x08	; 8
    10b0:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
    10b4:	81 11       	cpse	r24, r1
    10b6:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    10ba:	ff 91       	pop	r31
    10bc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	5e c0       	rjmp	.+188    	; 0x1180 <xQueueReceive+0x130>
    10c4:	8e 81       	ldd	r24, Y+6	; 0x06
    10c6:	9f 81       	ldd	r25, Y+7	; 0x07
    10c8:	a8 85       	ldd	r26, Y+8	; 0x08
    10ca:	b9 85       	ldd	r27, Y+9	; 0x09
    10cc:	89 2b       	or	r24, r25
    10ce:	8a 2b       	or	r24, r26
    10d0:	8b 2b       	or	r24, r27
    10d2:	29 f4       	brne	.+10     	; 0x10de <xQueueReceive+0x8e>
    10d4:	ff 91       	pop	r31
    10d6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	51 c0       	rjmp	.+162    	; 0x1180 <xQueueReceive+0x130>
    10de:	e1 10       	cpse	r14, r1
    10e0:	06 c0       	rjmp	.+12     	; 0x10ee <xQueueReceive+0x9e>
    10e2:	ce 01       	movw	r24, r28
    10e4:	01 96       	adiw	r24, 0x01	; 1
    10e6:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <vTaskInternalSetTimeOutState>
    10ea:	ee 24       	eor	r14, r14
    10ec:	e3 94       	inc	r14
    10ee:	ff 91       	pop	r31
    10f0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10f4:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
    10f8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10fc:	ff 93       	push	r31
    10fe:	f8 7f       	andi	r31, 0xF8	; 248
    1100:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1104:	f8 01       	movw	r30, r16
    1106:	81 a1       	ldd	r24, Z+33	; 0x21
    1108:	8f 3f       	cpi	r24, 0xFF	; 255
    110a:	09 f4       	brne	.+2      	; 0x110e <xQueueReceive+0xbe>
    110c:	11 a2       	std	Z+33, r1	; 0x21
    110e:	f8 01       	movw	r30, r16
    1110:	82 a1       	ldd	r24, Z+34	; 0x22
    1112:	8f 3f       	cpi	r24, 0xFF	; 255
    1114:	09 f4       	brne	.+2      	; 0x1118 <xQueueReceive+0xc8>
    1116:	12 a2       	std	Z+34, r1	; 0x22
    1118:	ff 91       	pop	r31
    111a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    111e:	be 01       	movw	r22, r28
    1120:	6a 5f       	subi	r22, 0xFA	; 250
    1122:	7f 4f       	sbci	r23, 0xFF	; 255
    1124:	ce 01       	movw	r24, r28
    1126:	01 96       	adiw	r24, 0x01	; 1
    1128:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <xTaskCheckForTimeOut>
    112c:	81 11       	cpse	r24, r1
    112e:	1c c0       	rjmp	.+56     	; 0x1168 <xQueueReceive+0x118>
    1130:	c8 01       	movw	r24, r16
    1132:	0e 94 bd 05 	call	0xb7a	; 0xb7a <prvIsQueueEmpty>
    1136:	88 23       	and	r24, r24
    1138:	89 f0       	breq	.+34     	; 0x115c <xQueueReceive+0x10c>
    113a:	4e 81       	ldd	r20, Y+6	; 0x06
    113c:	5f 81       	ldd	r21, Y+7	; 0x07
    113e:	68 85       	ldd	r22, Y+8	; 0x08
    1140:	79 85       	ldd	r23, Y+9	; 0x09
    1142:	c6 01       	movw	r24, r12
    1144:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskPlaceOnEventList>
    1148:	c8 01       	movw	r24, r16
    114a:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    114e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    1152:	81 11       	cpse	r24, r1
    1154:	97 cf       	rjmp	.-210    	; 0x1084 <xQueueReceive+0x34>
    1156:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    115a:	94 cf       	rjmp	.-216    	; 0x1084 <xQueueReceive+0x34>
    115c:	c8 01       	movw	r24, r16
    115e:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    1162:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    1166:	8e cf       	rjmp	.-228    	; 0x1084 <xQueueReceive+0x34>
    1168:	c8 01       	movw	r24, r16
    116a:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    116e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    1172:	c8 01       	movw	r24, r16
    1174:	0e 94 bd 05 	call	0xb7a	; 0xb7a <prvIsQueueEmpty>
    1178:	88 23       	and	r24, r24
    117a:	09 f4       	brne	.+2      	; 0x117e <xQueueReceive+0x12e>
    117c:	83 cf       	rjmp	.-250    	; 0x1084 <xQueueReceive+0x34>
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	29 96       	adiw	r28, 0x09	; 9
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	de bf       	out	0x3e, r29	; 62
    1186:	df 91       	pop	r29
    1188:	cf 91       	pop	r28
    118a:	1f 91       	pop	r17
    118c:	0f 91       	pop	r16
    118e:	ff 90       	pop	r15
    1190:	ef 90       	pop	r14
    1192:	df 90       	pop	r13
    1194:	cf 90       	pop	r12
    1196:	bf 90       	pop	r11
    1198:	af 90       	pop	r10
    119a:	08 95       	ret

0000119c <xQueueSemaphoreTake>:
    119c:	cf 92       	push	r12
    119e:	df 92       	push	r13
    11a0:	ef 92       	push	r14
    11a2:	ff 92       	push	r15
    11a4:	0f 93       	push	r16
    11a6:	1f 93       	push	r17
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	cd b7       	in	r28, 0x3d	; 61
    11ae:	de b7       	in	r29, 0x3e	; 62
    11b0:	29 97       	sbiw	r28, 0x09	; 9
    11b2:	cd bf       	out	0x3d, r28	; 61
    11b4:	de bf       	out	0x3e, r29	; 62
    11b6:	8c 01       	movw	r16, r24
    11b8:	4e 83       	std	Y+6, r20	; 0x06
    11ba:	5f 83       	std	Y+7, r21	; 0x07
    11bc:	68 87       	std	Y+8, r22	; 0x08
    11be:	79 87       	std	Y+9, r23	; 0x09
    11c0:	c1 2c       	mov	r12, r1
    11c2:	d1 2c       	mov	r13, r1
    11c4:	7c 01       	movw	r14, r24
    11c6:	83 e1       	ldi	r24, 0x13	; 19
    11c8:	e8 0e       	add	r14, r24
    11ca:	f1 1c       	adc	r15, r1
    11cc:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11d0:	ff 93       	push	r31
    11d2:	f8 7f       	andi	r31, 0xF8	; 248
    11d4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11d8:	d8 01       	movw	r26, r16
    11da:	5e 96       	adiw	r26, 0x1e	; 30
    11dc:	8c 91       	ld	r24, X
    11de:	5e 97       	sbiw	r26, 0x1e	; 30
    11e0:	88 23       	and	r24, r24
    11e2:	f1 f0       	breq	.+60     	; 0x1220 <xQueueSemaphoreTake+0x84>
    11e4:	81 50       	subi	r24, 0x01	; 1
    11e6:	5e 96       	adiw	r26, 0x1e	; 30
    11e8:	8c 93       	st	X, r24
    11ea:	5e 97       	sbiw	r26, 0x1e	; 30
    11ec:	8d 91       	ld	r24, X+
    11ee:	9c 91       	ld	r25, X
    11f0:	89 2b       	or	r24, r25
    11f2:	29 f4       	brne	.+10     	; 0x11fe <xQueueSemaphoreTake+0x62>
    11f4:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <pvTaskIncrementMutexHeldCount>
    11f8:	f8 01       	movw	r30, r16
    11fa:	82 83       	std	Z+2, r24	; 0x02
    11fc:	93 83       	std	Z+3, r25	; 0x03
    11fe:	d8 01       	movw	r26, r16
    1200:	18 96       	adiw	r26, 0x08	; 8
    1202:	8c 91       	ld	r24, X
    1204:	88 23       	and	r24, r24
    1206:	39 f0       	breq	.+14     	; 0x1216 <xQueueSemaphoreTake+0x7a>
    1208:	c8 01       	movw	r24, r16
    120a:	08 96       	adiw	r24, 0x08	; 8
    120c:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <xTaskRemoveFromEventList>
    1210:	81 11       	cpse	r24, r1
    1212:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    1216:	ff 91       	pop	r31
    1218:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    121c:	81 e0       	ldi	r24, 0x01	; 1
    121e:	97 c0       	rjmp	.+302    	; 0x134e <xQueueSemaphoreTake+0x1b2>
    1220:	8e 81       	ldd	r24, Y+6	; 0x06
    1222:	9f 81       	ldd	r25, Y+7	; 0x07
    1224:	a8 85       	ldd	r26, Y+8	; 0x08
    1226:	b9 85       	ldd	r27, Y+9	; 0x09
    1228:	89 2b       	or	r24, r25
    122a:	8a 2b       	or	r24, r26
    122c:	8b 2b       	or	r24, r27
    122e:	29 f4       	brne	.+10     	; 0x123a <xQueueSemaphoreTake+0x9e>
    1230:	ff 91       	pop	r31
    1232:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1236:	80 e0       	ldi	r24, 0x00	; 0
    1238:	8a c0       	rjmp	.+276    	; 0x134e <xQueueSemaphoreTake+0x1b2>
    123a:	d1 10       	cpse	r13, r1
    123c:	06 c0       	rjmp	.+12     	; 0x124a <xQueueSemaphoreTake+0xae>
    123e:	ce 01       	movw	r24, r28
    1240:	01 96       	adiw	r24, 0x01	; 1
    1242:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <vTaskInternalSetTimeOutState>
    1246:	dd 24       	eor	r13, r13
    1248:	d3 94       	inc	r13
    124a:	ff 91       	pop	r31
    124c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1250:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
    1254:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1258:	ff 93       	push	r31
    125a:	f8 7f       	andi	r31, 0xF8	; 248
    125c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1260:	f8 01       	movw	r30, r16
    1262:	81 a1       	ldd	r24, Z+33	; 0x21
    1264:	8f 3f       	cpi	r24, 0xFF	; 255
    1266:	09 f4       	brne	.+2      	; 0x126a <xQueueSemaphoreTake+0xce>
    1268:	11 a2       	std	Z+33, r1	; 0x21
    126a:	d8 01       	movw	r26, r16
    126c:	92 96       	adiw	r26, 0x22	; 34
    126e:	8c 91       	ld	r24, X
    1270:	92 97       	sbiw	r26, 0x22	; 34
    1272:	8f 3f       	cpi	r24, 0xFF	; 255
    1274:	11 f4       	brne	.+4      	; 0x127a <xQueueSemaphoreTake+0xde>
    1276:	92 96       	adiw	r26, 0x22	; 34
    1278:	1c 92       	st	X, r1
    127a:	ff 91       	pop	r31
    127c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1280:	be 01       	movw	r22, r28
    1282:	6a 5f       	subi	r22, 0xFA	; 250
    1284:	7f 4f       	sbci	r23, 0xFF	; 255
    1286:	ce 01       	movw	r24, r28
    1288:	01 96       	adiw	r24, 0x01	; 1
    128a:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <xTaskCheckForTimeOut>
    128e:	81 11       	cpse	r24, r1
    1290:	32 c0       	rjmp	.+100    	; 0x12f6 <xQueueSemaphoreTake+0x15a>
    1292:	c8 01       	movw	r24, r16
    1294:	0e 94 bd 05 	call	0xb7a	; 0xb7a <prvIsQueueEmpty>
    1298:	88 23       	and	r24, r24
    129a:	39 f1       	breq	.+78     	; 0x12ea <xQueueSemaphoreTake+0x14e>
    129c:	f8 01       	movw	r30, r16
    129e:	80 81       	ld	r24, Z
    12a0:	91 81       	ldd	r25, Z+1	; 0x01
    12a2:	89 2b       	or	r24, r25
    12a4:	89 f4       	brne	.+34     	; 0x12c8 <xQueueSemaphoreTake+0x12c>
    12a6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12aa:	ff 93       	push	r31
    12ac:	f8 7f       	andi	r31, 0xF8	; 248
    12ae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12b2:	d8 01       	movw	r26, r16
    12b4:	12 96       	adiw	r26, 0x02	; 2
    12b6:	8d 91       	ld	r24, X+
    12b8:	9c 91       	ld	r25, X
    12ba:	13 97       	sbiw	r26, 0x03	; 3
    12bc:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xTaskPriorityInherit>
    12c0:	c8 2e       	mov	r12, r24
    12c2:	ff 91       	pop	r31
    12c4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12c8:	4e 81       	ldd	r20, Y+6	; 0x06
    12ca:	5f 81       	ldd	r21, Y+7	; 0x07
    12cc:	68 85       	ldd	r22, Y+8	; 0x08
    12ce:	79 85       	ldd	r23, Y+9	; 0x09
    12d0:	c7 01       	movw	r24, r14
    12d2:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskPlaceOnEventList>
    12d6:	c8 01       	movw	r24, r16
    12d8:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    12dc:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    12e0:	81 11       	cpse	r24, r1
    12e2:	74 cf       	rjmp	.-280    	; 0x11cc <xQueueSemaphoreTake+0x30>
    12e4:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    12e8:	71 cf       	rjmp	.-286    	; 0x11cc <xQueueSemaphoreTake+0x30>
    12ea:	c8 01       	movw	r24, r16
    12ec:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    12f0:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    12f4:	6b cf       	rjmp	.-298    	; 0x11cc <xQueueSemaphoreTake+0x30>
    12f6:	c8 01       	movw	r24, r16
    12f8:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
    12fc:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    1300:	c8 01       	movw	r24, r16
    1302:	0e 94 bd 05 	call	0xb7a	; 0xb7a <prvIsQueueEmpty>
    1306:	88 23       	and	r24, r24
    1308:	09 f4       	brne	.+2      	; 0x130c <xQueueSemaphoreTake+0x170>
    130a:	60 cf       	rjmp	.-320    	; 0x11cc <xQueueSemaphoreTake+0x30>
    130c:	cc 20       	and	r12, r12
    130e:	f1 f0       	breq	.+60     	; 0x134c <xQueueSemaphoreTake+0x1b0>
    1310:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1314:	ff 93       	push	r31
    1316:	f8 7f       	andi	r31, 0xF8	; 248
    1318:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    131c:	f8 01       	movw	r30, r16
    131e:	83 89       	ldd	r24, Z+19	; 0x13
    1320:	88 23       	and	r24, r24
    1322:	39 f0       	breq	.+14     	; 0x1332 <xQueueSemaphoreTake+0x196>
    1324:	02 8c       	ldd	r0, Z+26	; 0x1a
    1326:	f3 8d       	ldd	r31, Z+27	; 0x1b
    1328:	e0 2d       	mov	r30, r0
    132a:	80 81       	ld	r24, Z
    132c:	64 e0       	ldi	r22, 0x04	; 4
    132e:	68 1b       	sub	r22, r24
    1330:	01 c0       	rjmp	.+2      	; 0x1334 <xQueueSemaphoreTake+0x198>
    1332:	60 e0       	ldi	r22, 0x00	; 0
    1334:	d8 01       	movw	r26, r16
    1336:	12 96       	adiw	r26, 0x02	; 2
    1338:	8d 91       	ld	r24, X+
    133a:	9c 91       	ld	r25, X
    133c:	13 97       	sbiw	r26, 0x03	; 3
    133e:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskPriorityDisinheritAfterTimeout>
    1342:	ff 91       	pop	r31
    1344:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1348:	80 e0       	ldi	r24, 0x00	; 0
    134a:	01 c0       	rjmp	.+2      	; 0x134e <xQueueSemaphoreTake+0x1b2>
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	29 96       	adiw	r28, 0x09	; 9
    1350:	cd bf       	out	0x3d, r28	; 61
    1352:	de bf       	out	0x3e, r29	; 62
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	ff 90       	pop	r15
    135e:	ef 90       	pop	r14
    1360:	df 90       	pop	r13
    1362:	cf 90       	pop	r12
    1364:	08 95       	ret

00001366 <uxQueueMessagesWaiting>:
    1366:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    136a:	ff 93       	push	r31
    136c:	f8 7f       	andi	r31, 0xF8	; 248
    136e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1372:	fc 01       	movw	r30, r24
    1374:	86 8d       	ldd	r24, Z+30	; 0x1e
    1376:	ff 91       	pop	r31
    1378:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    137c:	08 95       	ret

0000137e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    137e:	cf 93       	push	r28
    1380:	df 93       	push	r29
    1382:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1384:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1388:	ff 93       	push	r31
    138a:	f8 7f       	andi	r31, 0xF8	; 248
    138c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1390:	89 a1       	ldd	r24, Y+33	; 0x21
    1392:	8f 3f       	cpi	r24, 0xFF	; 255
    1394:	09 f4       	brne	.+2      	; 0x1398 <vQueueWaitForMessageRestricted+0x1a>
    1396:	19 a2       	std	Y+33, r1	; 0x21
    1398:	8a a1       	ldd	r24, Y+34	; 0x22
    139a:	8f 3f       	cpi	r24, 0xFF	; 255
    139c:	09 f4       	brne	.+2      	; 0x13a0 <vQueueWaitForMessageRestricted+0x22>
    139e:	1a a2       	std	Y+34, r1	; 0x22
    13a0:	ff 91       	pop	r31
    13a2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    13a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13a8:	81 11       	cpse	r24, r1
    13aa:	04 c0       	rjmp	.+8      	; 0x13b4 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    13ac:	ce 01       	movw	r24, r28
    13ae:	43 96       	adiw	r24, 0x13	; 19
    13b0:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    13b4:	ce 01       	movw	r24, r28
    13b6:	0e 94 58 06 	call	0xcb0	; 0xcb0 <prvUnlockQueue>
	}
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	08 95       	ret

000013c0 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    13c0:	e0 91 28 2c 	lds	r30, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    13c4:	f0 91 29 2c 	lds	r31, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    13c8:	80 81       	ld	r24, Z
    13ca:	81 11       	cpse	r24, r1
    13cc:	0c c0       	rjmp	.+24     	; 0x13e6 <prvResetNextTaskUnblockTime+0x26>
    13ce:	8f ef       	ldi	r24, 0xFF	; 255
    13d0:	9f ef       	ldi	r25, 0xFF	; 255
    13d2:	dc 01       	movw	r26, r24
    13d4:	80 93 01 2c 	sts	0x2C01, r24	; 0x802c01 <xNextTaskUnblockTime>
    13d8:	90 93 02 2c 	sts	0x2C02, r25	; 0x802c02 <xNextTaskUnblockTime+0x1>
    13dc:	a0 93 03 2c 	sts	0x2C03, r26	; 0x802c03 <xNextTaskUnblockTime+0x2>
    13e0:	b0 93 04 2c 	sts	0x2C04, r27	; 0x802c04 <xNextTaskUnblockTime+0x3>
    13e4:	08 95       	ret
    13e6:	e0 91 28 2c 	lds	r30, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    13ea:	f0 91 29 2c 	lds	r31, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    13ee:	07 80       	ldd	r0, Z+7	; 0x07
    13f0:	f0 85       	ldd	r31, Z+8	; 0x08
    13f2:	e0 2d       	mov	r30, r0
    13f4:	00 84       	ldd	r0, Z+8	; 0x08
    13f6:	f1 85       	ldd	r31, Z+9	; 0x09
    13f8:	e0 2d       	mov	r30, r0
    13fa:	82 81       	ldd	r24, Z+2	; 0x02
    13fc:	93 81       	ldd	r25, Z+3	; 0x03
    13fe:	a4 81       	ldd	r26, Z+4	; 0x04
    1400:	b5 81       	ldd	r27, Z+5	; 0x05
    1402:	80 93 01 2c 	sts	0x2C01, r24	; 0x802c01 <xNextTaskUnblockTime>
    1406:	90 93 02 2c 	sts	0x2C02, r25	; 0x802c02 <xNextTaskUnblockTime+0x1>
    140a:	a0 93 03 2c 	sts	0x2C03, r26	; 0x802c03 <xNextTaskUnblockTime+0x2>
    140e:	b0 93 04 2c 	sts	0x2C04, r27	; 0x802c04 <xNextTaskUnblockTime+0x3>
    1412:	08 95       	ret

00001414 <prvAddCurrentTaskToDelayedList>:
    1414:	8f 92       	push	r8
    1416:	9f 92       	push	r9
    1418:	af 92       	push	r10
    141a:	bf 92       	push	r11
    141c:	cf 92       	push	r12
    141e:	df 92       	push	r13
    1420:	ef 92       	push	r14
    1422:	ff 92       	push	r15
    1424:	cf 93       	push	r28
    1426:	6b 01       	movw	r12, r22
    1428:	7c 01       	movw	r14, r24
    142a:	c4 2f       	mov	r28, r20
    142c:	80 90 0b 2c 	lds	r8, 0x2C0B	; 0x802c0b <xTickCount>
    1430:	90 90 0c 2c 	lds	r9, 0x2C0C	; 0x802c0c <xTickCount+0x1>
    1434:	a0 90 0d 2c 	lds	r10, 0x2C0D	; 0x802c0d <xTickCount+0x2>
    1438:	b0 90 0e 2c 	lds	r11, 0x2C0E	; 0x802c0e <xTickCount+0x3>
    143c:	80 91 6c 2c 	lds	r24, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1440:	90 91 6d 2c 	lds	r25, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1444:	02 96       	adiw	r24, 0x02	; 2
    1446:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    144a:	8f ef       	ldi	r24, 0xFF	; 255
    144c:	c8 16       	cp	r12, r24
    144e:	d8 06       	cpc	r13, r24
    1450:	e8 06       	cpc	r14, r24
    1452:	f8 06       	cpc	r15, r24
    1454:	69 f4       	brne	.+26     	; 0x1470 <prvAddCurrentTaskToDelayedList+0x5c>
    1456:	cc 23       	and	r28, r28
    1458:	59 f0       	breq	.+22     	; 0x1470 <prvAddCurrentTaskToDelayedList+0x5c>
    145a:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    145e:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1462:	6e 5f       	subi	r22, 0xFE	; 254
    1464:	7f 4f       	sbci	r23, 0xFF	; 255
    1466:	80 e1       	ldi	r24, 0x10	; 16
    1468:	9c e2       	ldi	r25, 0x2C	; 44
    146a:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    146e:	3f c0       	rjmp	.+126    	; 0x14ee <prvAddCurrentTaskToDelayedList+0xda>
    1470:	c8 0c       	add	r12, r8
    1472:	d9 1c       	adc	r13, r9
    1474:	ea 1c       	adc	r14, r10
    1476:	fb 1c       	adc	r15, r11
    1478:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    147c:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1480:	c2 82       	std	Z+2, r12	; 0x02
    1482:	d3 82       	std	Z+3, r13	; 0x03
    1484:	e4 82       	std	Z+4, r14	; 0x04
    1486:	f5 82       	std	Z+5, r15	; 0x05
    1488:	c8 14       	cp	r12, r8
    148a:	d9 04       	cpc	r13, r9
    148c:	ea 04       	cpc	r14, r10
    148e:	fb 04       	cpc	r15, r11
    1490:	68 f4       	brcc	.+26     	; 0x14ac <prvAddCurrentTaskToDelayedList+0x98>
    1492:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1496:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    149a:	80 91 26 2c 	lds	r24, 0x2C26	; 0x802c26 <pxOverflowDelayedTaskList>
    149e:	90 91 27 2c 	lds	r25, 0x2C27	; 0x802c27 <pxOverflowDelayedTaskList+0x1>
    14a2:	6e 5f       	subi	r22, 0xFE	; 254
    14a4:	7f 4f       	sbci	r23, 0xFF	; 255
    14a6:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    14aa:	21 c0       	rjmp	.+66     	; 0x14ee <prvAddCurrentTaskToDelayedList+0xda>
    14ac:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    14b0:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    14b4:	80 91 28 2c 	lds	r24, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    14b8:	90 91 29 2c 	lds	r25, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    14bc:	6e 5f       	subi	r22, 0xFE	; 254
    14be:	7f 4f       	sbci	r23, 0xFF	; 255
    14c0:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    14c4:	80 91 01 2c 	lds	r24, 0x2C01	; 0x802c01 <xNextTaskUnblockTime>
    14c8:	90 91 02 2c 	lds	r25, 0x2C02	; 0x802c02 <xNextTaskUnblockTime+0x1>
    14cc:	a0 91 03 2c 	lds	r26, 0x2C03	; 0x802c03 <xNextTaskUnblockTime+0x2>
    14d0:	b0 91 04 2c 	lds	r27, 0x2C04	; 0x802c04 <xNextTaskUnblockTime+0x3>
    14d4:	c8 16       	cp	r12, r24
    14d6:	d9 06       	cpc	r13, r25
    14d8:	ea 06       	cpc	r14, r26
    14da:	fb 06       	cpc	r15, r27
    14dc:	40 f4       	brcc	.+16     	; 0x14ee <prvAddCurrentTaskToDelayedList+0xda>
    14de:	c0 92 01 2c 	sts	0x2C01, r12	; 0x802c01 <xNextTaskUnblockTime>
    14e2:	d0 92 02 2c 	sts	0x2C02, r13	; 0x802c02 <xNextTaskUnblockTime+0x1>
    14e6:	e0 92 03 2c 	sts	0x2C03, r14	; 0x802c03 <xNextTaskUnblockTime+0x2>
    14ea:	f0 92 04 2c 	sts	0x2C04, r15	; 0x802c04 <xNextTaskUnblockTime+0x3>
    14ee:	cf 91       	pop	r28
    14f0:	ff 90       	pop	r15
    14f2:	ef 90       	pop	r14
    14f4:	df 90       	pop	r13
    14f6:	cf 90       	pop	r12
    14f8:	bf 90       	pop	r11
    14fa:	af 90       	pop	r10
    14fc:	9f 90       	pop	r9
    14fe:	8f 90       	pop	r8
    1500:	08 95       	ret

00001502 <prvIdleTask>:
    1502:	c0 e4       	ldi	r28, 0x40	; 64
    1504:	dc e2       	ldi	r29, 0x2C	; 44
    1506:	88 81       	ld	r24, Y
    1508:	82 30       	cpi	r24, 0x02	; 2
    150a:	10 f0       	brcs	.+4      	; 0x1510 <prvIdleTask+0xe>
    150c:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    1510:	0e 94 86 15 	call	0x2b0c	; 0x2b0c <vApplicationIdleHook>
    1514:	f8 cf       	rjmp	.-16     	; 0x1506 <prvIdleTask+0x4>

00001516 <xTaskCreate>:
    1516:	4f 92       	push	r4
    1518:	5f 92       	push	r5
    151a:	6f 92       	push	r6
    151c:	7f 92       	push	r7
    151e:	8f 92       	push	r8
    1520:	9f 92       	push	r9
    1522:	af 92       	push	r10
    1524:	bf 92       	push	r11
    1526:	cf 92       	push	r12
    1528:	df 92       	push	r13
    152a:	ef 92       	push	r14
    152c:	ff 92       	push	r15
    152e:	0f 93       	push	r16
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	4c 01       	movw	r8, r24
    1536:	6b 01       	movw	r12, r22
    1538:	5a 01       	movw	r10, r20
    153a:	29 01       	movw	r4, r18
    153c:	ca 01       	movw	r24, r20
    153e:	0e 94 4f 03 	call	0x69e	; 0x69e <pvPortMalloc>
    1542:	3c 01       	movw	r6, r24
    1544:	89 2b       	or	r24, r25
    1546:	09 f4       	brne	.+2      	; 0x154a <xTaskCreate+0x34>
    1548:	ec c0       	rjmp	.+472    	; 0x1722 <xTaskCreate+0x20c>
    154a:	8e e2       	ldi	r24, 0x2E	; 46
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	0e 94 4f 03 	call	0x69e	; 0x69e <pvPortMalloc>
    1552:	ec 01       	movw	r28, r24
    1554:	89 2b       	or	r24, r25
    1556:	b1 f0       	breq	.+44     	; 0x1584 <xTaskCreate+0x6e>
    1558:	6b 8e       	std	Y+27, r6	; 0x1b
    155a:	7c 8e       	std	Y+28, r7	; 0x1c
    155c:	a5 01       	movw	r20, r10
    155e:	65 ea       	ldi	r22, 0xA5	; 165
    1560:	70 e0       	ldi	r23, 0x00	; 0
    1562:	c3 01       	movw	r24, r6
    1564:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <memset>
    1568:	21 e0       	ldi	r18, 0x01	; 1
    156a:	a2 1a       	sub	r10, r18
    156c:	b1 08       	sbc	r11, r1
    156e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1570:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1572:	a8 0e       	add	r10, r24
    1574:	b9 1e       	adc	r11, r25
    1576:	d6 01       	movw	r26, r12
    1578:	8c 91       	ld	r24, X
    157a:	8d 8f       	std	Y+29, r24	; 0x1d
    157c:	8c 91       	ld	r24, X
    157e:	81 11       	cpse	r24, r1
    1580:	05 c0       	rjmp	.+10     	; 0x158c <xTaskCreate+0x76>
    1582:	18 c0       	rjmp	.+48     	; 0x15b4 <xTaskCreate+0x9e>
    1584:	c3 01       	movw	r24, r6
    1586:	0e 94 75 03 	call	0x6ea	; 0x6ea <vPortFree>
    158a:	cb c0       	rjmp	.+406    	; 0x1722 <xTaskCreate+0x20c>
    158c:	ae 01       	movw	r20, r28
    158e:	42 5e       	subi	r20, 0xE2	; 226
    1590:	5f 4f       	sbci	r21, 0xFF	; 255
    1592:	f6 01       	movw	r30, r12
    1594:	31 96       	adiw	r30, 0x01	; 1
    1596:	b8 e0       	ldi	r27, 0x08	; 8
    1598:	cb 0e       	add	r12, r27
    159a:	d1 1c       	adc	r13, r1
    159c:	cf 01       	movw	r24, r30
    159e:	21 91       	ld	r18, Z+
    15a0:	da 01       	movw	r26, r20
    15a2:	2d 93       	st	X+, r18
    15a4:	ad 01       	movw	r20, r26
    15a6:	dc 01       	movw	r26, r24
    15a8:	8c 91       	ld	r24, X
    15aa:	88 23       	and	r24, r24
    15ac:	19 f0       	breq	.+6      	; 0x15b4 <xTaskCreate+0x9e>
    15ae:	ec 15       	cp	r30, r12
    15b0:	fd 05       	cpc	r31, r13
    15b2:	a1 f7       	brne	.-24     	; 0x159c <xTaskCreate+0x86>
    15b4:	1c a2       	std	Y+36, r1	; 0x24
    15b6:	04 30       	cpi	r16, 0x04	; 4
    15b8:	08 f0       	brcs	.+2      	; 0x15bc <xTaskCreate+0xa6>
    15ba:	03 e0       	ldi	r16, 0x03	; 3
    15bc:	0a 8f       	std	Y+26, r16	; 0x1a
    15be:	0f a3       	std	Y+39, r16	; 0x27
    15c0:	18 a6       	std	Y+40, r1	; 0x28
    15c2:	6e 01       	movw	r12, r28
    15c4:	b2 e0       	ldi	r27, 0x02	; 2
    15c6:	cb 0e       	add	r12, r27
    15c8:	d1 1c       	adc	r13, r1
    15ca:	c6 01       	movw	r24, r12
    15cc:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>
    15d0:	ce 01       	movw	r24, r28
    15d2:	0e 96       	adiw	r24, 0x0e	; 14
    15d4:	0e 94 87 03 	call	0x70e	; 0x70e <vListInitialiseItem>
    15d8:	ca 87       	std	Y+10, r28	; 0x0a
    15da:	db 87       	std	Y+11, r29	; 0x0b
    15dc:	84 e0       	ldi	r24, 0x04	; 4
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	a0 e0       	ldi	r26, 0x00	; 0
    15e2:	b0 e0       	ldi	r27, 0x00	; 0
    15e4:	80 1b       	sub	r24, r16
    15e6:	91 09       	sbc	r25, r1
    15e8:	a1 09       	sbc	r26, r1
    15ea:	b1 09       	sbc	r27, r1
    15ec:	8e 87       	std	Y+14, r24	; 0x0e
    15ee:	9f 87       	std	Y+15, r25	; 0x0f
    15f0:	a8 8b       	std	Y+16, r26	; 0x10
    15f2:	b9 8b       	std	Y+17, r27	; 0x11
    15f4:	ce 8b       	std	Y+22, r28	; 0x16
    15f6:	df 8b       	std	Y+23, r29	; 0x17
    15f8:	19 a6       	std	Y+41, r1	; 0x29
    15fa:	1a a6       	std	Y+42, r1	; 0x2a
    15fc:	1b a6       	std	Y+43, r1	; 0x2b
    15fe:	1c a6       	std	Y+44, r1	; 0x2c
    1600:	1d a6       	std	Y+45, r1	; 0x2d
    1602:	a2 01       	movw	r20, r4
    1604:	b4 01       	movw	r22, r8
    1606:	c5 01       	movw	r24, r10
    1608:	0e 94 17 04 	call	0x82e	; 0x82e <pxPortInitialiseStack>
    160c:	88 83       	st	Y, r24
    160e:	99 83       	std	Y+1, r25	; 0x01
    1610:	e1 14       	cp	r14, r1
    1612:	f1 04       	cpc	r15, r1
    1614:	19 f0       	breq	.+6      	; 0x161c <xTaskCreate+0x106>
    1616:	f7 01       	movw	r30, r14
    1618:	c0 83       	st	Z, r28
    161a:	d1 83       	std	Z+1, r29	; 0x01
    161c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1620:	ff 93       	push	r31
    1622:	f8 7f       	andi	r31, 0xF8	; 248
    1624:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1628:	80 91 0f 2c 	lds	r24, 0x2C0F	; 0x802c0f <uxCurrentNumberOfTasks>
    162c:	8f 5f       	subi	r24, 0xFF	; 255
    162e:	80 93 0f 2c 	sts	0x2C0F, r24	; 0x802c0f <uxCurrentNumberOfTasks>
    1632:	80 91 6c 2c 	lds	r24, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1636:	90 91 6d 2c 	lds	r25, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    163a:	89 2b       	or	r24, r25
    163c:	a9 f5       	brne	.+106    	; 0x16a8 <xTaskCreate+0x192>
    163e:	c0 93 6c 2c 	sts	0x2C6C, r28	; 0x802c6c <pxCurrentTCB>
    1642:	d0 93 6d 2c 	sts	0x2C6D, r29	; 0x802c6d <pxCurrentTCB+0x1>
    1646:	80 91 0f 2c 	lds	r24, 0x2C0F	; 0x802c0f <uxCurrentNumberOfTasks>
    164a:	81 30       	cpi	r24, 0x01	; 1
    164c:	e9 f5       	brne	.+122    	; 0x16c8 <xTaskCreate+0x1b2>
    164e:	80 e4       	ldi	r24, 0x40	; 64
    1650:	9c e2       	ldi	r25, 0x2C	; 44
    1652:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1656:	8b e4       	ldi	r24, 0x4B	; 75
    1658:	9c e2       	ldi	r25, 0x2C	; 44
    165a:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    165e:	86 e5       	ldi	r24, 0x56	; 86
    1660:	9c e2       	ldi	r25, 0x2C	; 44
    1662:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1666:	81 e6       	ldi	r24, 0x61	; 97
    1668:	9c e2       	ldi	r25, 0x2C	; 44
    166a:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    166e:	85 e3       	ldi	r24, 0x35	; 53
    1670:	9c e2       	ldi	r25, 0x2C	; 44
    1672:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1676:	8a e2       	ldi	r24, 0x2A	; 42
    1678:	9c e2       	ldi	r25, 0x2C	; 44
    167a:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    167e:	8b e1       	ldi	r24, 0x1B	; 27
    1680:	9c e2       	ldi	r25, 0x2C	; 44
    1682:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1686:	80 e1       	ldi	r24, 0x10	; 16
    1688:	9c e2       	ldi	r25, 0x2C	; 44
    168a:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    168e:	85 e3       	ldi	r24, 0x35	; 53
    1690:	9c e2       	ldi	r25, 0x2C	; 44
    1692:	80 93 28 2c 	sts	0x2C28, r24	; 0x802c28 <pxDelayedTaskList>
    1696:	90 93 29 2c 	sts	0x2C29, r25	; 0x802c29 <pxDelayedTaskList+0x1>
    169a:	8a e2       	ldi	r24, 0x2A	; 42
    169c:	9c e2       	ldi	r25, 0x2C	; 44
    169e:	80 93 26 2c 	sts	0x2C26, r24	; 0x802c26 <pxOverflowDelayedTaskList>
    16a2:	90 93 27 2c 	sts	0x2C27, r25	; 0x802c27 <pxOverflowDelayedTaskList+0x1>
    16a6:	10 c0       	rjmp	.+32     	; 0x16c8 <xTaskCreate+0x1b2>
    16a8:	80 91 09 2c 	lds	r24, 0x2C09	; 0x802c09 <xSchedulerRunning>
    16ac:	81 11       	cpse	r24, r1
    16ae:	0c c0       	rjmp	.+24     	; 0x16c8 <xTaskCreate+0x1b2>
    16b0:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    16b4:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    16b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    16ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16bc:	89 17       	cp	r24, r25
    16be:	20 f0       	brcs	.+8      	; 0x16c8 <xTaskCreate+0x1b2>
    16c0:	c0 93 6c 2c 	sts	0x2C6C, r28	; 0x802c6c <pxCurrentTCB>
    16c4:	d0 93 6d 2c 	sts	0x2C6D, r29	; 0x802c6d <pxCurrentTCB+0x1>
    16c8:	80 91 05 2c 	lds	r24, 0x2C05	; 0x802c05 <uxTaskNumber>
    16cc:	8f 5f       	subi	r24, 0xFF	; 255
    16ce:	80 93 05 2c 	sts	0x2C05, r24	; 0x802c05 <uxTaskNumber>
    16d2:	8d a3       	std	Y+37, r24	; 0x25
    16d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16d6:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    16da:	98 17       	cp	r25, r24
    16dc:	10 f4       	brcc	.+4      	; 0x16e2 <xTaskCreate+0x1cc>
    16de:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    16e2:	fb e0       	ldi	r31, 0x0B	; 11
    16e4:	8f 9f       	mul	r24, r31
    16e6:	c0 01       	movw	r24, r0
    16e8:	11 24       	eor	r1, r1
    16ea:	b6 01       	movw	r22, r12
    16ec:	80 5c       	subi	r24, 0xC0	; 192
    16ee:	93 4d       	sbci	r25, 0xD3	; 211
    16f0:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    16f4:	ff 91       	pop	r31
    16f6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16fa:	80 91 09 2c 	lds	r24, 0x2C09	; 0x802c09 <xSchedulerRunning>
    16fe:	88 23       	and	r24, r24
    1700:	61 f0       	breq	.+24     	; 0x171a <xTaskCreate+0x204>
    1702:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1706:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    170a:	92 8d       	ldd	r25, Z+26	; 0x1a
    170c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    170e:	98 17       	cp	r25, r24
    1710:	30 f4       	brcc	.+12     	; 0x171e <xTaskCreate+0x208>
    1712:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	05 c0       	rjmp	.+10     	; 0x1724 <xTaskCreate+0x20e>
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	03 c0       	rjmp	.+6      	; 0x1724 <xTaskCreate+0x20e>
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	01 c0       	rjmp	.+2      	; 0x1724 <xTaskCreate+0x20e>
    1722:	8f ef       	ldi	r24, 0xFF	; 255
    1724:	df 91       	pop	r29
    1726:	cf 91       	pop	r28
    1728:	0f 91       	pop	r16
    172a:	ff 90       	pop	r15
    172c:	ef 90       	pop	r14
    172e:	df 90       	pop	r13
    1730:	cf 90       	pop	r12
    1732:	bf 90       	pop	r11
    1734:	af 90       	pop	r10
    1736:	9f 90       	pop	r9
    1738:	8f 90       	pop	r8
    173a:	7f 90       	pop	r7
    173c:	6f 90       	pop	r6
    173e:	5f 90       	pop	r5
    1740:	4f 90       	pop	r4
    1742:	08 95       	ret

00001744 <vTaskStartScheduler>:
    1744:	ef 92       	push	r14
    1746:	ff 92       	push	r15
    1748:	0f 93       	push	r16
    174a:	0f 2e       	mov	r0, r31
    174c:	ff ef       	ldi	r31, 0xFF	; 255
    174e:	ef 2e       	mov	r14, r31
    1750:	fb e2       	ldi	r31, 0x2B	; 43
    1752:	ff 2e       	mov	r15, r31
    1754:	f0 2d       	mov	r31, r0
    1756:	00 e0       	ldi	r16, 0x00	; 0
    1758:	20 e0       	ldi	r18, 0x00	; 0
    175a:	30 e0       	ldi	r19, 0x00	; 0
    175c:	48 ec       	ldi	r20, 0xC8	; 200
    175e:	50 e0       	ldi	r21, 0x00	; 0
    1760:	60 e0       	ldi	r22, 0x00	; 0
    1762:	70 e2       	ldi	r23, 0x20	; 32
    1764:	81 e8       	ldi	r24, 0x81	; 129
    1766:	9a e0       	ldi	r25, 0x0A	; 10
    1768:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
    176c:	81 30       	cpi	r24, 0x01	; 1
    176e:	09 f5       	brne	.+66     	; 0x17b2 <vTaskStartScheduler+0x6e>
    1770:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <xTimerCreateTimerTask>
    1774:	81 30       	cpi	r24, 0x01	; 1
    1776:	e9 f4       	brne	.+58     	; 0x17b2 <vTaskStartScheduler+0x6e>
    1778:	e0 ea       	ldi	r30, 0xA0	; 160
    177a:	f0 e0       	ldi	r31, 0x00	; 0
    177c:	82 81       	ldd	r24, Z+2	; 0x02
    177e:	88 7f       	andi	r24, 0xF8	; 248
    1780:	82 83       	std	Z+2, r24	; 0x02
    1782:	8f ef       	ldi	r24, 0xFF	; 255
    1784:	9f ef       	ldi	r25, 0xFF	; 255
    1786:	dc 01       	movw	r26, r24
    1788:	80 93 01 2c 	sts	0x2C01, r24	; 0x802c01 <xNextTaskUnblockTime>
    178c:	90 93 02 2c 	sts	0x2C02, r25	; 0x802c02 <xNextTaskUnblockTime+0x1>
    1790:	a0 93 03 2c 	sts	0x2C03, r26	; 0x802c03 <xNextTaskUnblockTime+0x2>
    1794:	b0 93 04 2c 	sts	0x2C04, r27	; 0x802c04 <xNextTaskUnblockTime+0x3>
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	80 93 09 2c 	sts	0x2C09, r24	; 0x802c09 <xSchedulerRunning>
    179e:	10 92 0b 2c 	sts	0x2C0B, r1	; 0x802c0b <xTickCount>
    17a2:	10 92 0c 2c 	sts	0x2C0C, r1	; 0x802c0c <xTickCount+0x1>
    17a6:	10 92 0d 2c 	sts	0x2C0D, r1	; 0x802c0d <xTickCount+0x2>
    17aa:	10 92 0e 2c 	sts	0x2C0E, r1	; 0x802c0e <xTickCount+0x3>
    17ae:	0e 94 94 04 	call	0x928	; 0x928 <xPortStartScheduler>
    17b2:	0f 91       	pop	r16
    17b4:	ff 90       	pop	r15
    17b6:	ef 90       	pop	r14
    17b8:	08 95       	ret

000017ba <vTaskSuspendAll>:
    17ba:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    17be:	8f 5f       	subi	r24, 0xFF	; 255
    17c0:	80 93 fe 2b 	sts	0x2BFE, r24	; 0x802bfe <uxSchedulerSuspended>
    17c4:	08 95       	ret

000017c6 <xTaskGetTickCount>:
    17c6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17ca:	ff 93       	push	r31
    17cc:	f8 7f       	andi	r31, 0xF8	; 248
    17ce:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17d2:	60 91 0b 2c 	lds	r22, 0x2C0B	; 0x802c0b <xTickCount>
    17d6:	70 91 0c 2c 	lds	r23, 0x2C0C	; 0x802c0c <xTickCount+0x1>
    17da:	80 91 0d 2c 	lds	r24, 0x2C0D	; 0x802c0d <xTickCount+0x2>
    17de:	90 91 0e 2c 	lds	r25, 0x2C0E	; 0x802c0e <xTickCount+0x3>
    17e2:	ff 91       	pop	r31
    17e4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17e8:	08 95       	ret

000017ea <xTaskIncrementTick>:
    17ea:	af 92       	push	r10
    17ec:	bf 92       	push	r11
    17ee:	cf 92       	push	r12
    17f0:	df 92       	push	r13
    17f2:	ef 92       	push	r14
    17f4:	ff 92       	push	r15
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    1802:	81 11       	cpse	r24, r1
    1804:	ad c0       	rjmp	.+346    	; 0x1960 <xTaskIncrementTick+0x176>
    1806:	c0 90 0b 2c 	lds	r12, 0x2C0B	; 0x802c0b <xTickCount>
    180a:	d0 90 0c 2c 	lds	r13, 0x2C0C	; 0x802c0c <xTickCount+0x1>
    180e:	e0 90 0d 2c 	lds	r14, 0x2C0D	; 0x802c0d <xTickCount+0x2>
    1812:	f0 90 0e 2c 	lds	r15, 0x2C0E	; 0x802c0e <xTickCount+0x3>
    1816:	8f ef       	ldi	r24, 0xFF	; 255
    1818:	c8 1a       	sub	r12, r24
    181a:	d8 0a       	sbc	r13, r24
    181c:	e8 0a       	sbc	r14, r24
    181e:	f8 0a       	sbc	r15, r24
    1820:	c0 92 0b 2c 	sts	0x2C0B, r12	; 0x802c0b <xTickCount>
    1824:	d0 92 0c 2c 	sts	0x2C0C, r13	; 0x802c0c <xTickCount+0x1>
    1828:	e0 92 0d 2c 	sts	0x2C0D, r14	; 0x802c0d <xTickCount+0x2>
    182c:	f0 92 0e 2c 	sts	0x2C0E, r15	; 0x802c0e <xTickCount+0x3>
    1830:	c1 14       	cp	r12, r1
    1832:	d1 04       	cpc	r13, r1
    1834:	e1 04       	cpc	r14, r1
    1836:	f1 04       	cpc	r15, r1
    1838:	b9 f4       	brne	.+46     	; 0x1868 <xTaskIncrementTick+0x7e>
    183a:	80 91 28 2c 	lds	r24, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    183e:	90 91 29 2c 	lds	r25, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    1842:	20 91 26 2c 	lds	r18, 0x2C26	; 0x802c26 <pxOverflowDelayedTaskList>
    1846:	30 91 27 2c 	lds	r19, 0x2C27	; 0x802c27 <pxOverflowDelayedTaskList+0x1>
    184a:	20 93 28 2c 	sts	0x2C28, r18	; 0x802c28 <pxDelayedTaskList>
    184e:	30 93 29 2c 	sts	0x2C29, r19	; 0x802c29 <pxDelayedTaskList+0x1>
    1852:	80 93 26 2c 	sts	0x2C26, r24	; 0x802c26 <pxOverflowDelayedTaskList>
    1856:	90 93 27 2c 	sts	0x2C27, r25	; 0x802c27 <pxOverflowDelayedTaskList+0x1>
    185a:	80 91 06 2c 	lds	r24, 0x2C06	; 0x802c06 <xNumOfOverflows>
    185e:	8f 5f       	subi	r24, 0xFF	; 255
    1860:	80 93 06 2c 	sts	0x2C06, r24	; 0x802c06 <xNumOfOverflows>
    1864:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <prvResetNextTaskUnblockTime>
    1868:	80 91 01 2c 	lds	r24, 0x2C01	; 0x802c01 <xNextTaskUnblockTime>
    186c:	90 91 02 2c 	lds	r25, 0x2C02	; 0x802c02 <xNextTaskUnblockTime+0x1>
    1870:	a0 91 03 2c 	lds	r26, 0x2C03	; 0x802c03 <xNextTaskUnblockTime+0x2>
    1874:	b0 91 04 2c 	lds	r27, 0x2C04	; 0x802c04 <xNextTaskUnblockTime+0x3>
    1878:	c8 16       	cp	r12, r24
    187a:	d9 06       	cpc	r13, r25
    187c:	ea 06       	cpc	r14, r26
    187e:	fb 06       	cpc	r15, r27
    1880:	10 f4       	brcc	.+4      	; 0x1886 <xTaskIncrementTick+0x9c>
    1882:	b1 2c       	mov	r11, r1
    1884:	5c c0       	rjmp	.+184    	; 0x193e <xTaskIncrementTick+0x154>
    1886:	b1 2c       	mov	r11, r1
    1888:	0f 2e       	mov	r0, r31
    188a:	fb e0       	ldi	r31, 0x0B	; 11
    188c:	af 2e       	mov	r10, r31
    188e:	f0 2d       	mov	r31, r0
    1890:	e0 91 28 2c 	lds	r30, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    1894:	f0 91 29 2c 	lds	r31, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    1898:	80 81       	ld	r24, Z
    189a:	81 11       	cpse	r24, r1
    189c:	0c c0       	rjmp	.+24     	; 0x18b6 <xTaskIncrementTick+0xcc>
    189e:	8f ef       	ldi	r24, 0xFF	; 255
    18a0:	9f ef       	ldi	r25, 0xFF	; 255
    18a2:	dc 01       	movw	r26, r24
    18a4:	80 93 01 2c 	sts	0x2C01, r24	; 0x802c01 <xNextTaskUnblockTime>
    18a8:	90 93 02 2c 	sts	0x2C02, r25	; 0x802c02 <xNextTaskUnblockTime+0x1>
    18ac:	a0 93 03 2c 	sts	0x2C03, r26	; 0x802c03 <xNextTaskUnblockTime+0x2>
    18b0:	b0 93 04 2c 	sts	0x2C04, r27	; 0x802c04 <xNextTaskUnblockTime+0x3>
    18b4:	44 c0       	rjmp	.+136    	; 0x193e <xTaskIncrementTick+0x154>
    18b6:	e0 91 28 2c 	lds	r30, 0x2C28	; 0x802c28 <pxDelayedTaskList>
    18ba:	f0 91 29 2c 	lds	r31, 0x2C29	; 0x802c29 <pxDelayedTaskList+0x1>
    18be:	07 80       	ldd	r0, Z+7	; 0x07
    18c0:	f0 85       	ldd	r31, Z+8	; 0x08
    18c2:	e0 2d       	mov	r30, r0
    18c4:	c0 85       	ldd	r28, Z+8	; 0x08
    18c6:	d1 85       	ldd	r29, Z+9	; 0x09
    18c8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ca:	9b 81       	ldd	r25, Y+3	; 0x03
    18cc:	ac 81       	ldd	r26, Y+4	; 0x04
    18ce:	bd 81       	ldd	r27, Y+5	; 0x05
    18d0:	c8 16       	cp	r12, r24
    18d2:	d9 06       	cpc	r13, r25
    18d4:	ea 06       	cpc	r14, r26
    18d6:	fb 06       	cpc	r15, r27
    18d8:	48 f4       	brcc	.+18     	; 0x18ec <xTaskIncrementTick+0x102>
    18da:	80 93 01 2c 	sts	0x2C01, r24	; 0x802c01 <xNextTaskUnblockTime>
    18de:	90 93 02 2c 	sts	0x2C02, r25	; 0x802c02 <xNextTaskUnblockTime+0x1>
    18e2:	a0 93 03 2c 	sts	0x2C03, r26	; 0x802c03 <xNextTaskUnblockTime+0x2>
    18e6:	b0 93 04 2c 	sts	0x2C04, r27	; 0x802c04 <xNextTaskUnblockTime+0x3>
    18ea:	29 c0       	rjmp	.+82     	; 0x193e <xTaskIncrementTick+0x154>
    18ec:	8e 01       	movw	r16, r28
    18ee:	0e 5f       	subi	r16, 0xFE	; 254
    18f0:	1f 4f       	sbci	r17, 0xFF	; 255
    18f2:	c8 01       	movw	r24, r16
    18f4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    18f8:	88 8d       	ldd	r24, Y+24	; 0x18
    18fa:	99 8d       	ldd	r25, Y+25	; 0x19
    18fc:	89 2b       	or	r24, r25
    18fe:	21 f0       	breq	.+8      	; 0x1908 <xTaskIncrementTick+0x11e>
    1900:	ce 01       	movw	r24, r28
    1902:	0e 96       	adiw	r24, 0x0e	; 14
    1904:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    1908:	8a 8d       	ldd	r24, Y+26	; 0x1a
    190a:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    190e:	98 17       	cp	r25, r24
    1910:	10 f4       	brcc	.+4      	; 0x1916 <xTaskIncrementTick+0x12c>
    1912:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1916:	a8 9e       	mul	r10, r24
    1918:	c0 01       	movw	r24, r0
    191a:	11 24       	eor	r1, r1
    191c:	b8 01       	movw	r22, r16
    191e:	80 5c       	subi	r24, 0xC0	; 192
    1920:	93 4d       	sbci	r25, 0xD3	; 211
    1922:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1926:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    192a:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    192e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1930:	82 8d       	ldd	r24, Z+26	; 0x1a
    1932:	98 17       	cp	r25, r24
    1934:	08 f4       	brcc	.+2      	; 0x1938 <xTaskIncrementTick+0x14e>
    1936:	ac cf       	rjmp	.-168    	; 0x1890 <xTaskIncrementTick+0xa6>
    1938:	bb 24       	eor	r11, r11
    193a:	b3 94       	inc	r11
    193c:	a9 cf       	rjmp	.-174    	; 0x1890 <xTaskIncrementTick+0xa6>
    193e:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1942:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1946:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1948:	8b e0       	ldi	r24, 0x0B	; 11
    194a:	e8 9f       	mul	r30, r24
    194c:	f0 01       	movw	r30, r0
    194e:	11 24       	eor	r1, r1
    1950:	e0 5c       	subi	r30, 0xC0	; 192
    1952:	f3 4d       	sbci	r31, 0xD3	; 211
    1954:	80 81       	ld	r24, Z
    1956:	82 30       	cpi	r24, 0x02	; 2
    1958:	48 f0       	brcs	.+18     	; 0x196c <xTaskIncrementTick+0x182>
    195a:	bb 24       	eor	r11, r11
    195c:	b3 94       	inc	r11
    195e:	06 c0       	rjmp	.+12     	; 0x196c <xTaskIncrementTick+0x182>
    1960:	80 91 08 2c 	lds	r24, 0x2C08	; 0x802c08 <uxPendedTicks>
    1964:	8f 5f       	subi	r24, 0xFF	; 255
    1966:	80 93 08 2c 	sts	0x2C08, r24	; 0x802c08 <uxPendedTicks>
    196a:	b1 2c       	mov	r11, r1
    196c:	80 91 07 2c 	lds	r24, 0x2C07	; 0x802c07 <xYieldPending>
    1970:	88 23       	and	r24, r24
    1972:	11 f0       	breq	.+4      	; 0x1978 <xTaskIncrementTick+0x18e>
    1974:	bb 24       	eor	r11, r11
    1976:	b3 94       	inc	r11
    1978:	8b 2d       	mov	r24, r11
    197a:	df 91       	pop	r29
    197c:	cf 91       	pop	r28
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	ff 90       	pop	r15
    1984:	ef 90       	pop	r14
    1986:	df 90       	pop	r13
    1988:	cf 90       	pop	r12
    198a:	bf 90       	pop	r11
    198c:	af 90       	pop	r10
    198e:	08 95       	ret

00001990 <xTaskResumeAll>:
    1990:	cf 92       	push	r12
    1992:	df 92       	push	r13
    1994:	ef 92       	push	r14
    1996:	ff 92       	push	r15
    1998:	0f 93       	push	r16
    199a:	1f 93       	push	r17
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    19a4:	ff 93       	push	r31
    19a6:	f8 7f       	andi	r31, 0xF8	; 248
    19a8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    19ac:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    19b0:	81 50       	subi	r24, 0x01	; 1
    19b2:	80 93 fe 2b 	sts	0x2BFE, r24	; 0x802bfe <uxSchedulerSuspended>
    19b6:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    19ba:	81 11       	cpse	r24, r1
    19bc:	5c c0       	rjmp	.+184    	; 0x1a76 <xTaskResumeAll+0xe6>
    19be:	80 91 0f 2c 	lds	r24, 0x2C0F	; 0x802c0f <uxCurrentNumberOfTasks>
    19c2:	81 11       	cpse	r24, r1
    19c4:	2c c0       	rjmp	.+88     	; 0x1a1e <xTaskResumeAll+0x8e>
    19c6:	5a c0       	rjmp	.+180    	; 0x1a7c <xTaskResumeAll+0xec>
    19c8:	d7 01       	movw	r26, r14
    19ca:	17 96       	adiw	r26, 0x07	; 7
    19cc:	ed 91       	ld	r30, X+
    19ce:	fc 91       	ld	r31, X
    19d0:	18 97       	sbiw	r26, 0x08	; 8
    19d2:	c0 85       	ldd	r28, Z+8	; 0x08
    19d4:	d1 85       	ldd	r29, Z+9	; 0x09
    19d6:	ce 01       	movw	r24, r28
    19d8:	0e 96       	adiw	r24, 0x0e	; 14
    19da:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    19de:	8e 01       	movw	r16, r28
    19e0:	0e 5f       	subi	r16, 0xFE	; 254
    19e2:	1f 4f       	sbci	r17, 0xFF	; 255
    19e4:	c8 01       	movw	r24, r16
    19e6:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    19ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19ec:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    19f0:	98 17       	cp	r25, r24
    19f2:	10 f4       	brcc	.+4      	; 0x19f8 <xTaskResumeAll+0x68>
    19f4:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    19f8:	d8 9e       	mul	r13, r24
    19fa:	c0 01       	movw	r24, r0
    19fc:	11 24       	eor	r1, r1
    19fe:	b8 01       	movw	r22, r16
    1a00:	80 5c       	subi	r24, 0xC0	; 192
    1a02:	93 4d       	sbci	r25, 0xD3	; 211
    1a04:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1a08:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1a0c:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1a10:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a14:	98 17       	cp	r25, r24
    1a16:	88 f0       	brcs	.+34     	; 0x1a3a <xTaskResumeAll+0xaa>
    1a18:	c0 92 07 2c 	sts	0x2C07, r12	; 0x802c07 <xYieldPending>
    1a1c:	0e c0       	rjmp	.+28     	; 0x1a3a <xTaskResumeAll+0xaa>
    1a1e:	c0 e0       	ldi	r28, 0x00	; 0
    1a20:	d0 e0       	ldi	r29, 0x00	; 0
    1a22:	0f 2e       	mov	r0, r31
    1a24:	fb e1       	ldi	r31, 0x1B	; 27
    1a26:	ef 2e       	mov	r14, r31
    1a28:	fc e2       	ldi	r31, 0x2C	; 44
    1a2a:	ff 2e       	mov	r15, r31
    1a2c:	f0 2d       	mov	r31, r0
    1a2e:	0f 2e       	mov	r0, r31
    1a30:	fb e0       	ldi	r31, 0x0B	; 11
    1a32:	df 2e       	mov	r13, r31
    1a34:	f0 2d       	mov	r31, r0
    1a36:	cc 24       	eor	r12, r12
    1a38:	c3 94       	inc	r12
    1a3a:	f7 01       	movw	r30, r14
    1a3c:	80 81       	ld	r24, Z
    1a3e:	81 11       	cpse	r24, r1
    1a40:	c3 cf       	rjmp	.-122    	; 0x19c8 <xTaskResumeAll+0x38>
    1a42:	cd 2b       	or	r28, r29
    1a44:	11 f0       	breq	.+4      	; 0x1a4a <xTaskResumeAll+0xba>
    1a46:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <prvResetNextTaskUnblockTime>
    1a4a:	c0 91 08 2c 	lds	r28, 0x2C08	; 0x802c08 <uxPendedTicks>
    1a4e:	cc 23       	and	r28, r28
    1a50:	51 f0       	breq	.+20     	; 0x1a66 <xTaskResumeAll+0xd6>
    1a52:	d1 e0       	ldi	r29, 0x01	; 1
    1a54:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <xTaskIncrementTick>
    1a58:	81 11       	cpse	r24, r1
    1a5a:	d0 93 07 2c 	sts	0x2C07, r29	; 0x802c07 <xYieldPending>
    1a5e:	c1 50       	subi	r28, 0x01	; 1
    1a60:	c9 f7       	brne	.-14     	; 0x1a54 <xTaskResumeAll+0xc4>
    1a62:	10 92 08 2c 	sts	0x2C08, r1	; 0x802c08 <uxPendedTicks>
    1a66:	80 91 07 2c 	lds	r24, 0x2C07	; 0x802c07 <xYieldPending>
    1a6a:	88 23       	and	r24, r24
    1a6c:	31 f0       	breq	.+12     	; 0x1a7a <xTaskResumeAll+0xea>
    1a6e:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	03 c0       	rjmp	.+6      	; 0x1a7c <xTaskResumeAll+0xec>
    1a76:	80 e0       	ldi	r24, 0x00	; 0
    1a78:	01 c0       	rjmp	.+2      	; 0x1a7c <xTaskResumeAll+0xec>
    1a7a:	80 e0       	ldi	r24, 0x00	; 0
    1a7c:	ff 91       	pop	r31
    1a7e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	1f 91       	pop	r17
    1a88:	0f 91       	pop	r16
    1a8a:	ff 90       	pop	r15
    1a8c:	ef 90       	pop	r14
    1a8e:	df 90       	pop	r13
    1a90:	cf 90       	pop	r12
    1a92:	08 95       	ret

00001a94 <vTaskDelay>:
    1a94:	cf 92       	push	r12
    1a96:	df 92       	push	r13
    1a98:	ef 92       	push	r14
    1a9a:	ff 92       	push	r15
    1a9c:	6b 01       	movw	r12, r22
    1a9e:	7c 01       	movw	r14, r24
    1aa0:	67 2b       	or	r22, r23
    1aa2:	68 2b       	or	r22, r24
    1aa4:	69 2b       	or	r22, r25
    1aa6:	59 f0       	breq	.+22     	; 0x1abe <vTaskDelay+0x2a>
    1aa8:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
    1aac:	40 e0       	ldi	r20, 0x00	; 0
    1aae:	c7 01       	movw	r24, r14
    1ab0:	b6 01       	movw	r22, r12
    1ab2:	0e 94 0a 0a 	call	0x1414	; 0x1414 <prvAddCurrentTaskToDelayedList>
    1ab6:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    1aba:	81 11       	cpse	r24, r1
    1abc:	02 c0       	rjmp	.+4      	; 0x1ac2 <vTaskDelay+0x2e>
    1abe:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    1ac2:	ff 90       	pop	r15
    1ac4:	ef 90       	pop	r14
    1ac6:	df 90       	pop	r13
    1ac8:	cf 90       	pop	r12
    1aca:	08 95       	ret

00001acc <vTaskSwitchContext>:
    1acc:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    1ad0:	88 23       	and	r24, r24
    1ad2:	21 f0       	breq	.+8      	; 0x1adc <vTaskSwitchContext+0x10>
    1ad4:	81 e0       	ldi	r24, 0x01	; 1
    1ad6:	80 93 07 2c 	sts	0x2C07, r24	; 0x802c07 <xYieldPending>
    1ada:	08 95       	ret
    1adc:	10 92 07 2c 	sts	0x2C07, r1	; 0x802c07 <xYieldPending>
    1ae0:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1ae4:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1ae8:	03 8c       	ldd	r0, Z+27	; 0x1b
    1aea:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1aec:	e0 2d       	mov	r30, r0
    1aee:	80 81       	ld	r24, Z
    1af0:	91 81       	ldd	r25, Z+1	; 0x01
    1af2:	a2 81       	ldd	r26, Z+2	; 0x02
    1af4:	b3 81       	ldd	r27, Z+3	; 0x03
    1af6:	85 3a       	cpi	r24, 0xA5	; 165
    1af8:	95 4a       	sbci	r25, 0xA5	; 165
    1afa:	a5 4a       	sbci	r26, 0xA5	; 165
    1afc:	b5 4a       	sbci	r27, 0xA5	; 165
    1afe:	d9 f4       	brne	.+54     	; 0x1b36 <vTaskSwitchContext+0x6a>
    1b00:	84 81       	ldd	r24, Z+4	; 0x04
    1b02:	95 81       	ldd	r25, Z+5	; 0x05
    1b04:	a6 81       	ldd	r26, Z+6	; 0x06
    1b06:	b7 81       	ldd	r27, Z+7	; 0x07
    1b08:	85 3a       	cpi	r24, 0xA5	; 165
    1b0a:	95 4a       	sbci	r25, 0xA5	; 165
    1b0c:	a5 4a       	sbci	r26, 0xA5	; 165
    1b0e:	b5 4a       	sbci	r27, 0xA5	; 165
    1b10:	91 f4       	brne	.+36     	; 0x1b36 <vTaskSwitchContext+0x6a>
    1b12:	80 85       	ldd	r24, Z+8	; 0x08
    1b14:	91 85       	ldd	r25, Z+9	; 0x09
    1b16:	a2 85       	ldd	r26, Z+10	; 0x0a
    1b18:	b3 85       	ldd	r27, Z+11	; 0x0b
    1b1a:	85 3a       	cpi	r24, 0xA5	; 165
    1b1c:	95 4a       	sbci	r25, 0xA5	; 165
    1b1e:	a5 4a       	sbci	r26, 0xA5	; 165
    1b20:	b5 4a       	sbci	r27, 0xA5	; 165
    1b22:	49 f4       	brne	.+18     	; 0x1b36 <vTaskSwitchContext+0x6a>
    1b24:	84 85       	ldd	r24, Z+12	; 0x0c
    1b26:	95 85       	ldd	r25, Z+13	; 0x0d
    1b28:	a6 85       	ldd	r26, Z+14	; 0x0e
    1b2a:	b7 85       	ldd	r27, Z+15	; 0x0f
    1b2c:	85 3a       	cpi	r24, 0xA5	; 165
    1b2e:	95 4a       	sbci	r25, 0xA5	; 165
    1b30:	a5 4a       	sbci	r26, 0xA5	; 165
    1b32:	b5 4a       	sbci	r27, 0xA5	; 165
    1b34:	61 f0       	breq	.+24     	; 0x1b4e <vTaskSwitchContext+0x82>
    1b36:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1b3a:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1b3e:	80 91 6c 2c 	lds	r24, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1b42:	90 91 6d 2c 	lds	r25, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1b46:	63 5e       	subi	r22, 0xE3	; 227
    1b48:	7f 4f       	sbci	r23, 0xFF	; 255
    1b4a:	0e 94 af 01 	call	0x35e	; 0x35e <vApplicationStackOverflowHook>
    1b4e:	80 91 0a 2c 	lds	r24, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    1b52:	28 2f       	mov	r18, r24
    1b54:	30 e0       	ldi	r19, 0x00	; 0
    1b56:	9b e0       	ldi	r25, 0x0B	; 11
    1b58:	89 9f       	mul	r24, r25
    1b5a:	f0 01       	movw	r30, r0
    1b5c:	11 24       	eor	r1, r1
    1b5e:	e0 5c       	subi	r30, 0xC0	; 192
    1b60:	f3 4d       	sbci	r31, 0xD3	; 211
    1b62:	90 81       	ld	r25, Z
    1b64:	91 11       	cpse	r25, r1
    1b66:	0e c0       	rjmp	.+28     	; 0x1b84 <vTaskSwitchContext+0xb8>
    1b68:	4b e0       	ldi	r20, 0x0B	; 11
    1b6a:	81 50       	subi	r24, 0x01	; 1
    1b6c:	28 2f       	mov	r18, r24
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	42 9f       	mul	r20, r18
    1b72:	f0 01       	movw	r30, r0
    1b74:	43 9f       	mul	r20, r19
    1b76:	f0 0d       	add	r31, r0
    1b78:	11 24       	eor	r1, r1
    1b7a:	e0 5c       	subi	r30, 0xC0	; 192
    1b7c:	f3 4d       	sbci	r31, 0xD3	; 211
    1b7e:	90 81       	ld	r25, Z
    1b80:	99 23       	and	r25, r25
    1b82:	99 f3       	breq	.-26     	; 0x1b6a <vTaskSwitchContext+0x9e>
    1b84:	9b e0       	ldi	r25, 0x0B	; 11
    1b86:	92 9f       	mul	r25, r18
    1b88:	a0 01       	movw	r20, r0
    1b8a:	93 9f       	mul	r25, r19
    1b8c:	50 0d       	add	r21, r0
    1b8e:	11 24       	eor	r1, r1
    1b90:	da 01       	movw	r26, r20
    1b92:	a0 5c       	subi	r26, 0xC0	; 192
    1b94:	b3 4d       	sbci	r27, 0xD3	; 211
    1b96:	11 96       	adiw	r26, 0x01	; 1
    1b98:	ed 91       	ld	r30, X+
    1b9a:	fc 91       	ld	r31, X
    1b9c:	12 97       	sbiw	r26, 0x02	; 2
    1b9e:	04 80       	ldd	r0, Z+4	; 0x04
    1ba0:	f5 81       	ldd	r31, Z+5	; 0x05
    1ba2:	e0 2d       	mov	r30, r0
    1ba4:	11 96       	adiw	r26, 0x01	; 1
    1ba6:	ed 93       	st	X+, r30
    1ba8:	fc 93       	st	X, r31
    1baa:	12 97       	sbiw	r26, 0x02	; 2
    1bac:	4d 5b       	subi	r20, 0xBD	; 189
    1bae:	53 4d       	sbci	r21, 0xD3	; 211
    1bb0:	e4 17       	cp	r30, r20
    1bb2:	f5 07       	cpc	r31, r21
    1bb4:	29 f4       	brne	.+10     	; 0x1bc0 <vTaskSwitchContext+0xf4>
    1bb6:	44 81       	ldd	r20, Z+4	; 0x04
    1bb8:	55 81       	ldd	r21, Z+5	; 0x05
    1bba:	fd 01       	movw	r30, r26
    1bbc:	41 83       	std	Z+1, r20	; 0x01
    1bbe:	52 83       	std	Z+2, r21	; 0x02
    1bc0:	9b e0       	ldi	r25, 0x0B	; 11
    1bc2:	92 9f       	mul	r25, r18
    1bc4:	f0 01       	movw	r30, r0
    1bc6:	93 9f       	mul	r25, r19
    1bc8:	f0 0d       	add	r31, r0
    1bca:	11 24       	eor	r1, r1
    1bcc:	e0 5c       	subi	r30, 0xC0	; 192
    1bce:	f3 4d       	sbci	r31, 0xD3	; 211
    1bd0:	01 80       	ldd	r0, Z+1	; 0x01
    1bd2:	f2 81       	ldd	r31, Z+2	; 0x02
    1bd4:	e0 2d       	mov	r30, r0
    1bd6:	20 85       	ldd	r18, Z+8	; 0x08
    1bd8:	31 85       	ldd	r19, Z+9	; 0x09
    1bda:	20 93 6c 2c 	sts	0x2C6C, r18	; 0x802c6c <pxCurrentTCB>
    1bde:	30 93 6d 2c 	sts	0x2C6D, r19	; 0x802c6d <pxCurrentTCB+0x1>
    1be2:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1be6:	08 95       	ret

00001be8 <vTaskPlaceOnEventList>:
    1be8:	cf 92       	push	r12
    1bea:	df 92       	push	r13
    1bec:	ef 92       	push	r14
    1bee:	ff 92       	push	r15
    1bf0:	6a 01       	movw	r12, r20
    1bf2:	7b 01       	movw	r14, r22
    1bf4:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1bf8:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1bfc:	62 5f       	subi	r22, 0xF2	; 242
    1bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1c00:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    1c04:	41 e0       	ldi	r20, 0x01	; 1
    1c06:	c7 01       	movw	r24, r14
    1c08:	b6 01       	movw	r22, r12
    1c0a:	0e 94 0a 0a 	call	0x1414	; 0x1414 <prvAddCurrentTaskToDelayedList>
    1c0e:	ff 90       	pop	r15
    1c10:	ef 90       	pop	r14
    1c12:	df 90       	pop	r13
    1c14:	cf 90       	pop	r12
    1c16:	08 95       	ret

00001c18 <vTaskPlaceOnUnorderedEventList>:
    1c18:	cf 92       	push	r12
    1c1a:	df 92       	push	r13
    1c1c:	ef 92       	push	r14
    1c1e:	ff 92       	push	r15
    1c20:	0f 93       	push	r16
    1c22:	1f 93       	push	r17
    1c24:	68 01       	movw	r12, r16
    1c26:	79 01       	movw	r14, r18
    1c28:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1c2c:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1c30:	70 68       	ori	r23, 0x80	; 128
    1c32:	46 87       	std	Z+14, r20	; 0x0e
    1c34:	57 87       	std	Z+15, r21	; 0x0f
    1c36:	60 8b       	std	Z+16, r22	; 0x10
    1c38:	71 8b       	std	Z+17, r23	; 0x11
    1c3a:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1c3e:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1c42:	62 5f       	subi	r22, 0xF2	; 242
    1c44:	7f 4f       	sbci	r23, 0xFF	; 255
    1c46:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1c4a:	41 e0       	ldi	r20, 0x01	; 1
    1c4c:	c7 01       	movw	r24, r14
    1c4e:	b6 01       	movw	r22, r12
    1c50:	0e 94 0a 0a 	call	0x1414	; 0x1414 <prvAddCurrentTaskToDelayedList>
    1c54:	1f 91       	pop	r17
    1c56:	0f 91       	pop	r16
    1c58:	ff 90       	pop	r15
    1c5a:	ef 90       	pop	r14
    1c5c:	df 90       	pop	r13
    1c5e:	cf 90       	pop	r12
    1c60:	08 95       	ret

00001c62 <vTaskPlaceOnEventListRestricted>:
    1c62:	cf 92       	push	r12
    1c64:	df 92       	push	r13
    1c66:	ef 92       	push	r14
    1c68:	ff 92       	push	r15
    1c6a:	cf 93       	push	r28
    1c6c:	6a 01       	movw	r12, r20
    1c6e:	7b 01       	movw	r14, r22
    1c70:	c2 2f       	mov	r28, r18
    1c72:	60 91 6c 2c 	lds	r22, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1c76:	70 91 6d 2c 	lds	r23, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1c7a:	62 5f       	subi	r22, 0xF2	; 242
    1c7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c7e:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1c82:	cc 23       	and	r28, r28
    1c84:	21 f0       	breq	.+8      	; 0x1c8e <vTaskPlaceOnEventListRestricted+0x2c>
    1c86:	cc 24       	eor	r12, r12
    1c88:	ca 94       	dec	r12
    1c8a:	dc 2c       	mov	r13, r12
    1c8c:	76 01       	movw	r14, r12
    1c8e:	4c 2f       	mov	r20, r28
    1c90:	c7 01       	movw	r24, r14
    1c92:	b6 01       	movw	r22, r12
    1c94:	0e 94 0a 0a 	call	0x1414	; 0x1414 <prvAddCurrentTaskToDelayedList>
    1c98:	cf 91       	pop	r28
    1c9a:	ff 90       	pop	r15
    1c9c:	ef 90       	pop	r14
    1c9e:	df 90       	pop	r13
    1ca0:	cf 90       	pop	r12
    1ca2:	08 95       	ret

00001ca4 <xTaskRemoveFromEventList>:
    1ca4:	0f 93       	push	r16
    1ca6:	1f 93       	push	r17
    1ca8:	cf 93       	push	r28
    1caa:	df 93       	push	r29
    1cac:	dc 01       	movw	r26, r24
    1cae:	17 96       	adiw	r26, 0x07	; 7
    1cb0:	ed 91       	ld	r30, X+
    1cb2:	fc 91       	ld	r31, X
    1cb4:	18 97       	sbiw	r26, 0x08	; 8
    1cb6:	c0 85       	ldd	r28, Z+8	; 0x08
    1cb8:	d1 85       	ldd	r29, Z+9	; 0x09
    1cba:	8e 01       	movw	r16, r28
    1cbc:	02 5f       	subi	r16, 0xF2	; 242
    1cbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc0:	c8 01       	movw	r24, r16
    1cc2:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    1cc6:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    1cca:	81 11       	cpse	r24, r1
    1ccc:	16 c0       	rjmp	.+44     	; 0x1cfa <xTaskRemoveFromEventList+0x56>
    1cce:	0c 50       	subi	r16, 0x0C	; 12
    1cd0:	11 09       	sbc	r17, r1
    1cd2:	c8 01       	movw	r24, r16
    1cd4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    1cd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cda:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    1cde:	98 17       	cp	r25, r24
    1ce0:	10 f4       	brcc	.+4      	; 0x1ce6 <xTaskRemoveFromEventList+0x42>
    1ce2:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1ce6:	bb e0       	ldi	r27, 0x0B	; 11
    1ce8:	8b 9f       	mul	r24, r27
    1cea:	c0 01       	movw	r24, r0
    1cec:	11 24       	eor	r1, r1
    1cee:	b8 01       	movw	r22, r16
    1cf0:	80 5c       	subi	r24, 0xC0	; 192
    1cf2:	93 4d       	sbci	r25, 0xD3	; 211
    1cf4:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1cf8:	05 c0       	rjmp	.+10     	; 0x1d04 <xTaskRemoveFromEventList+0x60>
    1cfa:	b8 01       	movw	r22, r16
    1cfc:	8b e1       	ldi	r24, 0x1B	; 27
    1cfe:	9c e2       	ldi	r25, 0x2C	; 44
    1d00:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1d04:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1d08:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1d0c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d10:	89 17       	cp	r24, r25
    1d12:	20 f4       	brcc	.+8      	; 0x1d1c <xTaskRemoveFromEventList+0x78>
    1d14:	81 e0       	ldi	r24, 0x01	; 1
    1d16:	80 93 07 2c 	sts	0x2C07, r24	; 0x802c07 <xYieldPending>
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <xTaskRemoveFromEventList+0x7a>
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	1f 91       	pop	r17
    1d24:	0f 91       	pop	r16
    1d26:	08 95       	ret

00001d28 <vTaskRemoveFromUnorderedEventList>:
    1d28:	0f 93       	push	r16
    1d2a:	1f 93       	push	r17
    1d2c:	cf 93       	push	r28
    1d2e:	df 93       	push	r29
    1d30:	70 68       	ori	r23, 0x80	; 128
    1d32:	fc 01       	movw	r30, r24
    1d34:	40 83       	st	Z, r20
    1d36:	51 83       	std	Z+1, r21	; 0x01
    1d38:	62 83       	std	Z+2, r22	; 0x02
    1d3a:	73 83       	std	Z+3, r23	; 0x03
    1d3c:	c0 85       	ldd	r28, Z+8	; 0x08
    1d3e:	d1 85       	ldd	r29, Z+9	; 0x09
    1d40:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    1d44:	8e 01       	movw	r16, r28
    1d46:	0e 5f       	subi	r16, 0xFE	; 254
    1d48:	1f 4f       	sbci	r17, 0xFF	; 255
    1d4a:	c8 01       	movw	r24, r16
    1d4c:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    1d50:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d52:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    1d56:	98 17       	cp	r25, r24
    1d58:	10 f4       	brcc	.+4      	; 0x1d5e <vTaskRemoveFromUnorderedEventList+0x36>
    1d5a:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1d5e:	fb e0       	ldi	r31, 0x0B	; 11
    1d60:	8f 9f       	mul	r24, r31
    1d62:	c0 01       	movw	r24, r0
    1d64:	11 24       	eor	r1, r1
    1d66:	b8 01       	movw	r22, r16
    1d68:	80 5c       	subi	r24, 0xC0	; 192
    1d6a:	93 4d       	sbci	r25, 0xD3	; 211
    1d6c:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
    1d70:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1d74:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1d78:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d7c:	89 17       	cp	r24, r25
    1d7e:	18 f4       	brcc	.+6      	; 0x1d86 <vTaskRemoveFromUnorderedEventList+0x5e>
    1d80:	81 e0       	ldi	r24, 0x01	; 1
    1d82:	80 93 07 2c 	sts	0x2C07, r24	; 0x802c07 <xYieldPending>
    1d86:	df 91       	pop	r29
    1d88:	cf 91       	pop	r28
    1d8a:	1f 91       	pop	r17
    1d8c:	0f 91       	pop	r16
    1d8e:	08 95       	ret

00001d90 <vTaskInternalSetTimeOutState>:
    1d90:	20 91 06 2c 	lds	r18, 0x2C06	; 0x802c06 <xNumOfOverflows>
    1d94:	fc 01       	movw	r30, r24
    1d96:	20 83       	st	Z, r18
    1d98:	40 91 0b 2c 	lds	r20, 0x2C0B	; 0x802c0b <xTickCount>
    1d9c:	50 91 0c 2c 	lds	r21, 0x2C0C	; 0x802c0c <xTickCount+0x1>
    1da0:	60 91 0d 2c 	lds	r22, 0x2C0D	; 0x802c0d <xTickCount+0x2>
    1da4:	70 91 0e 2c 	lds	r23, 0x2C0E	; 0x802c0e <xTickCount+0x3>
    1da8:	41 83       	std	Z+1, r20	; 0x01
    1daa:	52 83       	std	Z+2, r21	; 0x02
    1dac:	63 83       	std	Z+3, r22	; 0x03
    1dae:	74 83       	std	Z+4, r23	; 0x04
    1db0:	08 95       	ret

00001db2 <xTaskCheckForTimeOut>:
    1db2:	cf 92       	push	r12
    1db4:	df 92       	push	r13
    1db6:	ef 92       	push	r14
    1db8:	ff 92       	push	r15
    1dba:	0f 93       	push	r16
    1dbc:	1f 93       	push	r17
    1dbe:	cf 93       	push	r28
    1dc0:	df 93       	push	r29
    1dc2:	db 01       	movw	r26, r22
    1dc4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1dc8:	ff 93       	push	r31
    1dca:	f8 7f       	andi	r31, 0xF8	; 248
    1dcc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1dd0:	40 91 0b 2c 	lds	r20, 0x2C0B	; 0x802c0b <xTickCount>
    1dd4:	50 91 0c 2c 	lds	r21, 0x2C0C	; 0x802c0c <xTickCount+0x1>
    1dd8:	60 91 0d 2c 	lds	r22, 0x2C0D	; 0x802c0d <xTickCount+0x2>
    1ddc:	70 91 0e 2c 	lds	r23, 0x2C0E	; 0x802c0e <xTickCount+0x3>
    1de0:	0d 91       	ld	r16, X+
    1de2:	1d 91       	ld	r17, X+
    1de4:	2d 91       	ld	r18, X+
    1de6:	3c 91       	ld	r19, X
    1de8:	13 97       	sbiw	r26, 0x03	; 3
    1dea:	0f 3f       	cpi	r16, 0xFF	; 255
    1dec:	cf ef       	ldi	r28, 0xFF	; 255
    1dee:	1c 07       	cpc	r17, r28
    1df0:	2c 07       	cpc	r18, r28
    1df2:	3c 07       	cpc	r19, r28
    1df4:	69 f1       	breq	.+90     	; 0x1e50 <xTaskCheckForTimeOut+0x9e>
    1df6:	fc 01       	movw	r30, r24
    1df8:	c1 80       	ldd	r12, Z+1	; 0x01
    1dfa:	d2 80       	ldd	r13, Z+2	; 0x02
    1dfc:	e3 80       	ldd	r14, Z+3	; 0x03
    1dfe:	f4 80       	ldd	r15, Z+4	; 0x04
    1e00:	e0 91 06 2c 	lds	r30, 0x2C06	; 0x802c06 <xNumOfOverflows>
    1e04:	ec 01       	movw	r28, r24
    1e06:	f8 81       	ld	r31, Y
    1e08:	fe 17       	cp	r31, r30
    1e0a:	29 f0       	breq	.+10     	; 0x1e16 <xTaskCheckForTimeOut+0x64>
    1e0c:	4c 15       	cp	r20, r12
    1e0e:	5d 05       	cpc	r21, r13
    1e10:	6e 05       	cpc	r22, r14
    1e12:	7f 05       	cpc	r23, r15
    1e14:	f8 f4       	brcc	.+62     	; 0x1e54 <xTaskCheckForTimeOut+0xa2>
    1e16:	4c 19       	sub	r20, r12
    1e18:	5d 09       	sbc	r21, r13
    1e1a:	6e 09       	sbc	r22, r14
    1e1c:	7f 09       	sbc	r23, r15
    1e1e:	40 17       	cp	r20, r16
    1e20:	51 07       	cpc	r21, r17
    1e22:	62 07       	cpc	r22, r18
    1e24:	73 07       	cpc	r23, r19
    1e26:	68 f4       	brcc	.+26     	; 0x1e42 <xTaskCheckForTimeOut+0x90>
    1e28:	fd 01       	movw	r30, r26
    1e2a:	04 1b       	sub	r16, r20
    1e2c:	15 0b       	sbc	r17, r21
    1e2e:	26 0b       	sbc	r18, r22
    1e30:	37 0b       	sbc	r19, r23
    1e32:	00 83       	st	Z, r16
    1e34:	11 83       	std	Z+1, r17	; 0x01
    1e36:	22 83       	std	Z+2, r18	; 0x02
    1e38:	33 83       	std	Z+3, r19	; 0x03
    1e3a:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <vTaskInternalSetTimeOutState>
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	0a c0       	rjmp	.+20     	; 0x1e56 <xTaskCheckForTimeOut+0xa4>
    1e42:	1d 92       	st	X+, r1
    1e44:	1d 92       	st	X+, r1
    1e46:	1d 92       	st	X+, r1
    1e48:	1c 92       	st	X, r1
    1e4a:	13 97       	sbiw	r26, 0x03	; 3
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	03 c0       	rjmp	.+6      	; 0x1e56 <xTaskCheckForTimeOut+0xa4>
    1e50:	80 e0       	ldi	r24, 0x00	; 0
    1e52:	01 c0       	rjmp	.+2      	; 0x1e56 <xTaskCheckForTimeOut+0xa4>
    1e54:	81 e0       	ldi	r24, 0x01	; 1
    1e56:	ff 91       	pop	r31
    1e58:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e5c:	df 91       	pop	r29
    1e5e:	cf 91       	pop	r28
    1e60:	1f 91       	pop	r17
    1e62:	0f 91       	pop	r16
    1e64:	ff 90       	pop	r15
    1e66:	ef 90       	pop	r14
    1e68:	df 90       	pop	r13
    1e6a:	cf 90       	pop	r12
    1e6c:	08 95       	ret

00001e6e <vTaskMissedYield>:
    1e6e:	81 e0       	ldi	r24, 0x01	; 1
    1e70:	80 93 07 2c 	sts	0x2C07, r24	; 0x802c07 <xYieldPending>
    1e74:	08 95       	ret

00001e76 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e76:	80 91 09 2c 	lds	r24, 0x2C09	; 0x802c09 <xSchedulerRunning>
    1e7a:	88 23       	and	r24, r24
    1e7c:	31 f0       	breq	.+12     	; 0x1e8a <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e7e:	80 91 fe 2b 	lds	r24, 0x2BFE	; 0x802bfe <uxSchedulerSuspended>
    1e82:	88 23       	and	r24, r24
    1e84:	21 f0       	breq	.+8      	; 0x1e8e <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e86:	80 e0       	ldi	r24, 0x00	; 0
    1e88:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e8e:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e90:	08 95       	ret

00001e92 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1e92:	0f 93       	push	r16
    1e94:	1f 93       	push	r17
    1e96:	cf 93       	push	r28
    1e98:	df 93       	push	r29
    1e9a:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    1e9c:	89 2b       	or	r24, r25
    1e9e:	09 f4       	brne	.+2      	; 0x1ea2 <xTaskPriorityInherit+0x10>
    1ea0:	60 c0       	rjmp	.+192    	; 0x1f62 <xTaskPriorityInherit+0xd0>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    1ea2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ea4:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1ea8:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1eac:	5a 96       	adiw	r26, 0x1a	; 26
    1eae:	9c 91       	ld	r25, X
    1eb0:	89 17       	cp	r24, r25
    1eb2:	08 f0       	brcs	.+2      	; 0x1eb6 <xTaskPriorityInherit+0x24>
    1eb4:	4a c0       	rjmp	.+148    	; 0x1f4a <xTaskPriorityInherit+0xb8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1eb6:	46 85       	ldd	r20, Z+14	; 0x0e
    1eb8:	57 85       	ldd	r21, Z+15	; 0x0f
    1eba:	60 89       	ldd	r22, Z+16	; 0x10
    1ebc:	71 89       	ldd	r23, Z+17	; 0x11
    1ebe:	77 23       	and	r23, r23
    1ec0:	94 f0       	brlt	.+36     	; 0x1ee6 <xTaskPriorityInherit+0x54>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ec2:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1ec6:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1eca:	5a 96       	adiw	r26, 0x1a	; 26
    1ecc:	9c 91       	ld	r25, X
    1ece:	44 e0       	ldi	r20, 0x04	; 4
    1ed0:	50 e0       	ldi	r21, 0x00	; 0
    1ed2:	60 e0       	ldi	r22, 0x00	; 0
    1ed4:	70 e0       	ldi	r23, 0x00	; 0
    1ed6:	49 1b       	sub	r20, r25
    1ed8:	51 09       	sbc	r21, r1
    1eda:	61 09       	sbc	r22, r1
    1edc:	71 09       	sbc	r23, r1
    1ede:	46 87       	std	Z+14, r20	; 0x0e
    1ee0:	57 87       	std	Z+15, r21	; 0x0f
    1ee2:	60 8b       	std	Z+16, r22	; 0x10
    1ee4:	71 8b       	std	Z+17, r23	; 0x11
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    1ee6:	2b e0       	ldi	r18, 0x0B	; 11
    1ee8:	82 9f       	mul	r24, r18
    1eea:	c0 01       	movw	r24, r0
    1eec:	11 24       	eor	r1, r1
    1eee:	80 5c       	subi	r24, 0xC0	; 192
    1ef0:	93 4d       	sbci	r25, 0xD3	; 211
    1ef2:	24 85       	ldd	r18, Z+12	; 0x0c
    1ef4:	35 85       	ldd	r19, Z+13	; 0x0d
    1ef6:	28 17       	cp	r18, r24
    1ef8:	39 07       	cpc	r19, r25
    1efa:	f1 f4       	brne	.+60     	; 0x1f38 <xTaskPriorityInherit+0xa6>
    1efc:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1efe:	ef 01       	movw	r28, r30
    1f00:	22 96       	adiw	r28, 0x02	; 2
    1f02:	ce 01       	movw	r24, r28
    1f04:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f08:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1f0c:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1f10:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f12:	f8 01       	movw	r30, r16
    1f14:	82 8f       	std	Z+26, r24	; 0x1a
					prvAddTaskToReadyList( pxMutexHolderTCB );
    1f16:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    1f1a:	98 17       	cp	r25, r24
    1f1c:	10 f4       	brcc	.+4      	; 0x1f22 <xTaskPriorityInherit+0x90>
    1f1e:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1f22:	fb e0       	ldi	r31, 0x0B	; 11
    1f24:	8f 9f       	mul	r24, r31
    1f26:	c0 01       	movw	r24, r0
    1f28:	11 24       	eor	r1, r1
    1f2a:	be 01       	movw	r22, r28
    1f2c:	80 5c       	subi	r24, 0xC0	; 192
    1f2e:	93 4d       	sbci	r25, 0xD3	; 211
    1f30:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	16 c0       	rjmp	.+44     	; 0x1f64 <xTaskPriorityInherit+0xd2>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f38:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1f3c:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    1f40:	5a 96       	adiw	r26, 0x1a	; 26
    1f42:	8c 91       	ld	r24, X
    1f44:	82 8f       	std	Z+26, r24	; 0x1a
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	0d c0       	rjmp	.+26     	; 0x1f64 <xTaskPriorityInherit+0xd2>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    1f4a:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    1f4e:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	27 a1       	ldd	r18, Z+39	; 0x27
    1f56:	5a 96       	adiw	r26, 0x1a	; 26
    1f58:	9c 91       	ld	r25, X
    1f5a:	29 17       	cp	r18, r25
    1f5c:	18 f0       	brcs	.+6      	; 0x1f64 <xTaskPriorityInherit+0xd2>
    1f5e:	80 e0       	ldi	r24, 0x00	; 0
    1f60:	01 c0       	rjmp	.+2      	; 0x1f64 <xTaskPriorityInherit+0xd2>
    1f62:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1f64:	df 91       	pop	r29
    1f66:	cf 91       	pop	r28
    1f68:	1f 91       	pop	r17
    1f6a:	0f 91       	pop	r16
    1f6c:	08 95       	ret

00001f6e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1f6e:	0f 93       	push	r16
    1f70:	1f 93       	push	r17
    1f72:	cf 93       	push	r28
    1f74:	df 93       	push	r29
    1f76:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1f78:	89 2b       	or	r24, r25
    1f7a:	79 f1       	breq	.+94     	; 0x1fda <xTaskPriorityDisinherit+0x6c>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1f7c:	80 a5       	ldd	r24, Z+40	; 0x28
    1f7e:	81 50       	subi	r24, 0x01	; 1
    1f80:	80 a7       	std	Z+40, r24	; 0x28

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1f82:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f84:	97 a1       	ldd	r25, Z+39	; 0x27
    1f86:	29 17       	cp	r18, r25
    1f88:	51 f1       	breq	.+84     	; 0x1fde <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1f8a:	81 11       	cpse	r24, r1
    1f8c:	2a c0       	rjmp	.+84     	; 0x1fe2 <xTaskPriorityDisinherit+0x74>
    1f8e:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f90:	8f 01       	movw	r16, r30
    1f92:	0e 5f       	subi	r16, 0xFE	; 254
    1f94:	1f 4f       	sbci	r17, 0xFF	; 255
    1f96:	c8 01       	movw	r24, r16
    1f98:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1f9c:	8f a1       	ldd	r24, Y+39	; 0x27
    1f9e:	8a 8f       	std	Y+26, r24	; 0x1a

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1fa0:	44 e0       	ldi	r20, 0x04	; 4
    1fa2:	50 e0       	ldi	r21, 0x00	; 0
    1fa4:	60 e0       	ldi	r22, 0x00	; 0
    1fa6:	70 e0       	ldi	r23, 0x00	; 0
    1fa8:	48 1b       	sub	r20, r24
    1faa:	51 09       	sbc	r21, r1
    1fac:	61 09       	sbc	r22, r1
    1fae:	71 09       	sbc	r23, r1
    1fb0:	4e 87       	std	Y+14, r20	; 0x0e
    1fb2:	5f 87       	std	Y+15, r21	; 0x0f
    1fb4:	68 8b       	std	Y+16, r22	; 0x10
    1fb6:	79 8b       	std	Y+17, r23	; 0x11
					prvAddTaskToReadyList( pxTCB );
    1fb8:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    1fbc:	98 17       	cp	r25, r24
    1fbe:	10 f4       	brcc	.+4      	; 0x1fc4 <xTaskPriorityDisinherit+0x56>
    1fc0:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    1fc4:	2b e0       	ldi	r18, 0x0B	; 11
    1fc6:	82 9f       	mul	r24, r18
    1fc8:	c0 01       	movw	r24, r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	b8 01       	movw	r22, r16
    1fce:	80 5c       	subi	r24, 0xC0	; 192
    1fd0:	93 4d       	sbci	r25, 0xD3	; 211
    1fd2:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	05 c0       	rjmp	.+10     	; 0x1fe4 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1fda:	80 e0       	ldi	r24, 0x00	; 0
    1fdc:	03 c0       	rjmp	.+6      	; 0x1fe4 <xTaskPriorityDisinherit+0x76>
    1fde:	80 e0       	ldi	r24, 0x00	; 0
    1fe0:	01 c0       	rjmp	.+2      	; 0x1fe4 <xTaskPriorityDisinherit+0x76>
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	08 95       	ret

00001fee <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    1fee:	0f 93       	push	r16
    1ff0:	1f 93       	push	r17
    1ff2:	cf 93       	push	r28
    1ff4:	df 93       	push	r29
    1ff6:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

		if( pxMutexHolder != NULL )
    1ff8:	89 2b       	or	r24, r25
    1ffa:	09 f4       	brne	.+2      	; 0x1ffe <vTaskPriorityDisinheritAfterTimeout+0x10>
    1ffc:	3f c0       	rjmp	.+126    	; 0x207c <vTaskPriorityDisinheritAfterTimeout+0x8e>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    1ffe:	87 a1       	ldd	r24, Z+39	; 0x27
    2000:	86 17       	cp	r24, r22
    2002:	08 f4       	brcc	.+2      	; 0x2006 <vTaskPriorityDisinheritAfterTimeout+0x18>
    2004:	86 2f       	mov	r24, r22
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    2006:	92 8d       	ldd	r25, Z+26	; 0x1a
    2008:	98 17       	cp	r25, r24
    200a:	c1 f1       	breq	.+112    	; 0x207c <vTaskPriorityDisinheritAfterTimeout+0x8e>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    200c:	20 a5       	ldd	r18, Z+40	; 0x28
    200e:	21 30       	cpi	r18, 0x01	; 1
    2010:	a9 f5       	brne	.+106    	; 0x207c <vTaskPriorityDisinheritAfterTimeout+0x8e>
					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
					pxTCB->uxPriority = uxPriorityToUse;
    2012:	82 8f       	std	Z+26, r24	; 0x1a

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2014:	46 85       	ldd	r20, Z+14	; 0x0e
    2016:	57 85       	ldd	r21, Z+15	; 0x0f
    2018:	60 89       	ldd	r22, Z+16	; 0x10
    201a:	71 89       	ldd	r23, Z+17	; 0x11
    201c:	77 23       	and	r23, r23
    201e:	64 f0       	brlt	.+24     	; 0x2038 <vTaskPriorityDisinheritAfterTimeout+0x4a>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2020:	44 e0       	ldi	r20, 0x04	; 4
    2022:	50 e0       	ldi	r21, 0x00	; 0
    2024:	60 e0       	ldi	r22, 0x00	; 0
    2026:	70 e0       	ldi	r23, 0x00	; 0
    2028:	48 1b       	sub	r20, r24
    202a:	51 09       	sbc	r21, r1
    202c:	61 09       	sbc	r22, r1
    202e:	71 09       	sbc	r23, r1
    2030:	46 87       	std	Z+14, r20	; 0x0e
    2032:	57 87       	std	Z+15, r21	; 0x0f
    2034:	60 8b       	std	Z+16, r22	; 0x10
    2036:	71 8b       	std	Z+17, r23	; 0x11
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2038:	2b e0       	ldi	r18, 0x0B	; 11
    203a:	92 9f       	mul	r25, r18
    203c:	c0 01       	movw	r24, r0
    203e:	11 24       	eor	r1, r1
    2040:	80 5c       	subi	r24, 0xC0	; 192
    2042:	93 4d       	sbci	r25, 0xD3	; 211
    2044:	24 85       	ldd	r18, Z+12	; 0x0c
    2046:	35 85       	ldd	r19, Z+13	; 0x0d
    2048:	28 17       	cp	r18, r24
    204a:	39 07       	cpc	r19, r25
    204c:	b9 f4       	brne	.+46     	; 0x207c <vTaskPriorityDisinheritAfterTimeout+0x8e>
    204e:	ef 01       	movw	r28, r30
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2050:	8f 01       	movw	r16, r30
    2052:	0e 5f       	subi	r16, 0xFE	; 254
    2054:	1f 4f       	sbci	r17, 0xFF	; 255
    2056:	c8 01       	movw	r24, r16
    2058:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    205c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    205e:	90 91 0a 2c 	lds	r25, 0x2C0A	; 0x802c0a <uxTopReadyPriority>
    2062:	98 17       	cp	r25, r24
    2064:	10 f4       	brcc	.+4      	; 0x206a <vTaskPriorityDisinheritAfterTimeout+0x7c>
    2066:	80 93 0a 2c 	sts	0x2C0A, r24	; 0x802c0a <uxTopReadyPriority>
    206a:	2b e0       	ldi	r18, 0x0B	; 11
    206c:	82 9f       	mul	r24, r18
    206e:	c0 01       	movw	r24, r0
    2070:	11 24       	eor	r1, r1
    2072:	b8 01       	movw	r22, r16
    2074:	80 5c       	subi	r24, 0xC0	; 192
    2076:	93 4d       	sbci	r25, 0xD3	; 211
    2078:	0e 94 8b 03 	call	0x716	; 0x716 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	1f 91       	pop	r17
    2082:	0f 91       	pop	r16
    2084:	08 95       	ret

00002086 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    2086:	cf 92       	push	r12
    2088:	df 92       	push	r13
    208a:	ef 92       	push	r14
    208c:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    208e:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    2092:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    2096:	66 85       	ldd	r22, Z+14	; 0x0e
    2098:	77 85       	ldd	r23, Z+15	; 0x0f
    209a:	80 89       	ldd	r24, Z+16	; 0x10
    209c:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    209e:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    20a2:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    20a6:	a0 91 6c 2c 	lds	r26, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    20aa:	b0 91 6d 2c 	lds	r27, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    20ae:	5a 96       	adiw	r26, 0x1a	; 26
    20b0:	2c 91       	ld	r18, X
    20b2:	c1 2c       	mov	r12, r1
    20b4:	d1 2c       	mov	r13, r1
    20b6:	76 01       	movw	r14, r12
    20b8:	68 94       	set
    20ba:	c2 f8       	bld	r12, 2
    20bc:	c2 1a       	sub	r12, r18
    20be:	d1 08       	sbc	r13, r1
    20c0:	e1 08       	sbc	r14, r1
    20c2:	f1 08       	sbc	r15, r1
    20c4:	c6 86       	std	Z+14, r12	; 0x0e
    20c6:	d7 86       	std	Z+15, r13	; 0x0f
    20c8:	e0 8a       	std	Z+16, r14	; 0x10
    20ca:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    20cc:	ff 90       	pop	r15
    20ce:	ef 90       	pop	r14
    20d0:	df 90       	pop	r13
    20d2:	cf 90       	pop	r12
    20d4:	08 95       	ret

000020d6 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    20d6:	80 91 6c 2c 	lds	r24, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    20da:	90 91 6d 2c 	lds	r25, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    20de:	89 2b       	or	r24, r25
    20e0:	39 f0       	breq	.+14     	; 0x20f0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    20e2:	e0 91 6c 2c 	lds	r30, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    20e6:	f0 91 6d 2c 	lds	r31, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
    20ea:	80 a5       	ldd	r24, Z+40	; 0x28
    20ec:	8f 5f       	subi	r24, 0xFF	; 255
    20ee:	80 a7       	std	Z+40, r24	; 0x28
		}

		return pxCurrentTCB;
    20f0:	80 91 6c 2c 	lds	r24, 0x2C6C	; 0x802c6c <pxCurrentTCB>
    20f4:	90 91 6d 2c 	lds	r25, 0x2C6D	; 0x802c6d <pxCurrentTCB+0x1>
	}
    20f8:	08 95       	ret

000020fa <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    20fa:	cf 92       	push	r12
    20fc:	df 92       	push	r13
    20fe:	ef 92       	push	r14
    2100:	ff 92       	push	r15
    2102:	0f 93       	push	r16
    2104:	1f 93       	push	r17
    2106:	fc 01       	movw	r30, r24
    2108:	42 83       	std	Z+2, r20	; 0x02
    210a:	53 83       	std	Z+3, r21	; 0x03
    210c:	64 83       	std	Z+4, r22	; 0x04
    210e:	75 83       	std	Z+5, r23	; 0x05
    2110:	82 87       	std	Z+10, r24	; 0x0a
    2112:	93 87       	std	Z+11, r25	; 0x0b
    2114:	04 17       	cp	r16, r20
    2116:	15 07       	cpc	r17, r21
    2118:	26 07       	cpc	r18, r22
    211a:	37 07       	cpc	r19, r23
    211c:	c0 f0       	brcs	.+48     	; 0x214e <prvInsertTimerInActiveList+0x54>
    211e:	0c 19       	sub	r16, r12
    2120:	1d 09       	sbc	r17, r13
    2122:	2e 09       	sbc	r18, r14
    2124:	3f 09       	sbc	r19, r15
    2126:	86 85       	ldd	r24, Z+14	; 0x0e
    2128:	97 85       	ldd	r25, Z+15	; 0x0f
    212a:	a0 89       	ldd	r26, Z+16	; 0x10
    212c:	b1 89       	ldd	r27, Z+17	; 0x11
    212e:	08 17       	cp	r16, r24
    2130:	19 07       	cpc	r17, r25
    2132:	2a 07       	cpc	r18, r26
    2134:	3b 07       	cpc	r19, r27
    2136:	00 f5       	brcc	.+64     	; 0x2178 <prvInsertTimerInActiveList+0x7e>
    2138:	bf 01       	movw	r22, r30
    213a:	6e 5f       	subi	r22, 0xFE	; 254
    213c:	7f 4f       	sbci	r23, 0xFF	; 255
    213e:	80 91 76 2c 	lds	r24, 0x2C76	; 0x802c76 <pxOverflowTimerList>
    2142:	90 91 77 2c 	lds	r25, 0x2C77	; 0x802c77 <pxOverflowTimerList+0x1>
    2146:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    214a:	80 e0       	ldi	r24, 0x00	; 0
    214c:	18 c0       	rjmp	.+48     	; 0x217e <prvInsertTimerInActiveList+0x84>
    214e:	0c 15       	cp	r16, r12
    2150:	1d 05       	cpc	r17, r13
    2152:	2e 05       	cpc	r18, r14
    2154:	3f 05       	cpc	r19, r15
    2156:	28 f4       	brcc	.+10     	; 0x2162 <prvInsertTimerInActiveList+0x68>
    2158:	4c 15       	cp	r20, r12
    215a:	5d 05       	cpc	r21, r13
    215c:	6e 05       	cpc	r22, r14
    215e:	7f 05       	cpc	r23, r15
    2160:	68 f4       	brcc	.+26     	; 0x217c <prvInsertTimerInActiveList+0x82>
    2162:	bf 01       	movw	r22, r30
    2164:	6e 5f       	subi	r22, 0xFE	; 254
    2166:	7f 4f       	sbci	r23, 0xFF	; 255
    2168:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTimerList>
    216c:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTimerList+0x1>
    2170:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    2174:	80 e0       	ldi	r24, 0x00	; 0
    2176:	03 c0       	rjmp	.+6      	; 0x217e <prvInsertTimerInActiveList+0x84>
    2178:	81 e0       	ldi	r24, 0x01	; 1
    217a:	01 c0       	rjmp	.+2      	; 0x217e <prvInsertTimerInActiveList+0x84>
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	1f 91       	pop	r17
    2180:	0f 91       	pop	r16
    2182:	ff 90       	pop	r15
    2184:	ef 90       	pop	r14
    2186:	df 90       	pop	r13
    2188:	cf 90       	pop	r12
    218a:	08 95       	ret

0000218c <prvCheckForValidListAndQueue>:
    218c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2190:	ff 93       	push	r31
    2192:	f8 7f       	andi	r31, 0xF8	; 248
    2194:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2198:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    219c:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    21a0:	89 2b       	or	r24, r25
    21a2:	e9 f4       	brne	.+58     	; 0x21de <prvCheckForValidListAndQueue+0x52>
    21a4:	85 e8       	ldi	r24, 0x85	; 133
    21a6:	9c e2       	ldi	r25, 0x2C	; 44
    21a8:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    21ac:	8a e7       	ldi	r24, 0x7A	; 122
    21ae:	9c e2       	ldi	r25, 0x2C	; 44
    21b0:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    21b4:	85 e8       	ldi	r24, 0x85	; 133
    21b6:	9c e2       	ldi	r25, 0x2C	; 44
    21b8:	80 93 78 2c 	sts	0x2C78, r24	; 0x802c78 <pxCurrentTimerList>
    21bc:	90 93 79 2c 	sts	0x2C79, r25	; 0x802c79 <pxCurrentTimerList+0x1>
    21c0:	8a e7       	ldi	r24, 0x7A	; 122
    21c2:	9c e2       	ldi	r25, 0x2C	; 44
    21c4:	80 93 76 2c 	sts	0x2C76, r24	; 0x802c76 <pxOverflowTimerList>
    21c8:	90 93 77 2c 	sts	0x2C77, r25	; 0x802c77 <pxOverflowTimerList+0x1>
    21cc:	40 e0       	ldi	r20, 0x00	; 0
    21ce:	69 e0       	ldi	r22, 0x09	; 9
    21d0:	85 e0       	ldi	r24, 0x05	; 5
    21d2:	0e 94 ef 06 	call	0xdde	; 0xdde <xQueueGenericCreate>
    21d6:	80 93 74 2c 	sts	0x2C74, r24	; 0x802c74 <xTimerQueue>
    21da:	90 93 75 2c 	sts	0x2C75, r25	; 0x802c75 <xTimerQueue+0x1>
    21de:	ff 91       	pop	r31
    21e0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    21e4:	08 95       	ret

000021e6 <xTimerCreateTimerTask>:
    21e6:	ef 92       	push	r14
    21e8:	ff 92       	push	r15
    21ea:	0f 93       	push	r16
    21ec:	0e 94 c6 10 	call	0x218c	; 0x218c <prvCheckForValidListAndQueue>
    21f0:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    21f4:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    21f8:	89 2b       	or	r24, r25
    21fa:	91 f0       	breq	.+36     	; 0x2220 <xTimerCreateTimerTask+0x3a>
    21fc:	0f 2e       	mov	r0, r31
    21fe:	f2 e7       	ldi	r31, 0x72	; 114
    2200:	ef 2e       	mov	r14, r31
    2202:	fc e2       	ldi	r31, 0x2C	; 44
    2204:	ff 2e       	mov	r15, r31
    2206:	f0 2d       	mov	r31, r0
    2208:	03 e0       	ldi	r16, 0x03	; 3
    220a:	20 e0       	ldi	r18, 0x00	; 0
    220c:	30 e0       	ldi	r19, 0x00	; 0
    220e:	48 ec       	ldi	r20, 0xC8	; 200
    2210:	50 e0       	ldi	r21, 0x00	; 0
    2212:	65 e0       	ldi	r22, 0x05	; 5
    2214:	70 e2       	ldi	r23, 0x20	; 32
    2216:	86 e0       	ldi	r24, 0x06	; 6
    2218:	92 e1       	ldi	r25, 0x12	; 18
    221a:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
    221e:	01 c0       	rjmp	.+2      	; 0x2222 <xTimerCreateTimerTask+0x3c>
    2220:	80 e0       	ldi	r24, 0x00	; 0
    2222:	0f 91       	pop	r16
    2224:	ff 90       	pop	r15
    2226:	ef 90       	pop	r14
    2228:	08 95       	ret

0000222a <xTimerGenericCommand>:
    222a:	8f 92       	push	r8
    222c:	9f 92       	push	r9
    222e:	af 92       	push	r10
    2230:	bf 92       	push	r11
    2232:	cf 92       	push	r12
    2234:	df 92       	push	r13
    2236:	ef 92       	push	r14
    2238:	ff 92       	push	r15
    223a:	0f 93       	push	r16
    223c:	1f 93       	push	r17
    223e:	cf 93       	push	r28
    2240:	df 93       	push	r29
    2242:	cd b7       	in	r28, 0x3d	; 61
    2244:	de b7       	in	r29, 0x3e	; 62
    2246:	29 97       	sbiw	r28, 0x09	; 9
    2248:	cd bf       	out	0x3d, r28	; 61
    224a:	de bf       	out	0x3e, r29	; 62
    224c:	e0 91 74 2c 	lds	r30, 0x2C74	; 0x802c74 <xTimerQueue>
    2250:	f0 91 75 2c 	lds	r31, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    2254:	30 97       	sbiw	r30, 0x00	; 0
    2256:	89 f1       	breq	.+98     	; 0x22ba <xTimerGenericCommand+0x90>
    2258:	69 83       	std	Y+1, r22	; 0x01
    225a:	2a 83       	std	Y+2, r18	; 0x02
    225c:	3b 83       	std	Y+3, r19	; 0x03
    225e:	4c 83       	std	Y+4, r20	; 0x04
    2260:	5d 83       	std	Y+5, r21	; 0x05
    2262:	8e 83       	std	Y+6, r24	; 0x06
    2264:	9f 83       	std	Y+7, r25	; 0x07
    2266:	66 30       	cpi	r22, 0x06	; 6
    2268:	fc f4       	brge	.+62     	; 0x22a8 <xTimerGenericCommand+0x7e>
    226a:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <xTaskGetSchedulerState>
    226e:	82 30       	cpi	r24, 0x02	; 2
    2270:	69 f4       	brne	.+26     	; 0x228c <xTimerGenericCommand+0x62>
    2272:	00 e0       	ldi	r16, 0x00	; 0
    2274:	a7 01       	movw	r20, r14
    2276:	96 01       	movw	r18, r12
    2278:	be 01       	movw	r22, r28
    227a:	6f 5f       	subi	r22, 0xFF	; 255
    227c:	7f 4f       	sbci	r23, 0xFF	; 255
    227e:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    2282:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    2286:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
    228a:	18 c0       	rjmp	.+48     	; 0x22bc <xTimerGenericCommand+0x92>
    228c:	00 e0       	ldi	r16, 0x00	; 0
    228e:	20 e0       	ldi	r18, 0x00	; 0
    2290:	30 e0       	ldi	r19, 0x00	; 0
    2292:	a9 01       	movw	r20, r18
    2294:	be 01       	movw	r22, r28
    2296:	6f 5f       	subi	r22, 0xFF	; 255
    2298:	7f 4f       	sbci	r23, 0xFF	; 255
    229a:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    229e:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    22a2:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
    22a6:	0a c0       	rjmp	.+20     	; 0x22bc <xTimerGenericCommand+0x92>
    22a8:	20 e0       	ldi	r18, 0x00	; 0
    22aa:	a8 01       	movw	r20, r16
    22ac:	be 01       	movw	r22, r28
    22ae:	6f 5f       	subi	r22, 0xFF	; 255
    22b0:	7f 4f       	sbci	r23, 0xFF	; 255
    22b2:	cf 01       	movw	r24, r30
    22b4:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <xQueueGenericSendFromISR>
    22b8:	01 c0       	rjmp	.+2      	; 0x22bc <xTimerGenericCommand+0x92>
    22ba:	80 e0       	ldi	r24, 0x00	; 0
    22bc:	29 96       	adiw	r28, 0x09	; 9
    22be:	cd bf       	out	0x3d, r28	; 61
    22c0:	de bf       	out	0x3e, r29	; 62
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	bf 90       	pop	r11
    22d4:	af 90       	pop	r10
    22d6:	9f 90       	pop	r9
    22d8:	8f 90       	pop	r8
    22da:	08 95       	ret

000022dc <prvSampleTimeNow>:
    22dc:	2f 92       	push	r2
    22de:	3f 92       	push	r3
    22e0:	4f 92       	push	r4
    22e2:	5f 92       	push	r5
    22e4:	6f 92       	push	r6
    22e6:	7f 92       	push	r7
    22e8:	8f 92       	push	r8
    22ea:	9f 92       	push	r9
    22ec:	af 92       	push	r10
    22ee:	bf 92       	push	r11
    22f0:	cf 92       	push	r12
    22f2:	df 92       	push	r13
    22f4:	ef 92       	push	r14
    22f6:	ff 92       	push	r15
    22f8:	0f 93       	push	r16
    22fa:	1f 93       	push	r17
    22fc:	cf 93       	push	r28
    22fe:	df 93       	push	r29
    2300:	1c 01       	movw	r2, r24
    2302:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <xTaskGetTickCount>
    2306:	2b 01       	movw	r4, r22
    2308:	3c 01       	movw	r6, r24
    230a:	80 91 6e 2c 	lds	r24, 0x2C6E	; 0x802c6e <xLastTime.4746>
    230e:	90 91 6f 2c 	lds	r25, 0x2C6F	; 0x802c6f <xLastTime.4746+0x1>
    2312:	a0 91 70 2c 	lds	r26, 0x2C70	; 0x802c70 <xLastTime.4746+0x2>
    2316:	b0 91 71 2c 	lds	r27, 0x2C71	; 0x802c71 <xLastTime.4746+0x3>
    231a:	48 16       	cp	r4, r24
    231c:	59 06       	cpc	r5, r25
    231e:	6a 06       	cpc	r6, r26
    2320:	7b 06       	cpc	r7, r27
    2322:	08 f0       	brcs	.+2      	; 0x2326 <prvSampleTimeNow+0x4a>
    2324:	54 c0       	rjmp	.+168    	; 0x23ce <prvSampleTimeNow+0xf2>
    2326:	3c c0       	rjmp	.+120    	; 0x23a0 <prvSampleTimeNow+0xc4>
    2328:	07 80       	ldd	r0, Z+7	; 0x07
    232a:	f0 85       	ldd	r31, Z+8	; 0x08
    232c:	e0 2d       	mov	r30, r0
    232e:	80 80       	ld	r8, Z
    2330:	91 80       	ldd	r9, Z+1	; 0x01
    2332:	a2 80       	ldd	r10, Z+2	; 0x02
    2334:	b3 80       	ldd	r11, Z+3	; 0x03
    2336:	c0 85       	ldd	r28, Z+8	; 0x08
    2338:	d1 85       	ldd	r29, Z+9	; 0x09
    233a:	8e 01       	movw	r16, r28
    233c:	0e 5f       	subi	r16, 0xFE	; 254
    233e:	1f 4f       	sbci	r17, 0xFF	; 255
    2340:	c8 01       	movw	r24, r16
    2342:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    2346:	ed 89       	ldd	r30, Y+21	; 0x15
    2348:	fe 89       	ldd	r31, Y+22	; 0x16
    234a:	ce 01       	movw	r24, r28
    234c:	19 95       	eicall
    234e:	8a 89       	ldd	r24, Y+18	; 0x12
    2350:	81 30       	cpi	r24, 0x01	; 1
    2352:	31 f5       	brne	.+76     	; 0x23a0 <prvSampleTimeNow+0xc4>
    2354:	8e 85       	ldd	r24, Y+14	; 0x0e
    2356:	9f 85       	ldd	r25, Y+15	; 0x0f
    2358:	a8 89       	ldd	r26, Y+16	; 0x10
    235a:	b9 89       	ldd	r27, Y+17	; 0x11
    235c:	88 0d       	add	r24, r8
    235e:	99 1d       	adc	r25, r9
    2360:	aa 1d       	adc	r26, r10
    2362:	bb 1d       	adc	r27, r11
    2364:	88 16       	cp	r8, r24
    2366:	99 06       	cpc	r9, r25
    2368:	aa 06       	cpc	r10, r26
    236a:	bb 06       	cpc	r11, r27
    236c:	70 f4       	brcc	.+28     	; 0x238a <prvSampleTimeNow+0xae>
    236e:	8a 83       	std	Y+2, r24	; 0x02
    2370:	9b 83       	std	Y+3, r25	; 0x03
    2372:	ac 83       	std	Y+4, r26	; 0x04
    2374:	bd 83       	std	Y+5, r27	; 0x05
    2376:	ca 87       	std	Y+10, r28	; 0x0a
    2378:	db 87       	std	Y+11, r29	; 0x0b
    237a:	b8 01       	movw	r22, r16
    237c:	80 91 78 2c 	lds	r24, 0x2C78	; 0x802c78 <pxCurrentTimerList>
    2380:	90 91 79 2c 	lds	r25, 0x2C79	; 0x802c79 <pxCurrentTimerList+0x1>
    2384:	0e 94 ac 03 	call	0x758	; 0x758 <vListInsert>
    2388:	0b c0       	rjmp	.+22     	; 0x23a0 <prvSampleTimeNow+0xc4>
    238a:	c1 2c       	mov	r12, r1
    238c:	d1 2c       	mov	r13, r1
    238e:	76 01       	movw	r14, r12
    2390:	00 e0       	ldi	r16, 0x00	; 0
    2392:	10 e0       	ldi	r17, 0x00	; 0
    2394:	a5 01       	movw	r20, r10
    2396:	94 01       	movw	r18, r8
    2398:	60 e0       	ldi	r22, 0x00	; 0
    239a:	ce 01       	movw	r24, r28
    239c:	0e 94 15 11 	call	0x222a	; 0x222a <xTimerGenericCommand>
    23a0:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTimerList>
    23a4:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTimerList+0x1>
    23a8:	80 81       	ld	r24, Z
    23aa:	81 11       	cpse	r24, r1
    23ac:	bd cf       	rjmp	.-134    	; 0x2328 <prvSampleTimeNow+0x4c>
    23ae:	80 91 76 2c 	lds	r24, 0x2C76	; 0x802c76 <pxOverflowTimerList>
    23b2:	90 91 77 2c 	lds	r25, 0x2C77	; 0x802c77 <pxOverflowTimerList+0x1>
    23b6:	80 93 78 2c 	sts	0x2C78, r24	; 0x802c78 <pxCurrentTimerList>
    23ba:	90 93 79 2c 	sts	0x2C79, r25	; 0x802c79 <pxCurrentTimerList+0x1>
    23be:	e0 93 76 2c 	sts	0x2C76, r30	; 0x802c76 <pxOverflowTimerList>
    23c2:	f0 93 77 2c 	sts	0x2C77, r31	; 0x802c77 <pxOverflowTimerList+0x1>
    23c6:	81 e0       	ldi	r24, 0x01	; 1
    23c8:	f1 01       	movw	r30, r2
    23ca:	80 83       	st	Z, r24
    23cc:	02 c0       	rjmp	.+4      	; 0x23d2 <prvSampleTimeNow+0xf6>
    23ce:	f1 01       	movw	r30, r2
    23d0:	10 82       	st	Z, r1
    23d2:	40 92 6e 2c 	sts	0x2C6E, r4	; 0x802c6e <xLastTime.4746>
    23d6:	50 92 6f 2c 	sts	0x2C6F, r5	; 0x802c6f <xLastTime.4746+0x1>
    23da:	60 92 70 2c 	sts	0x2C70, r6	; 0x802c70 <xLastTime.4746+0x2>
    23de:	70 92 71 2c 	sts	0x2C71, r7	; 0x802c71 <xLastTime.4746+0x3>
    23e2:	c3 01       	movw	r24, r6
    23e4:	b2 01       	movw	r22, r4
    23e6:	df 91       	pop	r29
    23e8:	cf 91       	pop	r28
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	df 90       	pop	r13
    23f4:	cf 90       	pop	r12
    23f6:	bf 90       	pop	r11
    23f8:	af 90       	pop	r10
    23fa:	9f 90       	pop	r9
    23fc:	8f 90       	pop	r8
    23fe:	7f 90       	pop	r7
    2400:	6f 90       	pop	r6
    2402:	5f 90       	pop	r5
    2404:	4f 90       	pop	r4
    2406:	3f 90       	pop	r3
    2408:	2f 90       	pop	r2
    240a:	08 95       	ret

0000240c <prvTimerTask>:
    240c:	cf 93       	push	r28
    240e:	df 93       	push	r29
    2410:	cd b7       	in	r28, 0x3d	; 61
    2412:	de b7       	in	r29, 0x3e	; 62
    2414:	2e 97       	sbiw	r28, 0x0e	; 14
    2416:	cd bf       	out	0x3d, r28	; 61
    2418:	de bf       	out	0x3e, r29	; 62
    241a:	ce 01       	movw	r24, r28
    241c:	01 96       	adiw	r24, 0x01	; 1
    241e:	1c 01       	movw	r2, r24
    2420:	a8 2e       	mov	r10, r24
    2422:	b3 2c       	mov	r11, r3
    2424:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTimerList>
    2428:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTimerList+0x1>
    242c:	80 81       	ld	r24, Z
    242e:	88 23       	and	r24, r24
    2430:	09 f4       	brne	.+2      	; 0x2434 <prvTimerTask+0x28>
    2432:	03 c1       	rjmp	.+518    	; 0x263a <prvTimerTask+0x22e>
    2434:	07 80       	ldd	r0, Z+7	; 0x07
    2436:	f0 85       	ldd	r31, Z+8	; 0x08
    2438:	e0 2d       	mov	r30, r0
    243a:	40 80       	ld	r4, Z
    243c:	51 80       	ldd	r5, Z+1	; 0x01
    243e:	62 80       	ldd	r6, Z+2	; 0x02
    2440:	73 80       	ldd	r7, Z+3	; 0x03
    2442:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
    2446:	c1 01       	movw	r24, r2
    2448:	0e 94 6e 11 	call	0x22dc	; 0x22dc <prvSampleTimeNow>
    244c:	6b 87       	std	Y+11, r22	; 0x0b
    244e:	7c 87       	std	Y+12, r23	; 0x0c
    2450:	8d 87       	std	Y+13, r24	; 0x0d
    2452:	9e 87       	std	Y+14, r25	; 0x0e
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	81 11       	cpse	r24, r1
    2458:	5e c0       	rjmp	.+188    	; 0x2516 <prvTimerTask+0x10a>
    245a:	8b 85       	ldd	r24, Y+11	; 0x0b
    245c:	9c 85       	ldd	r25, Y+12	; 0x0c
    245e:	ad 85       	ldd	r26, Y+13	; 0x0d
    2460:	be 85       	ldd	r27, Y+14	; 0x0e
    2462:	84 15       	cp	r24, r4
    2464:	95 05       	cpc	r25, r5
    2466:	a6 05       	cpc	r26, r6
    2468:	b7 05       	cpc	r27, r7
    246a:	e8 f1       	brcs	.+122    	; 0x24e6 <prvTimerTask+0xda>
    246c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    2470:	e0 91 78 2c 	lds	r30, 0x2C78	; 0x802c78 <pxCurrentTimerList>
    2474:	f0 91 79 2c 	lds	r31, 0x2C79	; 0x802c79 <pxCurrentTimerList+0x1>
    2478:	07 80       	ldd	r0, Z+7	; 0x07
    247a:	f0 85       	ldd	r31, Z+8	; 0x08
    247c:	e0 2d       	mov	r30, r0
    247e:	80 84       	ldd	r8, Z+8	; 0x08
    2480:	91 84       	ldd	r9, Z+9	; 0x09
    2482:	c4 01       	movw	r24, r8
    2484:	02 96       	adiw	r24, 0x02	; 2
    2486:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    248a:	d4 01       	movw	r26, r8
    248c:	52 96       	adiw	r26, 0x12	; 18
    248e:	8c 91       	ld	r24, X
    2490:	52 97       	sbiw	r26, 0x12	; 18
    2492:	81 30       	cpi	r24, 0x01	; 1
    2494:	01 f5       	brne	.+64     	; 0x24d6 <prvTimerTask+0xca>
    2496:	1e 96       	adiw	r26, 0x0e	; 14
    2498:	4d 91       	ld	r20, X+
    249a:	5d 91       	ld	r21, X+
    249c:	6d 91       	ld	r22, X+
    249e:	7c 91       	ld	r23, X
    24a0:	51 97       	sbiw	r26, 0x11	; 17
    24a2:	44 0d       	add	r20, r4
    24a4:	55 1d       	adc	r21, r5
    24a6:	66 1d       	adc	r22, r6
    24a8:	77 1d       	adc	r23, r7
    24aa:	73 01       	movw	r14, r6
    24ac:	62 01       	movw	r12, r4
    24ae:	0b 85       	ldd	r16, Y+11	; 0x0b
    24b0:	1c 85       	ldd	r17, Y+12	; 0x0c
    24b2:	2d 85       	ldd	r18, Y+13	; 0x0d
    24b4:	3e 85       	ldd	r19, Y+14	; 0x0e
    24b6:	c4 01       	movw	r24, r8
    24b8:	0e 94 7d 10 	call	0x20fa	; 0x20fa <prvInsertTimerInActiveList>
    24bc:	88 23       	and	r24, r24
    24be:	59 f0       	breq	.+22     	; 0x24d6 <prvTimerTask+0xca>
    24c0:	c1 2c       	mov	r12, r1
    24c2:	d1 2c       	mov	r13, r1
    24c4:	76 01       	movw	r14, r12
    24c6:	00 e0       	ldi	r16, 0x00	; 0
    24c8:	10 e0       	ldi	r17, 0x00	; 0
    24ca:	a3 01       	movw	r20, r6
    24cc:	92 01       	movw	r18, r4
    24ce:	60 e0       	ldi	r22, 0x00	; 0
    24d0:	c4 01       	movw	r24, r8
    24d2:	0e 94 15 11 	call	0x222a	; 0x222a <xTimerGenericCommand>
    24d6:	d4 01       	movw	r26, r8
    24d8:	55 96       	adiw	r26, 0x15	; 21
    24da:	ed 91       	ld	r30, X+
    24dc:	fc 91       	ld	r31, X
    24de:	56 97       	sbiw	r26, 0x16	; 22
    24e0:	c4 01       	movw	r24, r8
    24e2:	19 95       	eicall
    24e4:	9c c0       	rjmp	.+312    	; 0x261e <prvTimerTask+0x212>
    24e6:	20 e0       	ldi	r18, 0x00	; 0
    24e8:	b3 01       	movw	r22, r6
    24ea:	a2 01       	movw	r20, r4
    24ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    24ee:	9c 85       	ldd	r25, Y+12	; 0x0c
    24f0:	ad 85       	ldd	r26, Y+13	; 0x0d
    24f2:	be 85       	ldd	r27, Y+14	; 0x0e
    24f4:	48 1b       	sub	r20, r24
    24f6:	59 0b       	sbc	r21, r25
    24f8:	6a 0b       	sbc	r22, r26
    24fa:	7b 0b       	sbc	r23, r27
    24fc:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    2500:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    2504:	0e 94 bf 09 	call	0x137e	; 0x137e <vQueueWaitForMessageRestricted>
    2508:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    250c:	81 11       	cpse	r24, r1
    250e:	87 c0       	rjmp	.+270    	; 0x261e <prvTimerTask+0x212>
    2510:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <vPortYield>
    2514:	84 c0       	rjmp	.+264    	; 0x261e <prvTimerTask+0x212>
    2516:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
    251a:	81 c0       	rjmp	.+258    	; 0x261e <prvTimerTask+0x212>
    251c:	89 81       	ldd	r24, Y+1	; 0x01
    251e:	88 23       	and	r24, r24
    2520:	6c f4       	brge	.+26     	; 0x253c <prvTimerTask+0x130>
    2522:	4e 81       	ldd	r20, Y+6	; 0x06
    2524:	5f 81       	ldd	r21, Y+7	; 0x07
    2526:	68 85       	ldd	r22, Y+8	; 0x08
    2528:	79 85       	ldd	r23, Y+9	; 0x09
    252a:	ea 81       	ldd	r30, Y+2	; 0x02
    252c:	fb 81       	ldd	r31, Y+3	; 0x03
    252e:	8c 81       	ldd	r24, Y+4	; 0x04
    2530:	9d 81       	ldd	r25, Y+5	; 0x05
    2532:	19 95       	eicall
    2534:	89 81       	ldd	r24, Y+1	; 0x01
    2536:	88 23       	and	r24, r24
    2538:	0c f4       	brge	.+2      	; 0x253c <prvTimerTask+0x130>
    253a:	71 c0       	rjmp	.+226    	; 0x261e <prvTimerTask+0x212>
    253c:	8e 80       	ldd	r8, Y+6	; 0x06
    253e:	9f 80       	ldd	r9, Y+7	; 0x07
    2540:	d4 01       	movw	r26, r8
    2542:	1c 96       	adiw	r26, 0x0c	; 12
    2544:	8d 91       	ld	r24, X+
    2546:	9c 91       	ld	r25, X
    2548:	1d 97       	sbiw	r26, 0x0d	; 13
    254a:	89 2b       	or	r24, r25
    254c:	21 f0       	breq	.+8      	; 0x2556 <prvTimerTask+0x14a>
    254e:	c4 01       	movw	r24, r8
    2550:	02 96       	adiw	r24, 0x02	; 2
    2552:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <uxListRemove>
    2556:	ce 01       	movw	r24, r28
    2558:	0a 96       	adiw	r24, 0x0a	; 10
    255a:	0e 94 6e 11 	call	0x22dc	; 0x22dc <prvSampleTimeNow>
    255e:	8b 01       	movw	r16, r22
    2560:	9c 01       	movw	r18, r24
    2562:	89 81       	ldd	r24, Y+1	; 0x01
    2564:	08 2e       	mov	r0, r24
    2566:	00 0c       	add	r0, r0
    2568:	99 0b       	sbc	r25, r25
    256a:	aa 0b       	sbc	r26, r26
    256c:	bb 0b       	sbc	r27, r27
    256e:	8a 30       	cpi	r24, 0x0A	; 10
    2570:	91 05       	cpc	r25, r1
    2572:	08 f0       	brcs	.+2      	; 0x2576 <prvTimerTask+0x16a>
    2574:	54 c0       	rjmp	.+168    	; 0x261e <prvTimerTask+0x212>
    2576:	fc 01       	movw	r30, r24
    2578:	88 27       	eor	r24, r24
    257a:	e2 50       	subi	r30, 0x02	; 2
    257c:	ff 4f       	sbci	r31, 0xFF	; 255
    257e:	8f 4f       	sbci	r24, 0xFF	; 255
    2580:	0c 94 6e 1e 	jmp	0x3cdc	; 0x3cdc <__tablejump2__>
    2584:	ca 80       	ldd	r12, Y+2	; 0x02
    2586:	db 80       	ldd	r13, Y+3	; 0x03
    2588:	ec 80       	ldd	r14, Y+4	; 0x04
    258a:	fd 80       	ldd	r15, Y+5	; 0x05
    258c:	f4 01       	movw	r30, r8
    258e:	46 85       	ldd	r20, Z+14	; 0x0e
    2590:	57 85       	ldd	r21, Z+15	; 0x0f
    2592:	60 89       	ldd	r22, Z+16	; 0x10
    2594:	71 89       	ldd	r23, Z+17	; 0x11
    2596:	4c 0d       	add	r20, r12
    2598:	5d 1d       	adc	r21, r13
    259a:	6e 1d       	adc	r22, r14
    259c:	7f 1d       	adc	r23, r15
    259e:	c4 01       	movw	r24, r8
    25a0:	0e 94 7d 10 	call	0x20fa	; 0x20fa <prvInsertTimerInActiveList>
    25a4:	88 23       	and	r24, r24
    25a6:	d9 f1       	breq	.+118    	; 0x261e <prvTimerTask+0x212>
    25a8:	d4 01       	movw	r26, r8
    25aa:	55 96       	adiw	r26, 0x15	; 21
    25ac:	ed 91       	ld	r30, X+
    25ae:	fc 91       	ld	r31, X
    25b0:	56 97       	sbiw	r26, 0x16	; 22
    25b2:	c4 01       	movw	r24, r8
    25b4:	19 95       	eicall
    25b6:	f4 01       	movw	r30, r8
    25b8:	82 89       	ldd	r24, Z+18	; 0x12
    25ba:	81 30       	cpi	r24, 0x01	; 1
    25bc:	81 f5       	brne	.+96     	; 0x261e <prvTimerTask+0x212>
    25be:	4a 81       	ldd	r20, Y+2	; 0x02
    25c0:	5b 81       	ldd	r21, Y+3	; 0x03
    25c2:	6c 81       	ldd	r22, Y+4	; 0x04
    25c4:	7d 81       	ldd	r23, Y+5	; 0x05
    25c6:	86 85       	ldd	r24, Z+14	; 0x0e
    25c8:	97 85       	ldd	r25, Z+15	; 0x0f
    25ca:	a0 89       	ldd	r26, Z+16	; 0x10
    25cc:	b1 89       	ldd	r27, Z+17	; 0x11
    25ce:	9a 01       	movw	r18, r20
    25d0:	ab 01       	movw	r20, r22
    25d2:	28 0f       	add	r18, r24
    25d4:	39 1f       	adc	r19, r25
    25d6:	4a 1f       	adc	r20, r26
    25d8:	5b 1f       	adc	r21, r27
    25da:	c1 2c       	mov	r12, r1
    25dc:	d1 2c       	mov	r13, r1
    25de:	76 01       	movw	r14, r12
    25e0:	00 e0       	ldi	r16, 0x00	; 0
    25e2:	10 e0       	ldi	r17, 0x00	; 0
    25e4:	60 e0       	ldi	r22, 0x00	; 0
    25e6:	c4 01       	movw	r24, r8
    25e8:	0e 94 15 11 	call	0x222a	; 0x222a <xTimerGenericCommand>
    25ec:	18 c0       	rjmp	.+48     	; 0x261e <prvTimerTask+0x212>
    25ee:	4a 81       	ldd	r20, Y+2	; 0x02
    25f0:	5b 81       	ldd	r21, Y+3	; 0x03
    25f2:	6c 81       	ldd	r22, Y+4	; 0x04
    25f4:	7d 81       	ldd	r23, Y+5	; 0x05
    25f6:	d4 01       	movw	r26, r8
    25f8:	1e 96       	adiw	r26, 0x0e	; 14
    25fa:	4d 93       	st	X+, r20
    25fc:	5d 93       	st	X+, r21
    25fe:	6d 93       	st	X+, r22
    2600:	7c 93       	st	X, r23
    2602:	51 97       	sbiw	r26, 0x11	; 17
    2604:	40 0f       	add	r20, r16
    2606:	51 1f       	adc	r21, r17
    2608:	62 1f       	adc	r22, r18
    260a:	73 1f       	adc	r23, r19
    260c:	68 01       	movw	r12, r16
    260e:	79 01       	movw	r14, r18
    2610:	c4 01       	movw	r24, r8
    2612:	0e 94 7d 10 	call	0x20fa	; 0x20fa <prvInsertTimerInActiveList>
    2616:	03 c0       	rjmp	.+6      	; 0x261e <prvTimerTask+0x212>
    2618:	c4 01       	movw	r24, r8
    261a:	0e 94 75 03 	call	0x6ea	; 0x6ea <vPortFree>
    261e:	20 e0       	ldi	r18, 0x00	; 0
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	a9 01       	movw	r20, r18
    2624:	6a 2d       	mov	r22, r10
    2626:	7b 2d       	mov	r23, r11
    2628:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    262c:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    2630:	0e 94 28 08 	call	0x1050	; 0x1050 <xQueueReceive>
    2634:	81 11       	cpse	r24, r1
    2636:	72 cf       	rjmp	.-284    	; 0x251c <prvTimerTask+0x110>
    2638:	f5 ce       	rjmp	.-534    	; 0x2424 <prvTimerTask+0x18>
    263a:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <vTaskSuspendAll>
    263e:	c1 01       	movw	r24, r2
    2640:	0e 94 6e 11 	call	0x22dc	; 0x22dc <prvSampleTimeNow>
    2644:	6b 87       	std	Y+11, r22	; 0x0b
    2646:	7c 87       	std	Y+12, r23	; 0x0c
    2648:	8d 87       	std	Y+13, r24	; 0x0d
    264a:	9e 87       	std	Y+14, r25	; 0x0e
    264c:	89 81       	ldd	r24, Y+1	; 0x01
    264e:	81 11       	cpse	r24, r1
    2650:	62 cf       	rjmp	.-316    	; 0x2516 <prvTimerTask+0x10a>
    2652:	e0 91 76 2c 	lds	r30, 0x2C76	; 0x802c76 <pxOverflowTimerList>
    2656:	f0 91 77 2c 	lds	r31, 0x2C77	; 0x802c77 <pxOverflowTimerList+0x1>
    265a:	80 81       	ld	r24, Z
    265c:	21 e0       	ldi	r18, 0x01	; 1
    265e:	81 11       	cpse	r24, r1
    2660:	20 e0       	ldi	r18, 0x00	; 0
    2662:	41 2c       	mov	r4, r1
    2664:	51 2c       	mov	r5, r1
    2666:	32 01       	movw	r6, r4
    2668:	3f cf       	rjmp	.-386    	; 0x24e8 <prvTimerTask+0xdc>

0000266a <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    266a:	0f 93       	push	r16
    266c:	1f 93       	push	r17
    266e:	cf 93       	push	r28
    2670:	df 93       	push	r29
    2672:	cd b7       	in	r28, 0x3d	; 61
    2674:	de b7       	in	r29, 0x3e	; 62
    2676:	29 97       	sbiw	r28, 0x09	; 9
    2678:	cd bf       	out	0x3d, r28	; 61
    267a:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    267c:	ee ef       	ldi	r30, 0xFE	; 254
    267e:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2680:	8a 83       	std	Y+2, r24	; 0x02
    2682:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2684:	6c 83       	std	Y+4, r22	; 0x04
    2686:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2688:	2e 83       	std	Y+6, r18	; 0x06
    268a:	3f 83       	std	Y+7, r19	; 0x07
    268c:	48 87       	std	Y+8, r20	; 0x08
    268e:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2690:	20 e0       	ldi	r18, 0x00	; 0
    2692:	a8 01       	movw	r20, r16
    2694:	be 01       	movw	r22, r28
    2696:	6f 5f       	subi	r22, 0xFF	; 255
    2698:	7f 4f       	sbci	r23, 0xFF	; 255
    269a:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <xTimerQueue>
    269e:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <xTimerQueue+0x1>
    26a2:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    26a6:	29 96       	adiw	r28, 0x09	; 9
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	de bf       	out	0x3e, r29	; 62
    26ac:	df 91       	pop	r29
    26ae:	cf 91       	pop	r28
    26b0:	1f 91       	pop	r17
    26b2:	0f 91       	pop	r16
    26b4:	08 95       	ret

000026b6 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    26b6:	e0 e5       	ldi	r30, 0x50	; 80
    26b8:	f0 e0       	ldi	r31, 0x00	; 0
    26ba:	80 81       	ld	r24, Z
    26bc:	81 60       	ori	r24, 0x01	; 1
    26be:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    26c0:	81 81       	ldd	r24, Z+1	; 0x01
    26c2:	80 ff       	sbrs	r24, 0
    26c4:	fd cf       	rjmp	.-6      	; 0x26c0 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	0e 94 81 01 	call	0x302	; 0x302 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    26cc:	8e e1       	ldi	r24, 0x1E	; 30
    26ce:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	80 e0       	ldi	r24, 0x00	; 0
    26d6:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    26da:	43 e0       	ldi	r20, 0x03	; 3
    26dc:	60 e0       	ldi	r22, 0x00	; 0
    26de:	80 e4       	ldi	r24, 0x40	; 64
    26e0:	0e 94 62 01 	call	0x2c4	; 0x2c4 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    26e4:	e0 e5       	ldi	r30, 0x50	; 80
    26e6:	f0 e0       	ldi	r31, 0x00	; 0
    26e8:	80 81       	ld	r24, Z
    26ea:	88 60       	ori	r24, 0x08	; 8
    26ec:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    26ee:	81 81       	ldd	r24, Z+1	; 0x01
    26f0:	83 ff       	sbrs	r24, 3
    26f2:	fd cf       	rjmp	.-6      	; 0x26ee <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    26f4:	64 e0       	ldi	r22, 0x04	; 4
    26f6:	80 ec       	ldi	r24, 0xC0	; 192
    26f8:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    26fc:	e0 e5       	ldi	r30, 0x50	; 80
    26fe:	f0 e0       	ldi	r31, 0x00	; 0
    2700:	80 81       	ld	r24, Z
    2702:	80 61       	ori	r24, 0x10	; 16
    2704:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2706:	60 e0       	ldi	r22, 0x00	; 0
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    270e:	e0 e5       	ldi	r30, 0x50	; 80
    2710:	f0 e0       	ldi	r31, 0x00	; 0
    2712:	81 81       	ldd	r24, Z+1	; 0x01
    2714:	84 ff       	sbrs	r24, 4
    2716:	fd cf       	rjmp	.-6      	; 0x2712 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    2718:	84 e0       	ldi	r24, 0x04	; 4
    271a:	0e 94 81 01 	call	0x302	; 0x302 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    271e:	87 e0       	ldi	r24, 0x07	; 7
    2720:	0e 94 71 01 	call	0x2e2	; 0x2e2 <CLKSYS_Disable>
    2724:	08 95       	ret

00002726 <vDisplayTask>:
	vDisplayClear();
	vTaskStartScheduler();
	return 0;
}

void vDisplayTask(void *pvParameters) {
    2726:	cf 93       	push	r28
    2728:	df 93       	push	r29
    272a:	00 d0       	rcall	.+0      	; 0x272c <vDisplayTask+0x6>
    272c:	1f 92       	push	r1
    272e:	cd b7       	in	r28, 0x3d	; 61
    2730:	de b7       	in	r29, 0x3e	; 62
	uint32_t b1 = 0, b2 = 0, b3 = 0, b4 = 0;
    2732:	41 2c       	mov	r4, r1
    2734:	51 2c       	mov	r5, r1
    2736:	32 01       	movw	r6, r4
    2738:	81 2c       	mov	r8, r1
    273a:	91 2c       	mov	r9, r1
    273c:	54 01       	movw	r10, r8
    273e:	c1 2c       	mov	r12, r1
    2740:	d1 2c       	mov	r13, r1
    2742:	76 01       	movw	r14, r12
    2744:	19 82       	std	Y+1, r1	; 0x01
    2746:	1a 82       	std	Y+2, r1	; 0x02
    2748:	1b 82       	std	Y+3, r1	; 0x03
    274a:	1c 82       	std	Y+4, r1	; 0x04
				}
				buttonData = 0;
				xSemaphoreGive(buttondataKey); //Unlock A-Resource
			}
		}
		vDisplayWriteStringAtPos(0,0,"B1: %d", b1);
    274c:	0f 2e       	mov	r0, r31
    274e:	fd e0       	ldi	r31, 0x0D	; 13
    2750:	2f 2e       	mov	r2, r31
    2752:	f0 e2       	ldi	r31, 0x20	; 32
    2754:	3f 2e       	mov	r3, r31
    2756:	f0 2d       	mov	r31, r0
		vDisplayWriteStringAtPos(1,0,"B2: %d", b2);
    2758:	11 e0       	ldi	r17, 0x01	; 1
}

void vDisplayTask(void *pvParameters) {
	uint32_t b1 = 0, b2 = 0, b3 = 0, b4 = 0;
	for(;;) {
		if(xSemaphoreTake(buttonUpdate, 100/portTICK_RATE_MS)) { //Wait for Button-Press
    275a:	44 e6       	ldi	r20, 0x64	; 100
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	60 e0       	ldi	r22, 0x00	; 0
    2760:	70 e0       	ldi	r23, 0x00	; 0
    2762:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <buttonUpdate>
    2766:	90 91 be 2c 	lds	r25, 0x2CBE	; 0x802cbe <buttonUpdate+0x1>
    276a:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    276e:	88 23       	and	r24, r24
    2770:	09 f4       	brne	.+2      	; 0x2774 <vDisplayTask+0x4e>
    2772:	5a c0       	rjmp	.+180    	; 0x2828 <vDisplayTask+0x102>
			if(xSemaphoreTake(buttondataKey, portMAX_DELAY)) { //Lock A-Resource to get access to P-Resource
    2774:	4f ef       	ldi	r20, 0xFF	; 255
    2776:	5f ef       	ldi	r21, 0xFF	; 255
    2778:	ba 01       	movw	r22, r20
    277a:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    277e:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2782:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    2786:	88 23       	and	r24, r24
    2788:	09 f4       	brne	.+2      	; 0x278c <vDisplayTask+0x66>
    278a:	4e c0       	rjmp	.+156    	; 0x2828 <vDisplayTask+0x102>
				switch(buttonData) {
    278c:	80 91 90 2c 	lds	r24, 0x2C90	; 0x802c90 <buttonData>
    2790:	90 91 91 2c 	lds	r25, 0x2C91	; 0x802c91 <buttonData+0x1>
    2794:	a0 91 92 2c 	lds	r26, 0x2C92	; 0x802c92 <buttonData+0x2>
    2798:	b0 91 93 2c 	lds	r27, 0x2C93	; 0x802c93 <buttonData+0x3>
    279c:	82 30       	cpi	r24, 0x02	; 2
    279e:	91 05       	cpc	r25, r1
    27a0:	a1 05       	cpc	r26, r1
    27a2:	b1 05       	cpc	r27, r1
    27a4:	e1 f0       	breq	.+56     	; 0x27de <vDisplayTask+0xb8>
    27a6:	28 f4       	brcc	.+10     	; 0x27b2 <vDisplayTask+0x8c>
    27a8:	01 97       	sbiw	r24, 0x01	; 1
    27aa:	a1 05       	cpc	r26, r1
    27ac:	b1 05       	cpc	r27, r1
    27ae:	59 f0       	breq	.+22     	; 0x27c6 <vDisplayTask+0xa0>
    27b0:	27 c0       	rjmp	.+78     	; 0x2800 <vDisplayTask+0xda>
    27b2:	83 30       	cpi	r24, 0x03	; 3
    27b4:	91 05       	cpc	r25, r1
    27b6:	a1 05       	cpc	r26, r1
    27b8:	b1 05       	cpc	r27, r1
    27ba:	b9 f0       	breq	.+46     	; 0x27ea <vDisplayTask+0xc4>
    27bc:	04 97       	sbiw	r24, 0x04	; 4
    27be:	a1 05       	cpc	r26, r1
    27c0:	b1 05       	cpc	r27, r1
    27c2:	c9 f0       	breq	.+50     	; 0x27f6 <vDisplayTask+0xd0>
    27c4:	1d c0       	rjmp	.+58     	; 0x2800 <vDisplayTask+0xda>
					case 1:
						b1++;
    27c6:	89 81       	ldd	r24, Y+1	; 0x01
    27c8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ca:	ab 81       	ldd	r26, Y+3	; 0x03
    27cc:	bc 81       	ldd	r27, Y+4	; 0x04
    27ce:	01 96       	adiw	r24, 0x01	; 1
    27d0:	a1 1d       	adc	r26, r1
    27d2:	b1 1d       	adc	r27, r1
    27d4:	89 83       	std	Y+1, r24	; 0x01
    27d6:	9a 83       	std	Y+2, r25	; 0x02
    27d8:	ab 83       	std	Y+3, r26	; 0x03
    27da:	bc 83       	std	Y+4, r27	; 0x04
					break;
    27dc:	11 c0       	rjmp	.+34     	; 0x2800 <vDisplayTask+0xda>
					case 2:
						b2++;
    27de:	9f ef       	ldi	r25, 0xFF	; 255
    27e0:	c9 1a       	sub	r12, r25
    27e2:	d9 0a       	sbc	r13, r25
    27e4:	e9 0a       	sbc	r14, r25
    27e6:	f9 0a       	sbc	r15, r25
					break;
    27e8:	0b c0       	rjmp	.+22     	; 0x2800 <vDisplayTask+0xda>
					case 3:
						b3++;
    27ea:	af ef       	ldi	r26, 0xFF	; 255
    27ec:	8a 1a       	sub	r8, r26
    27ee:	9a 0a       	sbc	r9, r26
    27f0:	aa 0a       	sbc	r10, r26
    27f2:	ba 0a       	sbc	r11, r26
					break;
    27f4:	05 c0       	rjmp	.+10     	; 0x2800 <vDisplayTask+0xda>
					case 4:
						b4++;
    27f6:	bf ef       	ldi	r27, 0xFF	; 255
    27f8:	4b 1a       	sub	r4, r27
    27fa:	5b 0a       	sbc	r5, r27
    27fc:	6b 0a       	sbc	r6, r27
    27fe:	7b 0a       	sbc	r7, r27
					break;
				}
				buttonData = 0;
    2800:	10 92 90 2c 	sts	0x2C90, r1	; 0x802c90 <buttonData>
    2804:	10 92 91 2c 	sts	0x2C91, r1	; 0x802c91 <buttonData+0x1>
    2808:	10 92 92 2c 	sts	0x2C92, r1	; 0x802c92 <buttonData+0x2>
    280c:	10 92 93 2c 	sts	0x2C93, r1	; 0x802c93 <buttonData+0x3>
				xSemaphoreGive(buttondataKey); //Unlock A-Resource
    2810:	00 e0       	ldi	r16, 0x00	; 0
    2812:	20 e0       	ldi	r18, 0x00	; 0
    2814:	30 e0       	ldi	r19, 0x00	; 0
    2816:	a9 01       	movw	r20, r18
    2818:	60 e0       	ldi	r22, 0x00	; 0
    281a:	70 e0       	ldi	r23, 0x00	; 0
    281c:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2820:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2824:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
			}
		}
		vDisplayWriteStringAtPos(0,0,"B1: %d", b1);
    2828:	2c 81       	ldd	r18, Y+4	; 0x04
    282a:	2f 93       	push	r18
    282c:	8b 81       	ldd	r24, Y+3	; 0x03
    282e:	8f 93       	push	r24
    2830:	9a 81       	ldd	r25, Y+2	; 0x02
    2832:	9f 93       	push	r25
    2834:	a9 81       	ldd	r26, Y+1	; 0x01
    2836:	af 93       	push	r26
    2838:	3f 92       	push	r3
    283a:	2f 92       	push	r2
    283c:	1f 92       	push	r1
    283e:	1f 92       	push	r1
    2840:	1f 92       	push	r1
    2842:	1f 92       	push	r1
    2844:	0e 94 67 18 	call	0x30ce	; 0x30ce <vDisplayWriteStringAtPos>
		vDisplayWriteStringAtPos(1,0,"B2: %d", b2);
    2848:	ff 92       	push	r15
    284a:	ef 92       	push	r14
    284c:	df 92       	push	r13
    284e:	cf 92       	push	r12
    2850:	84 e1       	ldi	r24, 0x14	; 20
    2852:	90 e2       	ldi	r25, 0x20	; 32
    2854:	9f 93       	push	r25
    2856:	8f 93       	push	r24
    2858:	1f 92       	push	r1
    285a:	1f 92       	push	r1
    285c:	1f 92       	push	r1
    285e:	1f 93       	push	r17
    2860:	0e 94 67 18 	call	0x30ce	; 0x30ce <vDisplayWriteStringAtPos>
		vDisplayWriteStringAtPos(2,0,"B3: %d", b3);
    2864:	bf 92       	push	r11
    2866:	af 92       	push	r10
    2868:	9f 92       	push	r9
    286a:	8f 92       	push	r8
    286c:	8b e1       	ldi	r24, 0x1B	; 27
    286e:	90 e2       	ldi	r25, 0x20	; 32
    2870:	9f 93       	push	r25
    2872:	8f 93       	push	r24
    2874:	1f 92       	push	r1
    2876:	1f 92       	push	r1
    2878:	1f 92       	push	r1
    287a:	b2 e0       	ldi	r27, 0x02	; 2
    287c:	bf 93       	push	r27
    287e:	0e 94 67 18 	call	0x30ce	; 0x30ce <vDisplayWriteStringAtPos>
		vDisplayWriteStringAtPos(3,0,"B4: %d", b4);
    2882:	7f 92       	push	r7
    2884:	6f 92       	push	r6
    2886:	5f 92       	push	r5
    2888:	4f 92       	push	r4
    288a:	82 e2       	ldi	r24, 0x22	; 34
    288c:	90 e2       	ldi	r25, 0x20	; 32
    288e:	9f 93       	push	r25
    2890:	8f 93       	push	r24
    2892:	1f 92       	push	r1
    2894:	1f 92       	push	r1
    2896:	1f 92       	push	r1
    2898:	b3 e0       	ldi	r27, 0x03	; 3
    289a:	bf 93       	push	r27
    289c:	0e 94 67 18 	call	0x30ce	; 0x30ce <vDisplayWriteStringAtPos>
		vTaskDelay(100 / portTICK_RATE_MS);
    28a0:	cd bf       	out	0x3d, r28	; 61
    28a2:	de bf       	out	0x3e, r29	; 62
    28a4:	64 e6       	ldi	r22, 0x64	; 100
    28a6:	70 e0       	ldi	r23, 0x00	; 0
    28a8:	80 e0       	ldi	r24, 0x00	; 0
    28aa:	90 e0       	ldi	r25, 0x00	; 0
    28ac:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
	}
    28b0:	54 cf       	rjmp	.-344    	; 0x275a <vDisplayTask+0x34>

000028b2 <vButtonHandler1>:
}

void vButtonHandler1(void *pvParameters) { //Buttonhandler to debounce Button and send to DisplayTask
	PORTF.DIRCLR = 0x10;
    28b2:	80 e1       	ldi	r24, 0x10	; 16
    28b4:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <__TEXT_REGION_LENGTH__+0x7006a2>
	for(;;) {
		if((PORTF.IN & 0x10) == 0x00) {
    28b8:	c0 ea       	ldi	r28, 0xA0	; 160
    28ba:	d6 e0       	ldi	r29, 0x06	; 6
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x10) == 0x00) { //crude debouncing
					vTaskDelay(10);
				}
				buttonData = 1;
    28bc:	c1 2c       	mov	r12, r1
    28be:	d1 2c       	mov	r13, r1
    28c0:	76 01       	movw	r14, r12
    28c2:	c3 94       	inc	r12
}

void vButtonHandler1(void *pvParameters) { //Buttonhandler to debounce Button and send to DisplayTask
	PORTF.DIRCLR = 0x10;
	for(;;) {
		if((PORTF.IN & 0x10) == 0x00) {
    28c4:	88 85       	ldd	r24, Y+8	; 0x08
    28c6:	84 fd       	sbrc	r24, 4
    28c8:	37 c0       	rjmp	.+110    	; 0x2938 <vButtonHandler1+0x86>
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
    28ca:	4a e0       	ldi	r20, 0x0A	; 10
    28cc:	50 e0       	ldi	r21, 0x00	; 0
    28ce:	60 e0       	ldi	r22, 0x00	; 0
    28d0:	70 e0       	ldi	r23, 0x00	; 0
    28d2:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    28d6:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    28da:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    28de:	88 23       	and	r24, r24
    28e0:	59 f1       	breq	.+86     	; 0x2938 <vButtonHandler1+0x86>
				while((PORTF.IN & 0x10) == 0x00) { //crude debouncing
    28e2:	88 85       	ldd	r24, Y+8	; 0x08
    28e4:	84 fd       	sbrc	r24, 4
    28e6:	09 c0       	rjmp	.+18     	; 0x28fa <vButtonHandler1+0x48>
					vTaskDelay(10);
    28e8:	6a e0       	ldi	r22, 0x0A	; 10
    28ea:	70 e0       	ldi	r23, 0x00	; 0
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
void vButtonHandler1(void *pvParameters) { //Buttonhandler to debounce Button and send to DisplayTask
	PORTF.DIRCLR = 0x10;
	for(;;) {
		if((PORTF.IN & 0x10) == 0x00) {
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x10) == 0x00) { //crude debouncing
    28f4:	88 85       	ldd	r24, Y+8	; 0x08
    28f6:	84 ff       	sbrs	r24, 4
    28f8:	f7 cf       	rjmp	.-18     	; 0x28e8 <vButtonHandler1+0x36>
					vTaskDelay(10);
				}
				buttonData = 1;
    28fa:	c0 92 90 2c 	sts	0x2C90, r12	; 0x802c90 <buttonData>
    28fe:	d0 92 91 2c 	sts	0x2C91, r13	; 0x802c91 <buttonData+0x1>
    2902:	e0 92 92 2c 	sts	0x2C92, r14	; 0x802c92 <buttonData+0x2>
    2906:	f0 92 93 2c 	sts	0x2C93, r15	; 0x802c93 <buttonData+0x3>
				xSemaphoreGive(buttonUpdate);
    290a:	00 e0       	ldi	r16, 0x00	; 0
    290c:	20 e0       	ldi	r18, 0x00	; 0
    290e:	30 e0       	ldi	r19, 0x00	; 0
    2910:	a9 01       	movw	r20, r18
    2912:	60 e0       	ldi	r22, 0x00	; 0
    2914:	70 e0       	ldi	r23, 0x00	; 0
    2916:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <buttonUpdate>
    291a:	90 91 be 2c 	lds	r25, 0x2CBE	; 0x802cbe <buttonUpdate+0x1>
    291e:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
				xSemaphoreGive(buttondataKey);
    2922:	20 e0       	ldi	r18, 0x00	; 0
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	a9 01       	movw	r20, r18
    2928:	60 e0       	ldi	r22, 0x00	; 0
    292a:	70 e0       	ldi	r23, 0x00	; 0
    292c:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2930:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2934:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
			}
		}
		vTaskDelay(50 / portTICK_RATE_MS);
    2938:	62 e3       	ldi	r22, 0x32	; 50
    293a:	70 e0       	ldi	r23, 0x00	; 0
    293c:	80 e0       	ldi	r24, 0x00	; 0
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
	}
    2944:	bf cf       	rjmp	.-130    	; 0x28c4 <vButtonHandler1+0x12>

00002946 <vButtonHandler2>:
}
void vButtonHandler2(void *pvParameters) {
	PORTF.DIRCLR = 0x20;
    2946:	80 e2       	ldi	r24, 0x20	; 32
    2948:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <__TEXT_REGION_LENGTH__+0x7006a2>
	for(;;) {
		if((PORTF.IN & 0x20) == 0x00) {
    294c:	c0 ea       	ldi	r28, 0xA0	; 160
    294e:	d6 e0       	ldi	r29, 0x06	; 6
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x20) == 0x00) {
					vTaskDelay(10);
				}
				buttonData = 2;
    2950:	c1 2c       	mov	r12, r1
    2952:	d1 2c       	mov	r13, r1
    2954:	76 01       	movw	r14, r12
    2956:	68 94       	set
    2958:	c1 f8       	bld	r12, 1
	}
}
void vButtonHandler2(void *pvParameters) {
	PORTF.DIRCLR = 0x20;
	for(;;) {
		if((PORTF.IN & 0x20) == 0x00) {
    295a:	88 85       	ldd	r24, Y+8	; 0x08
    295c:	85 fd       	sbrc	r24, 5
    295e:	37 c0       	rjmp	.+110    	; 0x29ce <vButtonHandler2+0x88>
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
    2960:	4a e0       	ldi	r20, 0x0A	; 10
    2962:	50 e0       	ldi	r21, 0x00	; 0
    2964:	60 e0       	ldi	r22, 0x00	; 0
    2966:	70 e0       	ldi	r23, 0x00	; 0
    2968:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    296c:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2970:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    2974:	88 23       	and	r24, r24
    2976:	59 f1       	breq	.+86     	; 0x29ce <vButtonHandler2+0x88>
				while((PORTF.IN & 0x20) == 0x00) {
    2978:	88 85       	ldd	r24, Y+8	; 0x08
    297a:	85 fd       	sbrc	r24, 5
    297c:	09 c0       	rjmp	.+18     	; 0x2990 <vButtonHandler2+0x4a>
					vTaskDelay(10);
    297e:	6a e0       	ldi	r22, 0x0A	; 10
    2980:	70 e0       	ldi	r23, 0x00	; 0
    2982:	80 e0       	ldi	r24, 0x00	; 0
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
void vButtonHandler2(void *pvParameters) {
	PORTF.DIRCLR = 0x20;
	for(;;) {
		if((PORTF.IN & 0x20) == 0x00) {
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x20) == 0x00) {
    298a:	88 85       	ldd	r24, Y+8	; 0x08
    298c:	85 ff       	sbrs	r24, 5
    298e:	f7 cf       	rjmp	.-18     	; 0x297e <vButtonHandler2+0x38>
					vTaskDelay(10);
				}
				buttonData = 2;
    2990:	c0 92 90 2c 	sts	0x2C90, r12	; 0x802c90 <buttonData>
    2994:	d0 92 91 2c 	sts	0x2C91, r13	; 0x802c91 <buttonData+0x1>
    2998:	e0 92 92 2c 	sts	0x2C92, r14	; 0x802c92 <buttonData+0x2>
    299c:	f0 92 93 2c 	sts	0x2C93, r15	; 0x802c93 <buttonData+0x3>
				xSemaphoreGive(buttonUpdate);
    29a0:	00 e0       	ldi	r16, 0x00	; 0
    29a2:	20 e0       	ldi	r18, 0x00	; 0
    29a4:	30 e0       	ldi	r19, 0x00	; 0
    29a6:	a9 01       	movw	r20, r18
    29a8:	60 e0       	ldi	r22, 0x00	; 0
    29aa:	70 e0       	ldi	r23, 0x00	; 0
    29ac:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <buttonUpdate>
    29b0:	90 91 be 2c 	lds	r25, 0x2CBE	; 0x802cbe <buttonUpdate+0x1>
    29b4:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
				xSemaphoreGive(buttondataKey);
    29b8:	20 e0       	ldi	r18, 0x00	; 0
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	a9 01       	movw	r20, r18
    29be:	60 e0       	ldi	r22, 0x00	; 0
    29c0:	70 e0       	ldi	r23, 0x00	; 0
    29c2:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    29c6:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    29ca:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
			}
		}
		vTaskDelay(50 / portTICK_RATE_MS);
    29ce:	62 e3       	ldi	r22, 0x32	; 50
    29d0:	70 e0       	ldi	r23, 0x00	; 0
    29d2:	80 e0       	ldi	r24, 0x00	; 0
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
	}
    29da:	bf cf       	rjmp	.-130    	; 0x295a <vButtonHandler2+0x14>

000029dc <vButtonHandler3>:
}
void vButtonHandler3(void *pvParameters) {
	PORTF.DIRCLR = 0x40;
    29dc:	80 e4       	ldi	r24, 0x40	; 64
    29de:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <__TEXT_REGION_LENGTH__+0x7006a2>
	for(;;) {
		if((PORTF.IN & 0x40) == 0x00) {
    29e2:	c0 ea       	ldi	r28, 0xA0	; 160
    29e4:	d6 e0       	ldi	r29, 0x06	; 6
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x40) == 0x00) {
					vTaskDelay(10);
				}
				buttonData = 3;
    29e6:	0f 2e       	mov	r0, r31
    29e8:	f3 e0       	ldi	r31, 0x03	; 3
    29ea:	cf 2e       	mov	r12, r31
    29ec:	d1 2c       	mov	r13, r1
    29ee:	e1 2c       	mov	r14, r1
    29f0:	f1 2c       	mov	r15, r1
    29f2:	f0 2d       	mov	r31, r0
	}
}
void vButtonHandler3(void *pvParameters) {
	PORTF.DIRCLR = 0x40;
	for(;;) {
		if((PORTF.IN & 0x40) == 0x00) {
    29f4:	88 85       	ldd	r24, Y+8	; 0x08
    29f6:	86 fd       	sbrc	r24, 6
    29f8:	37 c0       	rjmp	.+110    	; 0x2a68 <vButtonHandler3+0x8c>
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
    29fa:	4a e0       	ldi	r20, 0x0A	; 10
    29fc:	50 e0       	ldi	r21, 0x00	; 0
    29fe:	60 e0       	ldi	r22, 0x00	; 0
    2a00:	70 e0       	ldi	r23, 0x00	; 0
    2a02:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2a06:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2a0a:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    2a0e:	88 23       	and	r24, r24
    2a10:	59 f1       	breq	.+86     	; 0x2a68 <vButtonHandler3+0x8c>
				while((PORTF.IN & 0x40) == 0x00) {
    2a12:	88 85       	ldd	r24, Y+8	; 0x08
    2a14:	86 fd       	sbrc	r24, 6
    2a16:	09 c0       	rjmp	.+18     	; 0x2a2a <vButtonHandler3+0x4e>
					vTaskDelay(10);
    2a18:	6a e0       	ldi	r22, 0x0A	; 10
    2a1a:	70 e0       	ldi	r23, 0x00	; 0
    2a1c:	80 e0       	ldi	r24, 0x00	; 0
    2a1e:	90 e0       	ldi	r25, 0x00	; 0
    2a20:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
void vButtonHandler3(void *pvParameters) {
	PORTF.DIRCLR = 0x40;
	for(;;) {
		if((PORTF.IN & 0x40) == 0x00) {
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x40) == 0x00) {
    2a24:	88 85       	ldd	r24, Y+8	; 0x08
    2a26:	86 ff       	sbrs	r24, 6
    2a28:	f7 cf       	rjmp	.-18     	; 0x2a18 <vButtonHandler3+0x3c>
					vTaskDelay(10);
				}
				buttonData = 3;
    2a2a:	c0 92 90 2c 	sts	0x2C90, r12	; 0x802c90 <buttonData>
    2a2e:	d0 92 91 2c 	sts	0x2C91, r13	; 0x802c91 <buttonData+0x1>
    2a32:	e0 92 92 2c 	sts	0x2C92, r14	; 0x802c92 <buttonData+0x2>
    2a36:	f0 92 93 2c 	sts	0x2C93, r15	; 0x802c93 <buttonData+0x3>
				xSemaphoreGive(buttonUpdate);
    2a3a:	00 e0       	ldi	r16, 0x00	; 0
    2a3c:	20 e0       	ldi	r18, 0x00	; 0
    2a3e:	30 e0       	ldi	r19, 0x00	; 0
    2a40:	a9 01       	movw	r20, r18
    2a42:	60 e0       	ldi	r22, 0x00	; 0
    2a44:	70 e0       	ldi	r23, 0x00	; 0
    2a46:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <buttonUpdate>
    2a4a:	90 91 be 2c 	lds	r25, 0x2CBE	; 0x802cbe <buttonUpdate+0x1>
    2a4e:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
				xSemaphoreGive(buttondataKey);
    2a52:	20 e0       	ldi	r18, 0x00	; 0
    2a54:	30 e0       	ldi	r19, 0x00	; 0
    2a56:	a9 01       	movw	r20, r18
    2a58:	60 e0       	ldi	r22, 0x00	; 0
    2a5a:	70 e0       	ldi	r23, 0x00	; 0
    2a5c:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2a60:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2a64:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
			}
		}
		vTaskDelay(50 / portTICK_RATE_MS);
    2a68:	62 e3       	ldi	r22, 0x32	; 50
    2a6a:	70 e0       	ldi	r23, 0x00	; 0
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
	}
    2a74:	bf cf       	rjmp	.-130    	; 0x29f4 <vButtonHandler3+0x18>

00002a76 <vButtonHandler4>:
}
void vButtonHandler4(void *pvParameters) {
	PORTF.DIRCLR = 0x80;
    2a76:	80 e8       	ldi	r24, 0x80	; 128
    2a78:	80 93 a2 06 	sts	0x06A2, r24	; 0x8006a2 <__TEXT_REGION_LENGTH__+0x7006a2>
	for(;;) {
		if((PORTF.IN & 0x80) == 0x00) {
    2a7c:	c0 ea       	ldi	r28, 0xA0	; 160
    2a7e:	d6 e0       	ldi	r29, 0x06	; 6
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x80) == 0x00) {
					vTaskDelay(10);
				}
				buttonData = 4;
    2a80:	c1 2c       	mov	r12, r1
    2a82:	d1 2c       	mov	r13, r1
    2a84:	76 01       	movw	r14, r12
    2a86:	68 94       	set
    2a88:	c2 f8       	bld	r12, 2
	}
}
void vButtonHandler4(void *pvParameters) {
	PORTF.DIRCLR = 0x80;
	for(;;) {
		if((PORTF.IN & 0x80) == 0x00) {
    2a8a:	88 85       	ldd	r24, Y+8	; 0x08
    2a8c:	88 23       	and	r24, r24
    2a8e:	bc f1       	brlt	.+110    	; 0x2afe <vButtonHandler4+0x88>
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
    2a90:	4a e0       	ldi	r20, 0x0A	; 10
    2a92:	50 e0       	ldi	r21, 0x00	; 0
    2a94:	60 e0       	ldi	r22, 0x00	; 0
    2a96:	70 e0       	ldi	r23, 0x00	; 0
    2a98:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2a9c:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2aa0:	0e 94 ce 08 	call	0x119c	; 0x119c <xQueueSemaphoreTake>
    2aa4:	88 23       	and	r24, r24
    2aa6:	59 f1       	breq	.+86     	; 0x2afe <vButtonHandler4+0x88>
				while((PORTF.IN & 0x80) == 0x00) {
    2aa8:	88 85       	ldd	r24, Y+8	; 0x08
    2aaa:	88 23       	and	r24, r24
    2aac:	4c f0       	brlt	.+18     	; 0x2ac0 <vButtonHandler4+0x4a>
					vTaskDelay(10);
    2aae:	6a e0       	ldi	r22, 0x0A	; 10
    2ab0:	70 e0       	ldi	r23, 0x00	; 0
    2ab2:	80 e0       	ldi	r24, 0x00	; 0
    2ab4:	90 e0       	ldi	r25, 0x00	; 0
    2ab6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
void vButtonHandler4(void *pvParameters) {
	PORTF.DIRCLR = 0x80;
	for(;;) {
		if((PORTF.IN & 0x80) == 0x00) {
			if(xSemaphoreTake(buttondataKey, 10 / portTICK_RATE_MS)) {
				while((PORTF.IN & 0x80) == 0x00) {
    2aba:	88 85       	ldd	r24, Y+8	; 0x08
    2abc:	88 23       	and	r24, r24
    2abe:	bc f7       	brge	.-18     	; 0x2aae <vButtonHandler4+0x38>
					vTaskDelay(10);
				}
				buttonData = 4;
    2ac0:	c0 92 90 2c 	sts	0x2C90, r12	; 0x802c90 <buttonData>
    2ac4:	d0 92 91 2c 	sts	0x2C91, r13	; 0x802c91 <buttonData+0x1>
    2ac8:	e0 92 92 2c 	sts	0x2C92, r14	; 0x802c92 <buttonData+0x2>
    2acc:	f0 92 93 2c 	sts	0x2C93, r15	; 0x802c93 <buttonData+0x3>
				xSemaphoreGive(buttonUpdate);
    2ad0:	00 e0       	ldi	r16, 0x00	; 0
    2ad2:	20 e0       	ldi	r18, 0x00	; 0
    2ad4:	30 e0       	ldi	r19, 0x00	; 0
    2ad6:	a9 01       	movw	r20, r18
    2ad8:	60 e0       	ldi	r22, 0x00	; 0
    2ada:	70 e0       	ldi	r23, 0x00	; 0
    2adc:	80 91 bd 2c 	lds	r24, 0x2CBD	; 0x802cbd <buttonUpdate>
    2ae0:	90 91 be 2c 	lds	r25, 0x2CBE	; 0x802cbe <buttonUpdate+0x1>
    2ae4:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
				xSemaphoreGive(buttondataKey);
    2ae8:	20 e0       	ldi	r18, 0x00	; 0
    2aea:	30 e0       	ldi	r19, 0x00	; 0
    2aec:	a9 01       	movw	r20, r18
    2aee:	60 e0       	ldi	r22, 0x00	; 0
    2af0:	70 e0       	ldi	r23, 0x00	; 0
    2af2:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <buttondataKey>
    2af6:	90 91 c0 2c 	lds	r25, 0x2CC0	; 0x802cc0 <buttondataKey+0x1>
    2afa:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
			}
		}
		vTaskDelay(50 / portTICK_RATE_MS);
    2afe:	62 e3       	ldi	r22, 0x32	; 50
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	80 e0       	ldi	r24, 0x00	; 0
    2b04:	90 e0       	ldi	r25, 0x00	; 0
    2b06:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
	}
    2b0a:	bf cf       	rjmp	.-130    	; 0x2a8a <vButtonHandler4+0x14>

00002b0c <vApplicationIdleHook>:
SemaphoreHandle_t buttonUpdate;		//ButtonUpdate Semaphore to signal new Buttonpress
SemaphoreHandle_t buttondataKey;	//A-Resource for buttonData
uint32_t buttonData = 0;			//P-Resource

void vApplicationIdleHook( void )
{	
    2b0c:	08 95       	ret

00002b0e <main>:
	
}

int main(void)
{
    2b0e:	ef 92       	push	r14
    2b10:	ff 92       	push	r15
    2b12:	0f 93       	push	r16
    resetReason_t reason = getResetReason();
    2b14:	0e 94 0a 1c 	call	0x3814	; 0x3814 <getResetReason>

	vInitClock();
    2b18:	0e 94 5b 13 	call	0x26b6	; 0x26b6 <vInitClock>
	vInitDisplay();
    2b1c:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vInitDisplay>
	
	buttonUpdate = xSemaphoreCreateBinary();
    2b20:	43 e0       	ldi	r20, 0x03	; 3
    2b22:	60 e0       	ldi	r22, 0x00	; 0
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	0e 94 ef 06 	call	0xdde	; 0xdde <xQueueGenericCreate>
    2b2a:	80 93 bd 2c 	sts	0x2CBD, r24	; 0x802cbd <buttonUpdate>
    2b2e:	90 93 be 2c 	sts	0x2CBE, r25	; 0x802cbe <buttonUpdate+0x1>
	buttondataKey = xSemaphoreCreateMutex();
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	0e 94 c6 07 	call	0xf8c	; 0xf8c <xQueueCreateMutex>
    2b38:	80 93 bf 2c 	sts	0x2CBF, r24	; 0x802cbf <buttondataKey>
    2b3c:	90 93 c0 2c 	sts	0x2CC0, r25	; 0x802cc0 <buttondataKey+0x1>

	xTaskCreate( vDisplayTask, (const char *) "dTask", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    2b40:	e1 2c       	mov	r14, r1
    2b42:	f1 2c       	mov	r15, r1
    2b44:	01 e0       	ldi	r16, 0x01	; 1
    2b46:	20 e0       	ldi	r18, 0x00	; 0
    2b48:	30 e0       	ldi	r19, 0x00	; 0
    2b4a:	42 ed       	ldi	r20, 0xD2	; 210
    2b4c:	50 e0       	ldi	r21, 0x00	; 0
    2b4e:	69 e2       	ldi	r22, 0x29	; 41
    2b50:	70 e2       	ldi	r23, 0x20	; 32
    2b52:	83 e9       	ldi	r24, 0x93	; 147
    2b54:	93 e1       	ldi	r25, 0x13	; 19
    2b56:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
	xTaskCreate( vButtonHandler1, (const char *) "bHandler", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    2b5a:	20 e0       	ldi	r18, 0x00	; 0
    2b5c:	30 e0       	ldi	r19, 0x00	; 0
    2b5e:	42 ed       	ldi	r20, 0xD2	; 210
    2b60:	50 e0       	ldi	r21, 0x00	; 0
    2b62:	6f e2       	ldi	r22, 0x2F	; 47
    2b64:	70 e2       	ldi	r23, 0x20	; 32
    2b66:	89 e5       	ldi	r24, 0x59	; 89
    2b68:	94 e1       	ldi	r25, 0x14	; 20
    2b6a:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
	xTaskCreate( vButtonHandler2, (const char *) "bHandler", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    2b6e:	20 e0       	ldi	r18, 0x00	; 0
    2b70:	30 e0       	ldi	r19, 0x00	; 0
    2b72:	42 ed       	ldi	r20, 0xD2	; 210
    2b74:	50 e0       	ldi	r21, 0x00	; 0
    2b76:	6f e2       	ldi	r22, 0x2F	; 47
    2b78:	70 e2       	ldi	r23, 0x20	; 32
    2b7a:	83 ea       	ldi	r24, 0xA3	; 163
    2b7c:	94 e1       	ldi	r25, 0x14	; 20
    2b7e:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
	xTaskCreate( vButtonHandler3, (const char *) "bHandler", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    2b82:	20 e0       	ldi	r18, 0x00	; 0
    2b84:	30 e0       	ldi	r19, 0x00	; 0
    2b86:	42 ed       	ldi	r20, 0xD2	; 210
    2b88:	50 e0       	ldi	r21, 0x00	; 0
    2b8a:	6f e2       	ldi	r22, 0x2F	; 47
    2b8c:	70 e2       	ldi	r23, 0x20	; 32
    2b8e:	8e ee       	ldi	r24, 0xEE	; 238
    2b90:	94 e1       	ldi	r25, 0x14	; 20
    2b92:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
	xTaskCreate( vButtonHandler4, (const char *) "bHandler", configMINIMAL_STACK_SIZE+10, NULL, 1, NULL);
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	30 e0       	ldi	r19, 0x00	; 0
    2b9a:	42 ed       	ldi	r20, 0xD2	; 210
    2b9c:	50 e0       	ldi	r21, 0x00	; 0
    2b9e:	6f e2       	ldi	r22, 0x2F	; 47
    2ba0:	70 e2       	ldi	r23, 0x20	; 32
    2ba2:	8b e3       	ldi	r24, 0x3B	; 59
    2ba4:	95 e1       	ldi	r25, 0x15	; 21
    2ba6:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>

	vDisplayClear();
    2baa:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <vDisplayClear>
	vTaskStartScheduler();
    2bae:	0e 94 a2 0b 	call	0x1744	; 0x1744 <vTaskStartScheduler>
	return 0;
}
    2bb2:	80 e0       	ldi	r24, 0x00	; 0
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	0f 91       	pop	r16
    2bb8:	ff 90       	pop	r15
    2bba:	ef 90       	pop	r14
    2bbc:	08 95       	ret

00002bbe <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    2bbe:	1f 92       	push	r1
    2bc0:	0f 92       	push	r0
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	0f 92       	push	r0
    2bc6:	11 24       	eor	r1, r1
    2bc8:	0b b6       	in	r0, 0x3b	; 59
    2bca:	0f 92       	push	r0
    2bcc:	2f 93       	push	r18
    2bce:	3f 93       	push	r19
    2bd0:	4f 93       	push	r20
    2bd2:	5f 93       	push	r21
    2bd4:	6f 93       	push	r22
    2bd6:	7f 93       	push	r23
    2bd8:	8f 93       	push	r24
    2bda:	9f 93       	push	r25
    2bdc:	af 93       	push	r26
    2bde:	bf 93       	push	r27
    2be0:	ef 93       	push	r30
    2be2:	ff 93       	push	r31
    2be4:	cf 93       	push	r28
    2be6:	df 93       	push	r29
    2be8:	1f 92       	push	r1
    2bea:	cd b7       	in	r28, 0x3d	; 61
    2bec:	de b7       	in	r29, 0x3e	; 62
    2bee:	19 82       	std	Y+1, r1	; 0x01
    2bf0:	9e 01       	movw	r18, r28
    2bf2:	2f 5f       	subi	r18, 0xFF	; 255
    2bf4:	3f 4f       	sbci	r19, 0xFF	; 255
    2bf6:	41 e0       	ldi	r20, 0x01	; 1
    2bf8:	50 e0       	ldi	r21, 0x00	; 0
    2bfa:	60 e0       	ldi	r22, 0x00	; 0
    2bfc:	70 e0       	ldi	r23, 0x00	; 0
    2bfe:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <egDisplayTiming>
    2c02:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <egDisplayTiming+0x1>
    2c06:	0e 94 42 03 	call	0x684	; 0x684 <xEventGroupSetBitsFromISR>
    2c0a:	60 e0       	ldi	r22, 0x00	; 0
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	9b e0       	ldi	r25, 0x0B	; 11
    2c10:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigClockSource>
    2c14:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2c18:	0f 90       	pop	r0
    2c1a:	df 91       	pop	r29
    2c1c:	cf 91       	pop	r28
    2c1e:	ff 91       	pop	r31
    2c20:	ef 91       	pop	r30
    2c22:	bf 91       	pop	r27
    2c24:	af 91       	pop	r26
    2c26:	9f 91       	pop	r25
    2c28:	8f 91       	pop	r24
    2c2a:	7f 91       	pop	r23
    2c2c:	6f 91       	pop	r22
    2c2e:	5f 91       	pop	r21
    2c30:	4f 91       	pop	r20
    2c32:	3f 91       	pop	r19
    2c34:	2f 91       	pop	r18
    2c36:	0f 90       	pop	r0
    2c38:	0b be       	out	0x3b, r0	; 59
    2c3a:	0f 90       	pop	r0
    2c3c:	0f be       	out	0x3f, r0	; 63
    2c3e:	0f 90       	pop	r0
    2c40:	1f 90       	pop	r1
    2c42:	18 95       	reti

00002c44 <delayUS>:
    2c44:	cf 92       	push	r12
    2c46:	df 92       	push	r13
    2c48:	ef 92       	push	r14
    2c4a:	ff 92       	push	r15
    2c4c:	0f 93       	push	r16
    2c4e:	6b 01       	movw	r12, r22
    2c50:	7c 01       	movw	r14, r24
    2c52:	82 e0       	ldi	r24, 0x02	; 2
    2c54:	c8 16       	cp	r12, r24
    2c56:	d1 04       	cpc	r13, r1
    2c58:	e1 04       	cpc	r14, r1
    2c5a:	f1 04       	cpc	r15, r1
    2c5c:	08 f4       	brcc	.+2      	; 0x2c60 <delayUS+0x1c>
    2c5e:	4e c0       	rjmp	.+156    	; 0x2cfc <delayUS+0xb8>
    2c60:	e0 e0       	ldi	r30, 0x00	; 0
    2c62:	fb e0       	ldi	r31, 0x0B	; 11
    2c64:	81 e0       	ldi	r24, 0x01	; 1
    2c66:	86 83       	std	Z+6, r24	; 0x06
    2c68:	10 a2       	std	Z+32, r1	; 0x20
    2c6a:	11 a2       	std	Z+33, r1	; 0x21
    2c6c:	60 e0       	ldi	r22, 0x00	; 0
    2c6e:	80 e0       	ldi	r24, 0x00	; 0
    2c70:	9b e0       	ldi	r25, 0x0B	; 11
    2c72:	0e 94 9c 01 	call	0x338	; 0x338 <TC0_ConfigWGM>
    2c76:	8e ef       	ldi	r24, 0xFE	; 254
    2c78:	c8 16       	cp	r12, r24
    2c7a:	8f ef       	ldi	r24, 0xFF	; 255
    2c7c:	d8 06       	cpc	r13, r24
    2c7e:	e1 04       	cpc	r14, r1
    2c80:	f1 04       	cpc	r15, r1
    2c82:	70 f4       	brcc	.+28     	; 0x2ca0 <delayUS+0x5c>
    2c84:	f6 94       	lsr	r15
    2c86:	e7 94       	ror	r14
    2c88:	d7 94       	ror	r13
    2c8a:	c7 94       	ror	r12
    2c8c:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2c90:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2c94:	65 e0       	ldi	r22, 0x05	; 5
    2c96:	80 e0       	ldi	r24, 0x00	; 0
    2c98:	9b e0       	ldi	r25, 0x0B	; 11
    2c9a:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigClockSource>
    2c9e:	19 c0       	rjmp	.+50     	; 0x2cd2 <delayUS+0x8e>
    2ca0:	80 e4       	ldi	r24, 0x40	; 64
    2ca2:	c8 16       	cp	r12, r24
    2ca4:	82 e4       	ldi	r24, 0x42	; 66
    2ca6:	d8 06       	cpc	r13, r24
    2ca8:	8f e0       	ldi	r24, 0x0F	; 15
    2caa:	e8 06       	cpc	r14, r24
    2cac:	f1 04       	cpc	r15, r1
    2cae:	88 f4       	brcc	.+34     	; 0x2cd2 <delayUS+0x8e>
    2cb0:	68 94       	set
    2cb2:	14 f8       	bld	r1, 4
    2cb4:	f6 94       	lsr	r15
    2cb6:	e7 94       	ror	r14
    2cb8:	d7 94       	ror	r13
    2cba:	c7 94       	ror	r12
    2cbc:	16 94       	lsr	r1
    2cbe:	d1 f7       	brne	.-12     	; 0x2cb4 <delayUS+0x70>
    2cc0:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2cc4:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2cc8:	67 e0       	ldi	r22, 0x07	; 7
    2cca:	80 e0       	ldi	r24, 0x00	; 0
    2ccc:	9b e0       	ldi	r25, 0x0B	; 11
    2cce:	0e 94 96 01 	call	0x32c	; 0x32c <TC0_ConfigClockSource>
    2cd2:	0f 2e       	mov	r0, r31
    2cd4:	f4 ef       	ldi	r31, 0xF4	; 244
    2cd6:	cf 2e       	mov	r12, r31
    2cd8:	dd 24       	eor	r13, r13
    2cda:	d3 94       	inc	r13
    2cdc:	e1 2c       	mov	r14, r1
    2cde:	f1 2c       	mov	r15, r1
    2ce0:	f0 2d       	mov	r31, r0
    2ce2:	00 e0       	ldi	r16, 0x00	; 0
    2ce4:	21 e0       	ldi	r18, 0x01	; 1
    2ce6:	41 e0       	ldi	r20, 0x01	; 1
    2ce8:	50 e0       	ldi	r21, 0x00	; 0
    2cea:	60 e0       	ldi	r22, 0x00	; 0
    2cec:	70 e0       	ldi	r23, 0x00	; 0
    2cee:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <egDisplayTiming>
    2cf2:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <egDisplayTiming+0x1>
    2cf6:	0e 94 c7 01 	call	0x38e	; 0x38e <xEventGroupWaitBits>
    2cfa:	11 c0       	rjmp	.+34     	; 0x2d1e <delayUS+0xda>
    2cfc:	e0 e0       	ldi	r30, 0x00	; 0
    2cfe:	fb e0       	ldi	r31, 0x0B	; 11
    2d00:	81 e0       	ldi	r24, 0x01	; 1
    2d02:	86 83       	std	Z+6, r24	; 0x06
    2d04:	10 a2       	std	Z+32, r1	; 0x20
    2d06:	11 a2       	std	Z+33, r1	; 0x21
    2d08:	60 e0       	ldi	r22, 0x00	; 0
    2d0a:	80 e0       	ldi	r24, 0x00	; 0
    2d0c:	9b e0       	ldi	r25, 0x0B	; 11
    2d0e:	0e 94 9c 01 	call	0x338	; 0x338 <TC0_ConfigWGM>
    2d12:	c1 2c       	mov	r12, r1
    2d14:	d1 2c       	mov	r13, r1
    2d16:	76 01       	movw	r14, r12
    2d18:	68 94       	set
    2d1a:	c1 f8       	bld	r12, 1
    2d1c:	b3 cf       	rjmp	.-154    	; 0x2c84 <delayUS+0x40>
    2d1e:	0f 91       	pop	r16
    2d20:	ff 90       	pop	r15
    2d22:	ef 90       	pop	r14
    2d24:	df 90       	pop	r13
    2d26:	cf 90       	pop	r12
    2d28:	08 95       	ret

00002d2a <setPort>:
    2d2a:	82 95       	swap	r24
    2d2c:	80 7f       	andi	r24, 0xF0	; 240
    2d2e:	e0 e0       	ldi	r30, 0x00	; 0
    2d30:	f6 e0       	ldi	r31, 0x06	; 6
    2d32:	94 81       	ldd	r25, Z+4	; 0x04
    2d34:	28 2f       	mov	r18, r24
    2d36:	2f 60       	ori	r18, 0x0F	; 15
    2d38:	92 23       	and	r25, r18
    2d3a:	94 83       	std	Z+4, r25	; 0x04
    2d3c:	94 81       	ldd	r25, Z+4	; 0x04
    2d3e:	89 2b       	or	r24, r25
    2d40:	84 83       	std	Z+4, r24	; 0x04
    2d42:	08 95       	ret

00002d44 <Nybble>:
    2d44:	1f 93       	push	r17
    2d46:	cf 93       	push	r28
    2d48:	df 93       	push	r29
    2d4a:	c0 e6       	ldi	r28, 0x60	; 96
    2d4c:	d6 e0       	ldi	r29, 0x06	; 6
    2d4e:	14 e0       	ldi	r17, 0x04	; 4
    2d50:	1d 83       	std	Y+5, r17	; 0x05
    2d52:	61 e0       	ldi	r22, 0x01	; 1
    2d54:	70 e0       	ldi	r23, 0x00	; 0
    2d56:	80 e0       	ldi	r24, 0x00	; 0
    2d58:	90 e0       	ldi	r25, 0x00	; 0
    2d5a:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
    2d5e:	1e 83       	std	Y+6, r17	; 0x06
    2d60:	df 91       	pop	r29
    2d62:	cf 91       	pop	r28
    2d64:	1f 91       	pop	r17
    2d66:	08 95       	ret

00002d68 <command>:
    2d68:	cf 93       	push	r28
    2d6a:	c8 2f       	mov	r28, r24
    2d6c:	82 95       	swap	r24
    2d6e:	8f 70       	andi	r24, 0x0F	; 15
    2d70:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
    2d74:	e0 e6       	ldi	r30, 0x60	; 96
    2d76:	f6 e0       	ldi	r31, 0x06	; 6
    2d78:	81 e0       	ldi	r24, 0x01	; 1
    2d7a:	86 83       	std	Z+6, r24	; 0x06
    2d7c:	82 e0       	ldi	r24, 0x02	; 2
    2d7e:	86 83       	std	Z+6, r24	; 0x06
    2d80:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
    2d84:	8c 2f       	mov	r24, r28
    2d86:	8f 70       	andi	r24, 0x0F	; 15
    2d88:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
    2d8c:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
    2d90:	cf 91       	pop	r28
    2d92:	08 95       	ret

00002d94 <write>:
    2d94:	cf 93       	push	r28
    2d96:	c8 2f       	mov	r28, r24
    2d98:	82 95       	swap	r24
    2d9a:	8f 70       	andi	r24, 0x0F	; 15
    2d9c:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
    2da0:	e0 e6       	ldi	r30, 0x60	; 96
    2da2:	f6 e0       	ldi	r31, 0x06	; 6
    2da4:	81 e0       	ldi	r24, 0x01	; 1
    2da6:	85 83       	std	Z+5, r24	; 0x05
    2da8:	82 e0       	ldi	r24, 0x02	; 2
    2daa:	86 83       	std	Z+6, r24	; 0x06
    2dac:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
    2db0:	8c 2f       	mov	r24, r28
    2db2:	8f 70       	andi	r24, 0x0F	; 15
    2db4:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
    2db8:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
    2dbc:	cf 91       	pop	r28
    2dbe:	08 95       	ret

00002dc0 <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2dc0:	ef 92       	push	r14
    2dc2:	ff 92       	push	r15
    2dc4:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2dc6:	e0 e0       	ldi	r30, 0x00	; 0
    2dc8:	f6 e0       	ldi	r31, 0x06	; 6
    2dca:	80 e1       	ldi	r24, 0x10	; 16
    2dcc:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2dce:	80 e2       	ldi	r24, 0x20	; 32
    2dd0:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2dd2:	80 e4       	ldi	r24, 0x40	; 64
    2dd4:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2dd6:	80 e8       	ldi	r24, 0x80	; 128
    2dd8:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2dda:	a0 e6       	ldi	r26, 0x60	; 96
    2ddc:	b6 e0       	ldi	r27, 0x06	; 6
    2dde:	81 e0       	ldi	r24, 0x01	; 1
    2de0:	11 96       	adiw	r26, 0x01	; 1
    2de2:	8c 93       	st	X, r24
    2de4:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2de6:	82 e0       	ldi	r24, 0x02	; 2
    2de8:	11 96       	adiw	r26, 0x01	; 1
    2dea:	8c 93       	st	X, r24
    2dec:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2dee:	84 e0       	ldi	r24, 0x04	; 4
    2df0:	11 96       	adiw	r26, 0x01	; 1
    2df2:	8c 93       	st	X, r24
    2df4:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2df6:	84 81       	ldd	r24, Z+4	; 0x04
    2df8:	8f 70       	andi	r24, 0x0F	; 15
    2dfa:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2dfc:	14 96       	adiw	r26, 0x04	; 4
    2dfe:	8c 91       	ld	r24, X
    2e00:	14 97       	sbiw	r26, 0x04	; 4
    2e02:	88 7f       	andi	r24, 0xF8	; 248
    2e04:	14 96       	adiw	r26, 0x04	; 4
    2e06:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2e08:	40 e0       	ldi	r20, 0x00	; 0
    2e0a:	66 e1       	ldi	r22, 0x16	; 22
    2e0c:	88 e0       	ldi	r24, 0x08	; 8
    2e0e:	0e 94 ef 06 	call	0xdde	; 0xdde <xQueueGenericCreate>
    2e12:	80 93 c1 2c 	sts	0x2CC1, r24	; 0x802cc1 <displayLineQueue>
    2e16:	90 93 c2 2c 	sts	0x2CC2, r25	; 0x802cc2 <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2e1a:	0e 94 b2 01 	call	0x364	; 0x364 <xEventGroupCreate>
    2e1e:	80 93 c3 2c 	sts	0x2CC3, r24	; 0x802cc3 <egDisplayTiming>
    2e22:	90 93 c4 2c 	sts	0x2CC4, r25	; 0x802cc4 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2e26:	e1 2c       	mov	r14, r1
    2e28:	f1 2c       	mov	r15, r1
    2e2a:	01 e0       	ldi	r16, 0x01	; 1
    2e2c:	20 e0       	ldi	r18, 0x00	; 0
    2e2e:	30 e0       	ldi	r19, 0x00	; 0
    2e30:	4e e5       	ldi	r20, 0x5E	; 94
    2e32:	51 e0       	ldi	r21, 0x01	; 1
    2e34:	68 e3       	ldi	r22, 0x38	; 56
    2e36:	70 e2       	ldi	r23, 0x20	; 32
    2e38:	8e e7       	ldi	r24, 0x7E	; 126
    2e3a:	97 e1       	ldi	r25, 0x17	; 23
    2e3c:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xTaskCreate>
 }
    2e40:	0f 91       	pop	r16
    2e42:	ff 90       	pop	r15
    2e44:	ef 90       	pop	r14
    2e46:	08 95       	ret

00002e48 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2e48:	81 30       	cpi	r24, 0x01	; 1
    2e4a:	91 05       	cpc	r25, r1
    2e4c:	79 f0       	breq	.+30     	; 0x2e6c <_displaySetPos+0x24>
    2e4e:	1c f4       	brge	.+6      	; 0x2e56 <_displaySetPos+0xe>
    2e50:	89 2b       	or	r24, r25
    2e52:	39 f0       	breq	.+14     	; 0x2e62 <_displaySetPos+0x1a>
    2e54:	19 c0       	rjmp	.+50     	; 0x2e88 <_displaySetPos+0x40>
    2e56:	82 30       	cpi	r24, 0x02	; 2
    2e58:	91 05       	cpc	r25, r1
    2e5a:	69 f0       	breq	.+26     	; 0x2e76 <_displaySetPos+0x2e>
    2e5c:	03 97       	sbiw	r24, 0x03	; 3
    2e5e:	81 f0       	breq	.+32     	; 0x2e80 <_displaySetPos+0x38>
    2e60:	13 c0       	rjmp	.+38     	; 0x2e88 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2e62:	80 e8       	ldi	r24, 0x80	; 128
    2e64:	86 0f       	add	r24, r22
    2e66:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
		 break;
    2e6a:	0e c0       	rjmp	.+28     	; 0x2e88 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2e6c:	80 ec       	ldi	r24, 0xC0	; 192
    2e6e:	86 0f       	add	r24, r22
    2e70:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
		 break;
    2e74:	09 c0       	rjmp	.+18     	; 0x2e88 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2e76:	84 e9       	ldi	r24, 0x94	; 148
    2e78:	86 0f       	add	r24, r22
    2e7a:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
		 break;
    2e7e:	04 c0       	rjmp	.+8      	; 0x2e88 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2e80:	84 ed       	ldi	r24, 0xD4	; 212
    2e82:	86 0f       	add	r24, r22
    2e84:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
		 break;
	 }
	 delayUS(39);
    2e88:	67 e2       	ldi	r22, 0x27	; 39
    2e8a:	70 e0       	ldi	r23, 0x00	; 0
    2e8c:	80 e0       	ldi	r24, 0x00	; 0
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
    2e94:	08 95       	ret

00002e96 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2e96:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <write>
	 delayUS(43);
    2e9a:	6b e2       	ldi	r22, 0x2B	; 43
    2e9c:	70 e0       	ldi	r23, 0x00	; 0
    2e9e:	80 e0       	ldi	r24, 0x00	; 0
    2ea0:	90 e0       	ldi	r25, 0x00	; 0
    2ea2:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
    2ea6:	08 95       	ret

00002ea8 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2ea8:	0f 93       	push	r16
    2eaa:	1f 93       	push	r17
    2eac:	cf 93       	push	r28
    2eae:	df 93       	push	r29
    2eb0:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2eb2:	80 81       	ld	r24, Z
    2eb4:	81 11       	cpse	r24, r1
    2eb6:	0a c0       	rjmp	.+20     	; 0x2ecc <_displayWriteString+0x24>
    2eb8:	11 c0       	rjmp	.+34     	; 0x2edc <_displayWriteString+0x34>
    2eba:	89 91       	ld	r24, Y+
    2ebc:	88 23       	and	r24, r24
    2ebe:	71 f0       	breq	.+28     	; 0x2edc <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2ec0:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2ec4:	0c 17       	cp	r16, r28
    2ec6:	1d 07       	cpc	r17, r29
    2ec8:	c1 f7       	brne	.-16     	; 0x2eba <_displayWriteString+0x12>
    2eca:	08 c0       	rjmp	.+16     	; 0x2edc <_displayWriteString+0x34>
    2ecc:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2ece:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <_displayWriteChar>
    2ed2:	e8 01       	movw	r28, r16
    2ed4:	21 96       	adiw	r28, 0x01	; 1
    2ed6:	0c 5e       	subi	r16, 0xEC	; 236
    2ed8:	1f 4f       	sbci	r17, 0xFF	; 255
    2eda:	ef cf       	rjmp	.-34     	; 0x2eba <_displayWriteString+0x12>
	 }
 }
    2edc:	df 91       	pop	r29
    2ede:	cf 91       	pop	r28
    2ee0:	1f 91       	pop	r17
    2ee2:	0f 91       	pop	r16
    2ee4:	08 95       	ret

00002ee6 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2ee6:	cf 93       	push	r28
    2ee8:	df 93       	push	r29
    2eea:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2eec:	0e 94 24 17 	call	0x2e48	; 0x2e48 <_displaySetPos>
	 _displayWriteString(s);
    2ef0:	ce 01       	movw	r24, r28
    2ef2:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <_displayWriteString>
 }
    2ef6:	df 91       	pop	r29
    2ef8:	cf 91       	pop	r28
    2efa:	08 95       	ret

00002efc <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2efc:	cf 93       	push	r28
    2efe:	df 93       	push	r29
    2f00:	cd b7       	in	r28, 0x3d	; 61
    2f02:	de b7       	in	r29, 0x3e	; 62
    2f04:	c6 56       	subi	r28, 0x66	; 102
    2f06:	d1 09       	sbc	r29, r1
    2f08:	cd bf       	out	0x3d, r28	; 61
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	5e 01       	movw	r10, r28
    2f0e:	41 e5       	ldi	r20, 0x51	; 81
    2f10:	a4 0e       	add	r10, r20
    2f12:	b1 1c       	adc	r11, r1
    2f14:	fe 01       	movw	r30, r28
    2f16:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2f18:	20 e2       	ldi	r18, 0x20	; 32
    2f1a:	08 c0       	rjmp	.+16     	; 0x2f2c <vDisplayUpdateTask+0x30>
    2f1c:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2f1e:	e8 17       	cp	r30, r24
    2f20:	f9 07       	cpc	r31, r25
    2f22:	e1 f7       	brne	.-8      	; 0x2f1c <vDisplayUpdateTask+0x20>
    2f24:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2f26:	a8 16       	cp	r10, r24
    2f28:	b9 06       	cpc	r11, r25
    2f2a:	19 f0       	breq	.+6      	; 0x2f32 <vDisplayUpdateTask+0x36>
    2f2c:	cf 01       	movw	r24, r30
    2f2e:	44 96       	adiw	r24, 0x14	; 20
    2f30:	f5 cf       	rjmp	.-22     	; 0x2f1c <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2f32:	60 e4       	ldi	r22, 0x40	; 64
    2f34:	7c e9       	ldi	r23, 0x9C	; 156
    2f36:	80 e0       	ldi	r24, 0x00	; 0
    2f38:	90 e0       	ldi	r25, 0x00	; 0
    2f3a:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
	 setPort(0x03);
    2f3e:	83 e0       	ldi	r24, 0x03	; 3
    2f40:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
	 delayUS(5000);
    2f44:	68 e8       	ldi	r22, 0x88	; 136
    2f46:	73 e1       	ldi	r23, 0x13	; 19
    2f48:	80 e0       	ldi	r24, 0x00	; 0
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
	 Nybble();
    2f50:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
	 delayUS(160);
    2f54:	60 ea       	ldi	r22, 0xA0	; 160
    2f56:	70 e0       	ldi	r23, 0x00	; 0
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
	 Nybble();
    2f60:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
	 delayUS(160);
    2f64:	60 ea       	ldi	r22, 0xA0	; 160
    2f66:	70 e0       	ldi	r23, 0x00	; 0
    2f68:	80 e0       	ldi	r24, 0x00	; 0
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
	 Nybble();
    2f70:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
	 delayUS(160);
    2f74:	60 ea       	ldi	r22, 0xA0	; 160
    2f76:	70 e0       	ldi	r23, 0x00	; 0
    2f78:	80 e0       	ldi	r24, 0x00	; 0
    2f7a:	90 e0       	ldi	r25, 0x00	; 0
    2f7c:	0e 94 22 16 	call	0x2c44	; 0x2c44 <delayUS>
	 setPort(0x02);
    2f80:	82 e0       	ldi	r24, 0x02	; 2
    2f82:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <setPort>
	 Nybble();
    2f86:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <Nybble>
	 command(0x28);
    2f8a:	88 e2       	ldi	r24, 0x28	; 40
    2f8c:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
	 command(0x10);
    2f90:	80 e1       	ldi	r24, 0x10	; 16
    2f92:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
	 command(0x0C); //Cursor and Blinking off
    2f96:	8c e0       	ldi	r24, 0x0C	; 12
    2f98:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
	 command(0x06);
    2f9c:	86 e0       	ldi	r24, 0x06	; 6
    2f9e:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2fa2:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2fa4:	6e 01       	movw	r12, r28
    2fa6:	51 e5       	ldi	r21, 0x51	; 81
    2fa8:	c5 0e       	add	r12, r21
    2faa:	d1 1c       	adc	r13, r1
    2fac:	0f 2e       	mov	r0, r31
    2fae:	f4 e1       	ldi	r31, 0x14	; 20
    2fb0:	4f 2e       	mov	r4, r31
    2fb2:	f0 2d       	mov	r31, r0
    2fb4:	0f 2e       	mov	r0, r31
    2fb6:	f6 e1       	ldi	r31, 0x16	; 22
    2fb8:	8f 2e       	mov	r8, r31
    2fba:	91 2c       	mov	r9, r1
    2fbc:	f0 2d       	mov	r31, r0
    2fbe:	5c 2c       	mov	r5, r12
    2fc0:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2fc2:	68 ec       	ldi	r22, 0xC8	; 200
    2fc4:	70 e0       	ldi	r23, 0x00	; 0
    2fc6:	80 e0       	ldi	r24, 0x00	; 0
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2fce:	40 e0       	ldi	r20, 0x00	; 0
    2fd0:	50 e0       	ldi	r21, 0x00	; 0
    2fd2:	ba 01       	movw	r22, r20
    2fd4:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <egDisplayTiming>
    2fd8:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <egDisplayTiming+0x1>
    2fdc:	0e 94 8c 02 	call	0x518	; 0x518 <xEventGroupClearBits>
    2fe0:	67 2b       	or	r22, r23
    2fe2:	68 2b       	or	r22, r24
    2fe4:	69 2b       	or	r22, r25
    2fe6:	09 f4       	brne	.+2      	; 0x2fea <vDisplayUpdateTask+0xee>
    2fe8:	49 c0       	rjmp	.+146    	; 0x307c <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2fea:	42 e0       	ldi	r20, 0x02	; 2
    2fec:	50 e0       	ldi	r21, 0x00	; 0
    2fee:	60 e0       	ldi	r22, 0x00	; 0
    2ff0:	70 e0       	ldi	r23, 0x00	; 0
    2ff2:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <egDisplayTiming>
    2ff6:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <egDisplayTiming+0x1>
    2ffa:	0e 94 8c 02 	call	0x518	; 0x518 <xEventGroupClearBits>
    2ffe:	fe 01       	movw	r30, r28
    3000:	31 96       	adiw	r30, 0x01	; 1
    3002:	08 c0       	rjmp	.+16     	; 0x3014 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    3004:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    3006:	e8 17       	cp	r30, r24
    3008:	f9 07       	cpc	r31, r25
    300a:	e1 f7       	brne	.-8      	; 0x3004 <vDisplayUpdateTask+0x108>
    300c:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    300e:	8a 15       	cp	r24, r10
    3010:	9b 05       	cpc	r25, r11
    3012:	a1 f1       	breq	.+104    	; 0x307c <vDisplayUpdateTask+0x180>
    3014:	cf 01       	movw	r24, r30
    3016:	44 96       	adiw	r24, 0x14	; 20
    3018:	f5 cf       	rjmp	.-22     	; 0x3004 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    301a:	2f ef       	ldi	r18, 0xFF	; 255
    301c:	3f ef       	ldi	r19, 0xFF	; 255
    301e:	a9 01       	movw	r20, r18
    3020:	65 2d       	mov	r22, r5
    3022:	70 2f       	mov	r23, r16
    3024:	80 91 c1 2c 	lds	r24, 0x2CC1	; 0x802cc1 <displayLineQueue>
    3028:	90 91 c2 2c 	lds	r25, 0x2CC2	; 0x802cc2 <displayLineQueue+0x1>
    302c:	0e 94 28 08 	call	0x1050	; 0x1050 <xQueueReceive>
    3030:	88 23       	and	r24, r24
    3032:	21 f1       	breq	.+72     	; 0x307c <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    3034:	f6 01       	movw	r30, r12
    3036:	21 81       	ldd	r18, Z+1	; 0x01
    3038:	82 2f       	mov	r24, r18
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	44 97       	sbiw	r24, 0x14	; 20
    303e:	f4 f4       	brge	.+60     	; 0x307c <vDisplayUpdateTask+0x180>
    3040:	82 81       	ldd	r24, Z+2	; 0x02
    3042:	88 23       	and	r24, r24
    3044:	d9 f0       	breq	.+54     	; 0x307c <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    3046:	90 81       	ld	r25, Z
    3048:	30 e0       	ldi	r19, 0x00	; 0
    304a:	d9 01       	movw	r26, r18
    304c:	49 9e       	mul	r4, r25
    304e:	a0 0d       	add	r26, r0
    3050:	b1 1d       	adc	r27, r1
    3052:	11 24       	eor	r1, r1
    3054:	41 e0       	ldi	r20, 0x01	; 1
    3056:	50 e0       	ldi	r21, 0x00	; 0
    3058:	4c 0f       	add	r20, r28
    305a:	5d 1f       	adc	r21, r29
    305c:	a4 0f       	add	r26, r20
    305e:	b5 1f       	adc	r27, r21
    3060:	33 96       	adiw	r30, 0x03	; 3
    3062:	a4 01       	movw	r20, r8
    3064:	42 1b       	sub	r20, r18
    3066:	53 0b       	sbc	r21, r19
    3068:	9a 01       	movw	r18, r20
    306a:	2c 0d       	add	r18, r12
    306c:	3d 1d       	adc	r19, r13
    306e:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    3070:	e2 17       	cp	r30, r18
    3072:	f3 07       	cpc	r31, r19
    3074:	19 f0       	breq	.+6      	; 0x307c <vDisplayUpdateTask+0x180>
    3076:	81 91       	ld	r24, Z+
    3078:	81 11       	cpse	r24, r1
    307a:	f9 cf       	rjmp	.-14     	; 0x306e <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    307c:	80 91 c1 2c 	lds	r24, 0x2CC1	; 0x802cc1 <displayLineQueue>
    3080:	90 91 c2 2c 	lds	r25, 0x2CC2	; 0x802cc2 <displayLineQueue+0x1>
    3084:	0e 94 b3 09 	call	0x1366	; 0x1366 <uxQueueMessagesWaiting>
    3088:	81 11       	cpse	r24, r1
    308a:	c7 cf       	rjmp	.-114    	; 0x301a <vDisplayUpdateTask+0x11e>
    308c:	ce 01       	movw	r24, r28
    308e:	01 96       	adiw	r24, 0x01	; 1
    3090:	7c 01       	movw	r14, r24
    3092:	61 2c       	mov	r6, r1
    3094:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    3096:	a7 01       	movw	r20, r14
    3098:	60 e0       	ldi	r22, 0x00	; 0
    309a:	70 e0       	ldi	r23, 0x00	; 0
    309c:	c3 01       	movw	r24, r6
    309e:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    30a2:	9f ef       	ldi	r25, 0xFF	; 255
    30a4:	69 1a       	sub	r6, r25
    30a6:	79 0a       	sbc	r7, r25
    30a8:	e4 e1       	ldi	r30, 0x14	; 20
    30aa:	ee 0e       	add	r14, r30
    30ac:	f1 1c       	adc	r15, r1
    30ae:	f4 e0       	ldi	r31, 0x04	; 4
    30b0:	6f 16       	cp	r6, r31
    30b2:	71 04       	cpc	r7, r1
    30b4:	81 f7       	brne	.-32     	; 0x3096 <vDisplayUpdateTask+0x19a>
    30b6:	85 cf       	rjmp	.-246    	; 0x2fc2 <vDisplayUpdateTask+0xc6>

000030b8 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    30b8:	42 e0       	ldi	r20, 0x02	; 2
    30ba:	50 e0       	ldi	r21, 0x00	; 0
    30bc:	60 e0       	ldi	r22, 0x00	; 0
    30be:	70 e0       	ldi	r23, 0x00	; 0
    30c0:	80 91 c3 2c 	lds	r24, 0x2CC3	; 0x802cc3 <egDisplayTiming>
    30c4:	90 91 c4 2c 	lds	r25, 0x2CC4	; 0x802cc4 <egDisplayTiming+0x1>
    30c8:	0e 94 ad 02 	call	0x55a	; 0x55a <xEventGroupSetBits>
    30cc:	08 95       	ret

000030ce <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    30ce:	2f 92       	push	r2
    30d0:	3f 92       	push	r3
    30d2:	4f 92       	push	r4
    30d4:	5f 92       	push	r5
    30d6:	6f 92       	push	r6
    30d8:	7f 92       	push	r7
    30da:	8f 92       	push	r8
    30dc:	9f 92       	push	r9
    30de:	af 92       	push	r10
    30e0:	bf 92       	push	r11
    30e2:	cf 92       	push	r12
    30e4:	df 92       	push	r13
    30e6:	ef 92       	push	r14
    30e8:	ff 92       	push	r15
    30ea:	0f 93       	push	r16
    30ec:	1f 93       	push	r17
    30ee:	cf 93       	push	r28
    30f0:	df 93       	push	r29
    30f2:	cd b7       	in	r28, 0x3d	; 61
    30f4:	de b7       	in	r29, 0x3e	; 62
    30f6:	6d 97       	sbiw	r28, 0x1d	; 29
    30f8:	cd bf       	out	0x3d, r28	; 61
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	2b a9       	ldd	r18, Y+51	; 0x33
    30fe:	2b 8f       	std	Y+27, r18	; 0x1b
    3100:	af a9       	ldd	r26, Y+55	; 0x37
    3102:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    3104:	7e 01       	movw	r14, r28
    3106:	39 e3       	ldi	r19, 0x39	; 57
    3108:	e3 0e       	add	r14, r19
    310a:	f1 1c       	adc	r15, r1
    310c:	2c eb       	ldi	r18, 0xBC	; 188
    310e:	3c e2       	ldi	r19, 0x2C	; 44
	display_vprintf(line, pos, fmt, arg);
    3110:	e8 ea       	ldi	r30, 0xA8	; 168
    3112:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    3114:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    3116:	e2 17       	cp	r30, r18
    3118:	f3 07       	cpc	r31, r19
    311a:	e1 f7       	brne	.-8      	; 0x3114 <vDisplayWriteStringAtPos+0x46>
    311c:	0f 2e       	mov	r0, r31
    311e:	f4 e9       	ldi	r31, 0x94	; 148
    3120:	af 2e       	mov	r10, r31
    3122:	fc e2       	ldi	r31, 0x2C	; 44
    3124:	bf 2e       	mov	r11, r31
    3126:	f0 2d       	mov	r31, r0
    3128:	28 ea       	ldi	r18, 0xA8	; 168
    312a:	3c e2       	ldi	r19, 0x2C	; 44
    312c:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    312e:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3130:	e2 17       	cp	r30, r18
    3132:	f3 07       	cpc	r31, r19
    3134:	e1 f7       	brne	.-8      	; 0x312e <vDisplayWriteStringAtPos+0x60>
    3136:	81 2c       	mov	r8, r1
    3138:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    313a:	0f 2e       	mov	r0, r31
    313c:	f8 ea       	ldi	r31, 0xA8	; 168
    313e:	cf 2e       	mov	r12, r31
    3140:	fc e2       	ldi	r31, 0x2C	; 44
    3142:	df 2e       	mov	r13, r31
    3144:	f0 2d       	mov	r31, r0
    3146:	fc c2       	rjmp	.+1528   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    3148:	85 32       	cpi	r24, 0x25	; 37
    314a:	09 f0       	breq	.+2      	; 0x314e <vDisplayWriteStringAtPos+0x80>
    314c:	e8 c2       	rjmp	.+1488   	; 0x371e <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    314e:	2d 01       	movw	r4, r26
    3150:	82 e0       	ldi	r24, 0x02	; 2
    3152:	48 0e       	add	r4, r24
    3154:	51 1c       	adc	r5, r1
    3156:	11 96       	adiw	r26, 0x01	; 1
    3158:	8c 91       	ld	r24, X
    315a:	85 36       	cpi	r24, 0x65	; 101
    315c:	09 f4       	brne	.+2      	; 0x3160 <vDisplayWriteStringAtPos+0x92>
    315e:	db c1       	rjmp	.+950    	; 0x3516 <vDisplayWriteStringAtPos+0x448>
    3160:	38 f4       	brcc	.+14     	; 0x3170 <vDisplayWriteStringAtPos+0xa2>
    3162:	83 36       	cpi	r24, 0x63	; 99
    3164:	c1 f0       	breq	.+48     	; 0x3196 <vDisplayWriteStringAtPos+0xc8>
    3166:	08 f0       	brcs	.+2      	; 0x316a <vDisplayWriteStringAtPos+0x9c>
    3168:	48 c0       	rjmp	.+144    	; 0x31fa <vDisplayWriteStringAtPos+0x12c>
    316a:	85 32       	cpi	r24, 0x25	; 37
    316c:	51 f0       	breq	.+20     	; 0x3182 <vDisplayWriteStringAtPos+0xb4>
    316e:	e7 c2       	rjmp	.+1486   	; 0x373e <vDisplayWriteStringAtPos+0x670>
    3170:	83 37       	cpi	r24, 0x73	; 115
    3172:	f9 f0       	breq	.+62     	; 0x31b2 <vDisplayWriteStringAtPos+0xe4>
    3174:	88 37       	cpi	r24, 0x78	; 120
    3176:	09 f4       	brne	.+2      	; 0x317a <vDisplayWriteStringAtPos+0xac>
    3178:	68 c0       	rjmp	.+208    	; 0x324a <vDisplayWriteStringAtPos+0x17c>
    317a:	86 36       	cpi	r24, 0x66	; 102
    317c:	09 f0       	breq	.+2      	; 0x3180 <vDisplayWriteStringAtPos+0xb2>
    317e:	df c2       	rjmp	.+1470   	; 0x373e <vDisplayWriteStringAtPos+0x670>
    3180:	8c c0       	rjmp	.+280    	; 0x329a <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    3182:	f4 01       	movw	r30, r8
    3184:	ec 56       	subi	r30, 0x6C	; 108
    3186:	f3 4d       	sbci	r31, 0xD3	; 211
    3188:	95 e2       	ldi	r25, 0x25	; 37
    318a:	90 83       	st	Z, r25
				length++;
    318c:	af ef       	ldi	r26, 0xFF	; 255
    318e:	8a 1a       	sub	r8, r26
    3190:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3192:	d2 01       	movw	r26, r4
    3194:	d5 c2       	rjmp	.+1450   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    3196:	f4 01       	movw	r30, r8
    3198:	ec 56       	subi	r30, 0x6C	; 108
    319a:	f3 4d       	sbci	r31, 0xD3	; 211
    319c:	d7 01       	movw	r26, r14
    319e:	8c 91       	ld	r24, X
    31a0:	80 83       	st	Z, r24
				length++;
    31a2:	bf ef       	ldi	r27, 0xFF	; 255
    31a4:	8b 1a       	sub	r8, r27
    31a6:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    31a8:	f7 01       	movw	r30, r14
    31aa:	32 96       	adiw	r30, 0x02	; 2
    31ac:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    31ae:	d2 01       	movw	r26, r4
    31b0:	c7 c2       	rjmp	.+1422   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    31b2:	a7 01       	movw	r20, r14
    31b4:	4e 5f       	subi	r20, 0xFE	; 254
    31b6:	5f 4f       	sbci	r21, 0xFF	; 255
    31b8:	d7 01       	movw	r26, r14
    31ba:	8d 91       	ld	r24, X+
    31bc:	9c 91       	ld	r25, X
    31be:	9c 01       	movw	r18, r24
    31c0:	b4 01       	movw	r22, r8
    31c2:	f4 01       	movw	r30, r8
    31c4:	ec 56       	subi	r30, 0x6C	; 108
    31c6:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    31c8:	00 e0       	ldi	r16, 0x00	; 0
    31ca:	10 e0       	ldi	r17, 0x00	; 0
    31cc:	06 c0       	rjmp	.+12     	; 0x31da <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    31ce:	d9 01       	movw	r26, r18
    31d0:	fd 90       	ld	r15, X+
    31d2:	9d 01       	movw	r18, r26
    31d4:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    31d6:	0f 5f       	subi	r16, 0xFF	; 255
    31d8:	1f 4f       	sbci	r17, 0xFF	; 255
    31da:	dc 01       	movw	r26, r24
    31dc:	0d 90       	ld	r0, X+
    31de:	00 20       	and	r0, r0
    31e0:	e9 f7       	brne	.-6      	; 0x31dc <vDisplayWriteStringAtPos+0x10e>
    31e2:	11 97       	sbiw	r26, 0x01	; 1
    31e4:	a8 1b       	sub	r26, r24
    31e6:	b9 0b       	sbc	r27, r25
    31e8:	0a 17       	cp	r16, r26
    31ea:	1b 07       	cpc	r17, r27
    31ec:	80 f3       	brcs	.-32     	; 0x31ce <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    31ee:	4d 01       	movw	r8, r26
    31f0:	86 0e       	add	r8, r22
    31f2:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    31f4:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    31f6:	d2 01       	movw	r26, r4
    31f8:	a3 c2       	rjmp	.+1350   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    31fa:	87 01       	movw	r16, r14
    31fc:	0e 5f       	subi	r16, 0xFE	; 254
    31fe:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    3200:	4a e0       	ldi	r20, 0x0A	; 10
    3202:	b6 01       	movw	r22, r12
    3204:	f7 01       	movw	r30, r14
    3206:	80 81       	ld	r24, Z
    3208:	91 81       	ldd	r25, Z+1	; 0x01
    320a:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <__itoa_ncheck>
    320e:	94 01       	movw	r18, r8
    3210:	d4 01       	movw	r26, r8
    3212:	ac 56       	subi	r26, 0x6C	; 108
    3214:	b3 4d       	sbci	r27, 0xD3	; 211
    3216:	48 ea       	ldi	r20, 0xA8	; 168
    3218:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    321a:	80 e0       	ldi	r24, 0x00	; 0
    321c:	90 e0       	ldi	r25, 0x00	; 0
    321e:	05 c0       	rjmp	.+10     	; 0x322a <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    3220:	fa 01       	movw	r30, r20
    3222:	61 91       	ld	r22, Z+
    3224:	af 01       	movw	r20, r30
    3226:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    3228:	01 96       	adiw	r24, 0x01	; 1
    322a:	f6 01       	movw	r30, r12
    322c:	01 90       	ld	r0, Z+
    322e:	00 20       	and	r0, r0
    3230:	e9 f7       	brne	.-6      	; 0x322c <vDisplayWriteStringAtPos+0x15e>
    3232:	31 97       	sbiw	r30, 0x01	; 1
    3234:	e8 5a       	subi	r30, 0xA8	; 168
    3236:	fc 42       	sbci	r31, 0x2C	; 44
    3238:	8e 17       	cp	r24, r30
    323a:	9f 07       	cpc	r25, r31
    323c:	88 f3       	brcs	.-30     	; 0x3220 <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    323e:	4f 01       	movw	r8, r30
    3240:	82 0e       	add	r8, r18
    3242:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    3244:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3246:	d2 01       	movw	r26, r4
    3248:	7b c2       	rjmp	.+1270   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    324a:	87 01       	movw	r16, r14
    324c:	0e 5f       	subi	r16, 0xFE	; 254
    324e:	1f 4f       	sbci	r17, 0xFF	; 255
    3250:	40 e1       	ldi	r20, 0x10	; 16
    3252:	b6 01       	movw	r22, r12
    3254:	d7 01       	movw	r26, r14
    3256:	8d 91       	ld	r24, X+
    3258:	9c 91       	ld	r25, X
    325a:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <__itoa_ncheck>
    325e:	94 01       	movw	r18, r8
    3260:	f4 01       	movw	r30, r8
    3262:	ec 56       	subi	r30, 0x6C	; 108
    3264:	f3 4d       	sbci	r31, 0xD3	; 211
    3266:	48 ea       	ldi	r20, 0xA8	; 168
    3268:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    326a:	80 e0       	ldi	r24, 0x00	; 0
    326c:	90 e0       	ldi	r25, 0x00	; 0
    326e:	05 c0       	rjmp	.+10     	; 0x327a <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    3270:	da 01       	movw	r26, r20
    3272:	6d 91       	ld	r22, X+
    3274:	ad 01       	movw	r20, r26
    3276:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    3278:	01 96       	adiw	r24, 0x01	; 1
    327a:	d6 01       	movw	r26, r12
    327c:	0d 90       	ld	r0, X+
    327e:	00 20       	and	r0, r0
    3280:	e9 f7       	brne	.-6      	; 0x327c <vDisplayWriteStringAtPos+0x1ae>
    3282:	11 97       	sbiw	r26, 0x01	; 1
    3284:	a8 5a       	subi	r26, 0xA8	; 168
    3286:	bc 42       	sbci	r27, 0x2C	; 44
    3288:	8a 17       	cp	r24, r26
    328a:	9b 07       	cpc	r25, r27
    328c:	88 f3       	brcs	.-30     	; 0x3270 <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    328e:	4d 01       	movw	r8, r26
    3290:	82 0e       	add	r8, r18
    3292:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3294:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3296:	d2 01       	movw	r26, r4
    3298:	53 c2       	rjmp	.+1190   	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    329a:	17 01       	movw	r2, r14
    329c:	b4 e0       	ldi	r27, 0x04	; 4
    329e:	2b 0e       	add	r2, r27
    32a0:	31 1c       	adc	r3, r1
    32a2:	d7 01       	movw	r26, r14
    32a4:	8d 91       	ld	r24, X+
    32a6:	9d 91       	ld	r25, X+
    32a8:	0d 90       	ld	r0, X+
    32aa:	bc 91       	ld	r27, X
    32ac:	a0 2d       	mov	r26, r0
    32ae:	8f 8b       	std	Y+23, r24	; 0x17
    32b0:	98 8f       	std	Y+24, r25	; 0x18
    32b2:	a9 8f       	std	Y+25, r26	; 0x19
    32b4:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    32b6:	20 e0       	ldi	r18, 0x00	; 0
    32b8:	30 e0       	ldi	r19, 0x00	; 0
    32ba:	a9 01       	movw	r20, r18
    32bc:	bc 01       	movw	r22, r24
    32be:	cd 01       	movw	r24, r26
    32c0:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    32c4:	81 11       	cpse	r24, r1
    32c6:	05 c0       	rjmp	.+10     	; 0x32d2 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    32c8:	20 e3       	ldi	r18, 0x30	; 48
    32ca:	f6 01       	movw	r30, r12
    32cc:	20 83       	st	Z, r18
        buffer[1] = '\0';
    32ce:	11 82       	std	Z+1, r1	; 0x01
    32d0:	04 c1       	rjmp	.+520    	; 0x34da <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    32d2:	20 e0       	ldi	r18, 0x00	; 0
    32d4:	30 e0       	ldi	r19, 0x00	; 0
    32d6:	a9 01       	movw	r20, r18
    32d8:	6f 89       	ldd	r22, Y+23	; 0x17
    32da:	78 8d       	ldd	r23, Y+24	; 0x18
    32dc:	89 8d       	ldd	r24, Y+25	; 0x19
    32de:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32e0:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    32e4:	88 23       	and	r24, r24
    32e6:	9c f4       	brge	.+38     	; 0x330e <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    32e8:	ed e2       	ldi	r30, 0x2D	; 45
    32ea:	d6 01       	movw	r26, r12
    32ec:	ec 93       	st	X, r30
        value = -value;
    32ee:	8f 89       	ldd	r24, Y+23	; 0x17
    32f0:	98 8d       	ldd	r25, Y+24	; 0x18
    32f2:	a9 8d       	ldd	r26, Y+25	; 0x19
    32f4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    32f6:	b0 58       	subi	r27, 0x80	; 128
    32f8:	8f 8b       	std	Y+23, r24	; 0x17
    32fa:	98 8f       	std	Y+24, r25	; 0x18
    32fc:	a9 8f       	std	Y+25, r26	; 0x19
    32fe:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    3300:	0f 2e       	mov	r0, r31
    3302:	f9 ea       	ldi	r31, 0xA9	; 169
    3304:	6f 2e       	mov	r6, r31
    3306:	fc e2       	ldi	r31, 0x2C	; 44
    3308:	7f 2e       	mov	r7, r31
    330a:	f0 2d       	mov	r31, r0
    330c:	01 c0       	rjmp	.+2      	; 0x3310 <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    330e:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3310:	20 e0       	ldi	r18, 0x00	; 0
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	40 e8       	ldi	r20, 0x80	; 128
    3316:	5f e3       	ldi	r21, 0x3F	; 63
    3318:	6f 89       	ldd	r22, Y+23	; 0x17
    331a:	78 8d       	ldd	r23, Y+24	; 0x18
    331c:	89 8d       	ldd	r24, Y+25	; 0x19
    331e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3320:	0e 94 fc 1d 	call	0x3bf8	; 0x3bf8 <__gesf2>
    3324:	88 23       	and	r24, r24
    3326:	0c f4       	brge	.+2      	; 0x332a <vDisplayWriteStringAtPos+0x25c>
    3328:	44 c2       	rjmp	.+1160   	; 0x37b2 <vDisplayWriteStringAtPos+0x6e4>
    332a:	00 e0       	ldi	r16, 0x00	; 0
    332c:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    332e:	20 e0       	ldi	r18, 0x00	; 0
    3330:	30 e0       	ldi	r19, 0x00	; 0
    3332:	40 e2       	ldi	r20, 0x20	; 32
    3334:	51 e4       	ldi	r21, 0x41	; 65
    3336:	6f 89       	ldd	r22, Y+23	; 0x17
    3338:	78 8d       	ldd	r23, Y+24	; 0x18
    333a:	89 8d       	ldd	r24, Y+25	; 0x19
    333c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    333e:	0e 94 a2 1c 	call	0x3944	; 0x3944 <__divsf3>
    3342:	6f 8b       	std	Y+23, r22	; 0x17
    3344:	78 8f       	std	Y+24, r23	; 0x18
    3346:	89 8f       	std	Y+25, r24	; 0x19
    3348:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    334a:	0f 5f       	subi	r16, 0xFF	; 255
    334c:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    334e:	20 e0       	ldi	r18, 0x00	; 0
    3350:	30 e0       	ldi	r19, 0x00	; 0
    3352:	40 e8       	ldi	r20, 0x80	; 128
    3354:	5f e3       	ldi	r21, 0x3F	; 63
    3356:	0e 94 fc 1d 	call	0x3bf8	; 0x3bf8 <__gesf2>
    335a:	88 23       	and	r24, r24
    335c:	44 f7       	brge	.-48     	; 0x332e <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    335e:	2d ec       	ldi	r18, 0xCD	; 205
    3360:	3c ec       	ldi	r19, 0xCC	; 204
    3362:	4c ec       	ldi	r20, 0xCC	; 204
    3364:	5d e3       	ldi	r21, 0x3D	; 61
    3366:	6f 89       	ldd	r22, Y+23	; 0x17
    3368:	78 8d       	ldd	r23, Y+24	; 0x18
    336a:	89 8d       	ldd	r24, Y+25	; 0x19
    336c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    336e:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    3372:	88 23       	and	r24, r24
    3374:	1c f0       	brlt	.+6      	; 0x337c <vDisplayWriteStringAtPos+0x2ae>
    3376:	1a c0       	rjmp	.+52     	; 0x33ac <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3378:	00 e0       	ldi	r16, 0x00	; 0
    337a:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    337c:	20 e0       	ldi	r18, 0x00	; 0
    337e:	30 e0       	ldi	r19, 0x00	; 0
    3380:	40 e2       	ldi	r20, 0x20	; 32
    3382:	51 e4       	ldi	r21, 0x41	; 65
    3384:	6f 89       	ldd	r22, Y+23	; 0x17
    3386:	78 8d       	ldd	r23, Y+24	; 0x18
    3388:	89 8d       	ldd	r24, Y+25	; 0x19
    338a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    338c:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    3390:	6f 8b       	std	Y+23, r22	; 0x17
    3392:	78 8f       	std	Y+24, r23	; 0x18
    3394:	89 8f       	std	Y+25, r24	; 0x19
    3396:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3398:	01 50       	subi	r16, 0x01	; 1
    339a:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    339c:	2d ec       	ldi	r18, 0xCD	; 205
    339e:	3c ec       	ldi	r19, 0xCC	; 204
    33a0:	4c ec       	ldi	r20, 0xCC	; 204
    33a2:	5d e3       	ldi	r21, 0x3D	; 61
    33a4:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    33a8:	88 23       	and	r24, r24
    33aa:	44 f3       	brlt	.-48     	; 0x337c <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    33ac:	10 16       	cp	r1, r16
    33ae:	11 06       	cpc	r1, r17
    33b0:	ac f5       	brge	.+106    	; 0x341c <vDisplayWriteStringAtPos+0x34e>
    33b2:	73 01       	movw	r14, r6
    33b4:	d3 01       	movw	r26, r6
    33b6:	a0 0f       	add	r26, r16
    33b8:	b1 1f       	adc	r27, r17
    33ba:	ac 8f       	std	Y+28, r26	; 0x1c
    33bc:	bd 8f       	std	Y+29, r27	; 0x1d
    33be:	3d 01       	movw	r6, r26
    33c0:	6f 89       	ldd	r22, Y+23	; 0x17
    33c2:	78 8d       	ldd	r23, Y+24	; 0x18
    33c4:	89 8d       	ldd	r24, Y+25	; 0x19
    33c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    33c8:	20 e0       	ldi	r18, 0x00	; 0
    33ca:	30 e0       	ldi	r19, 0x00	; 0
    33cc:	40 e2       	ldi	r20, 0x20	; 32
    33ce:	51 e4       	ldi	r21, 0x41	; 65
    33d0:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    33d4:	6f 8b       	std	Y+23, r22	; 0x17
    33d6:	78 8f       	std	Y+24, r23	; 0x18
    33d8:	89 8f       	std	Y+25, r24	; 0x19
    33da:	9a 8f       	std	Y+26, r25	; 0x1a
    33dc:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <__fixsfsi>
        *buffer++ = digit + '0';
    33e0:	20 e3       	ldi	r18, 0x30	; 48
    33e2:	26 0f       	add	r18, r22
    33e4:	f7 01       	movw	r30, r14
    33e6:	21 93       	st	Z+, r18
    33e8:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    33ea:	07 2e       	mov	r0, r23
    33ec:	00 0c       	add	r0, r0
    33ee:	88 0b       	sbc	r24, r24
    33f0:	99 0b       	sbc	r25, r25
    33f2:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__floatsisf>
    33f6:	9b 01       	movw	r18, r22
    33f8:	ac 01       	movw	r20, r24
    33fa:	6f 89       	ldd	r22, Y+23	; 0x17
    33fc:	78 8d       	ldd	r23, Y+24	; 0x18
    33fe:	89 8d       	ldd	r24, Y+25	; 0x19
    3400:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3402:	0e 94 30 1c 	call	0x3860	; 0x3860 <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3406:	e6 14       	cp	r14, r6
    3408:	f7 04       	cpc	r15, r7
    340a:	f1 f6       	brne	.-68     	; 0x33c8 <vDisplayWriteStringAtPos+0x2fa>
    340c:	6f 8b       	std	Y+23, r22	; 0x17
    340e:	78 8f       	std	Y+24, r23	; 0x18
    3410:	89 8f       	std	Y+25, r24	; 0x19
    3412:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    3414:	01 15       	cp	r16, r1
    3416:	11 05       	cpc	r17, r1
    3418:	89 f4       	brne	.+34     	; 0x343c <vDisplayWriteStringAtPos+0x36e>
    341a:	db c1       	rjmp	.+950    	; 0x37d2 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    341c:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    341e:	e0 e3       	ldi	r30, 0x30	; 48
    3420:	d3 01       	movw	r26, r6
    3422:	ec 93       	st	X, r30

    *buffer++ = '.';
    3424:	73 01       	movw	r14, r6
    3426:	f2 e0       	ldi	r31, 0x02	; 2
    3428:	ef 0e       	add	r14, r31
    342a:	f1 1c       	adc	r15, r1
    342c:	2e e2       	ldi	r18, 0x2E	; 46
    342e:	11 96       	adiw	r26, 0x01	; 1
    3430:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    3432:	99 23       	and	r25, r25
    3434:	6c f0       	brlt	.+26     	; 0x3450 <vDisplayWriteStringAtPos+0x382>
    3436:	00 e0       	ldi	r16, 0x00	; 0
    3438:	10 e0       	ldi	r17, 0x00	; 0
    343a:	1f c0       	rjmp	.+62     	; 0x347a <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    343c:	ec 8c       	ldd	r14, Y+28	; 0x1c
    343e:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3440:	3f ef       	ldi	r19, 0xFF	; 255
    3442:	e3 1a       	sub	r14, r19
    3444:	f3 0a       	sbc	r15, r19
    3446:	ee e2       	ldi	r30, 0x2E	; 46
    3448:	ac 8d       	ldd	r26, Y+28	; 0x1c
    344a:	bd 8d       	ldd	r27, Y+29	; 0x1d
    344c:	ec 93       	st	X, r30
    344e:	12 c0       	rjmp	.+36     	; 0x3474 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    3450:	00 e0       	ldi	r16, 0x00	; 0
    3452:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    3454:	ff ef       	ldi	r31, 0xFF	; 255
    3456:	ef 1a       	sub	r14, r31
    3458:	ff 0a       	sbc	r15, r31
    345a:	f7 01       	movw	r30, r14
    345c:	31 97       	sbiw	r30, 0x01	; 1
    345e:	20 e3       	ldi	r18, 0x30	; 48
    3460:	20 83       	st	Z, r18
        --exponent;
    3462:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    3464:	0f 5f       	subi	r16, 0xFF	; 255
    3466:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3468:	99 23       	and	r25, r25
    346a:	24 f4       	brge	.+8      	; 0x3474 <vDisplayWriteStringAtPos+0x3a6>
    346c:	04 30       	cpi	r16, 0x04	; 4
    346e:	11 05       	cpc	r17, r1
    3470:	8c f3       	brlt	.-30     	; 0x3454 <vDisplayWriteStringAtPos+0x386>
    3472:	31 c0       	rjmp	.+98     	; 0x34d6 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3474:	04 30       	cpi	r16, 0x04	; 4
    3476:	11 05       	cpc	r17, r1
    3478:	74 f5       	brge	.+92     	; 0x34d6 <vDisplayWriteStringAtPos+0x408>
    347a:	37 01       	movw	r6, r14
    347c:	84 e0       	ldi	r24, 0x04	; 4
    347e:	90 e0       	ldi	r25, 0x00	; 0
    3480:	80 1b       	sub	r24, r16
    3482:	91 0b       	sbc	r25, r17
    3484:	e8 0e       	add	r14, r24
    3486:	f9 1e       	adc	r15, r25
    3488:	87 01       	movw	r16, r14
    348a:	6f 89       	ldd	r22, Y+23	; 0x17
    348c:	78 8d       	ldd	r23, Y+24	; 0x18
    348e:	89 8d       	ldd	r24, Y+25	; 0x19
    3490:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    3492:	20 e0       	ldi	r18, 0x00	; 0
    3494:	30 e0       	ldi	r19, 0x00	; 0
    3496:	40 e2       	ldi	r20, 0x20	; 32
    3498:	51 e4       	ldi	r21, 0x41	; 65
    349a:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    349e:	6f 8b       	std	Y+23, r22	; 0x17
    34a0:	78 8f       	std	Y+24, r23	; 0x18
    34a2:	89 8f       	std	Y+25, r24	; 0x19
    34a4:	9a 8f       	std	Y+26, r25	; 0x1a
    34a6:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <__fixsfsi>
        *buffer++ = digit + '0';
    34aa:	20 e3       	ldi	r18, 0x30	; 48
    34ac:	26 0f       	add	r18, r22
    34ae:	d3 01       	movw	r26, r6
    34b0:	2d 93       	st	X+, r18
    34b2:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    34b4:	07 2e       	mov	r0, r23
    34b6:	00 0c       	add	r0, r0
    34b8:	88 0b       	sbc	r24, r24
    34ba:	99 0b       	sbc	r25, r25
    34bc:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__floatsisf>
    34c0:	9b 01       	movw	r18, r22
    34c2:	ac 01       	movw	r20, r24
    34c4:	6f 89       	ldd	r22, Y+23	; 0x17
    34c6:	78 8d       	ldd	r23, Y+24	; 0x18
    34c8:	89 8d       	ldd	r24, Y+25	; 0x19
    34ca:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34cc:	0e 94 30 1c 	call	0x3860	; 0x3860 <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    34d0:	60 16       	cp	r6, r16
    34d2:	71 06       	cpc	r7, r17
    34d4:	f1 f6       	brne	.-68     	; 0x3492 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    34d6:	f7 01       	movw	r30, r14
    34d8:	10 82       	st	Z, r1
    34da:	94 01       	movw	r18, r8
    34dc:	f4 01       	movw	r30, r8
    34de:	ec 56       	subi	r30, 0x6C	; 108
    34e0:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    34e2:	48 ea       	ldi	r20, 0xA8	; 168
    34e4:	5c e2       	ldi	r21, 0x2C	; 44
    34e6:	80 e0       	ldi	r24, 0x00	; 0
    34e8:	90 e0       	ldi	r25, 0x00	; 0
    34ea:	05 c0       	rjmp	.+10     	; 0x34f6 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    34ec:	da 01       	movw	r26, r20
    34ee:	6d 91       	ld	r22, X+
    34f0:	ad 01       	movw	r20, r26
    34f2:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    34f4:	01 96       	adiw	r24, 0x01	; 1
    34f6:	d6 01       	movw	r26, r12
    34f8:	0d 90       	ld	r0, X+
    34fa:	00 20       	and	r0, r0
    34fc:	e9 f7       	brne	.-6      	; 0x34f8 <vDisplayWriteStringAtPos+0x42a>
    34fe:	11 97       	sbiw	r26, 0x01	; 1
    3500:	a8 5a       	subi	r26, 0xA8	; 168
    3502:	bc 42       	sbci	r27, 0x2C	; 44
    3504:	8a 17       	cp	r24, r26
    3506:	9b 07       	cpc	r25, r27
    3508:	88 f3       	brcs	.-30     	; 0x34ec <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    350a:	4d 01       	movw	r8, r26
    350c:	82 0e       	add	r8, r18
    350e:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    3510:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3512:	d2 01       	movw	r26, r4
    3514:	15 c1       	rjmp	.+554    	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3516:	17 01       	movw	r2, r14
    3518:	b4 e0       	ldi	r27, 0x04	; 4
    351a:	2b 0e       	add	r2, r27
    351c:	31 1c       	adc	r3, r1
    351e:	d7 01       	movw	r26, r14
    3520:	8d 91       	ld	r24, X+
    3522:	9d 91       	ld	r25, X+
    3524:	0d 90       	ld	r0, X+
    3526:	bc 91       	ld	r27, X
    3528:	a0 2d       	mov	r26, r0
    352a:	8f 8b       	std	Y+23, r24	; 0x17
    352c:	98 8f       	std	Y+24, r25	; 0x18
    352e:	a9 8f       	std	Y+25, r26	; 0x19
    3530:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    3532:	20 e0       	ldi	r18, 0x00	; 0
    3534:	30 e0       	ldi	r19, 0x00	; 0
    3536:	a9 01       	movw	r20, r18
    3538:	bc 01       	movw	r22, r24
    353a:	cd 01       	movw	r24, r26
    353c:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    3540:	81 11       	cpse	r24, r1
    3542:	05 c0       	rjmp	.+10     	; 0x354e <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    3544:	20 e3       	ldi	r18, 0x30	; 48
    3546:	f6 01       	movw	r30, r12
    3548:	20 83       	st	Z, r18
        buffer[1] = '\0';
    354a:	11 82       	std	Z+1, r1	; 0x01
    354c:	ca c0       	rjmp	.+404    	; 0x36e2 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    354e:	20 e0       	ldi	r18, 0x00	; 0
    3550:	30 e0       	ldi	r19, 0x00	; 0
    3552:	a9 01       	movw	r20, r18
    3554:	6f 89       	ldd	r22, Y+23	; 0x17
    3556:	78 8d       	ldd	r23, Y+24	; 0x18
    3558:	89 8d       	ldd	r24, Y+25	; 0x19
    355a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    355c:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    3560:	88 23       	and	r24, r24
    3562:	9c f4       	brge	.+38     	; 0x358a <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    3564:	ed e2       	ldi	r30, 0x2D	; 45
    3566:	d6 01       	movw	r26, r12
    3568:	ec 93       	st	X, r30
        value = -value;
    356a:	8f 89       	ldd	r24, Y+23	; 0x17
    356c:	98 8d       	ldd	r25, Y+24	; 0x18
    356e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3570:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3572:	b0 58       	subi	r27, 0x80	; 128
    3574:	8f 8b       	std	Y+23, r24	; 0x17
    3576:	98 8f       	std	Y+24, r25	; 0x18
    3578:	a9 8f       	std	Y+25, r26	; 0x19
    357a:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    357c:	0f 2e       	mov	r0, r31
    357e:	f9 ea       	ldi	r31, 0xA9	; 169
    3580:	6f 2e       	mov	r6, r31
    3582:	fc e2       	ldi	r31, 0x2C	; 44
    3584:	7f 2e       	mov	r7, r31
    3586:	f0 2d       	mov	r31, r0
    3588:	01 c0       	rjmp	.+2      	; 0x358c <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    358a:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    358c:	20 e0       	ldi	r18, 0x00	; 0
    358e:	30 e0       	ldi	r19, 0x00	; 0
    3590:	40 e8       	ldi	r20, 0x80	; 128
    3592:	5f e3       	ldi	r21, 0x3F	; 63
    3594:	6f 89       	ldd	r22, Y+23	; 0x17
    3596:	78 8d       	ldd	r23, Y+24	; 0x18
    3598:	89 8d       	ldd	r24, Y+25	; 0x19
    359a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    359c:	0e 94 fc 1d 	call	0x3bf8	; 0x3bf8 <__gesf2>
    35a0:	88 23       	and	r24, r24
    35a2:	dc f0       	brlt	.+54     	; 0x35da <vDisplayWriteStringAtPos+0x50c>
    35a4:	00 e0       	ldi	r16, 0x00	; 0
    35a6:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    35a8:	20 e0       	ldi	r18, 0x00	; 0
    35aa:	30 e0       	ldi	r19, 0x00	; 0
    35ac:	40 e2       	ldi	r20, 0x20	; 32
    35ae:	51 e4       	ldi	r21, 0x41	; 65
    35b0:	6f 89       	ldd	r22, Y+23	; 0x17
    35b2:	78 8d       	ldd	r23, Y+24	; 0x18
    35b4:	89 8d       	ldd	r24, Y+25	; 0x19
    35b6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    35b8:	0e 94 a2 1c 	call	0x3944	; 0x3944 <__divsf3>
    35bc:	6f 8b       	std	Y+23, r22	; 0x17
    35be:	78 8f       	std	Y+24, r23	; 0x18
    35c0:	89 8f       	std	Y+25, r24	; 0x19
    35c2:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    35c4:	0f 5f       	subi	r16, 0xFF	; 255
    35c6:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    35c8:	20 e0       	ldi	r18, 0x00	; 0
    35ca:	30 e0       	ldi	r19, 0x00	; 0
    35cc:	40 e8       	ldi	r20, 0x80	; 128
    35ce:	5f e3       	ldi	r21, 0x3F	; 63
    35d0:	0e 94 fc 1d 	call	0x3bf8	; 0x3bf8 <__gesf2>
    35d4:	88 23       	and	r24, r24
    35d6:	44 f7       	brge	.-48     	; 0x35a8 <vDisplayWriteStringAtPos+0x4da>
    35d8:	02 c0       	rjmp	.+4      	; 0x35de <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    35da:	00 e0       	ldi	r16, 0x00	; 0
    35dc:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    35de:	2d ec       	ldi	r18, 0xCD	; 205
    35e0:	3c ec       	ldi	r19, 0xCC	; 204
    35e2:	4c ec       	ldi	r20, 0xCC	; 204
    35e4:	5d e3       	ldi	r21, 0x3D	; 61
    35e6:	6f 89       	ldd	r22, Y+23	; 0x17
    35e8:	78 8d       	ldd	r23, Y+24	; 0x18
    35ea:	89 8d       	ldd	r24, Y+25	; 0x19
    35ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    35ee:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    35f2:	88 23       	and	r24, r24
    35f4:	c4 f4       	brge	.+48     	; 0x3626 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	40 e2       	ldi	r20, 0x20	; 32
    35fc:	51 e4       	ldi	r21, 0x41	; 65
    35fe:	6f 89       	ldd	r22, Y+23	; 0x17
    3600:	78 8d       	ldd	r23, Y+24	; 0x18
    3602:	89 8d       	ldd	r24, Y+25	; 0x19
    3604:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3606:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    360a:	6f 8b       	std	Y+23, r22	; 0x17
    360c:	78 8f       	std	Y+24, r23	; 0x18
    360e:	89 8f       	std	Y+25, r24	; 0x19
    3610:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3612:	01 50       	subi	r16, 0x01	; 1
    3614:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3616:	2d ec       	ldi	r18, 0xCD	; 205
    3618:	3c ec       	ldi	r19, 0xCC	; 204
    361a:	4c ec       	ldi	r20, 0xCC	; 204
    361c:	5d e3       	ldi	r21, 0x3D	; 61
    361e:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    3622:	88 23       	and	r24, r24
    3624:	44 f3       	brlt	.-48     	; 0x35f6 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    3626:	20 e0       	ldi	r18, 0x00	; 0
    3628:	30 e0       	ldi	r19, 0x00	; 0
    362a:	40 e2       	ldi	r20, 0x20	; 32
    362c:	51 e4       	ldi	r21, 0x41	; 65
    362e:	6f 89       	ldd	r22, Y+23	; 0x17
    3630:	78 8d       	ldd	r23, Y+24	; 0x18
    3632:	89 8d       	ldd	r24, Y+25	; 0x19
    3634:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3636:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    363a:	6f 8b       	std	Y+23, r22	; 0x17
    363c:	78 8f       	std	Y+24, r23	; 0x18
    363e:	89 8f       	std	Y+25, r24	; 0x19
    3640:	9a 8f       	std	Y+26, r25	; 0x1a
    3642:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <__fixsfsi>
    *buffer++ = digit + '0';
    3646:	20 e3       	ldi	r18, 0x30	; 48
    3648:	26 0f       	add	r18, r22
    364a:	d3 01       	movw	r26, r6
    364c:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    364e:	07 2e       	mov	r0, r23
    3650:	00 0c       	add	r0, r0
    3652:	88 0b       	sbc	r24, r24
    3654:	99 0b       	sbc	r25, r25
    3656:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__floatsisf>
    365a:	9b 01       	movw	r18, r22
    365c:	ac 01       	movw	r20, r24
    365e:	6f 89       	ldd	r22, Y+23	; 0x17
    3660:	78 8d       	ldd	r23, Y+24	; 0x18
    3662:	89 8d       	ldd	r24, Y+25	; 0x19
    3664:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3666:	0e 94 30 1c 	call	0x3860	; 0x3860 <__subsf3>
    --exponent;
    366a:	f8 01       	movw	r30, r16
    366c:	31 97       	sbiw	r30, 0x01	; 1
    366e:	ec 8f       	std	Y+28, r30	; 0x1c
    3670:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    3672:	ee e2       	ldi	r30, 0x2E	; 46
    3674:	d3 01       	movw	r26, r6
    3676:	11 96       	adiw	r26, 0x01	; 1
    3678:	ec 93       	st	X, r30
    367a:	83 01       	movw	r16, r6
    367c:	0e 5f       	subi	r16, 0xFE	; 254
    367e:	1f 4f       	sbci	r17, 0xFF	; 255
    3680:	73 01       	movw	r14, r6
    3682:	f6 e0       	ldi	r31, 0x06	; 6
    3684:	ef 0e       	add	r14, r31
    3686:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3688:	20 e0       	ldi	r18, 0x00	; 0
    368a:	30 e0       	ldi	r19, 0x00	; 0
    368c:	40 e2       	ldi	r20, 0x20	; 32
    368e:	51 e4       	ldi	r21, 0x41	; 65
    3690:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <__mulsf3>
    3694:	6f 8b       	std	Y+23, r22	; 0x17
    3696:	78 8f       	std	Y+24, r23	; 0x18
    3698:	89 8f       	std	Y+25, r24	; 0x19
    369a:	9a 8f       	std	Y+26, r25	; 0x1a
    369c:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <__fixsfsi>
        *buffer++ = digit + '0';
    36a0:	20 e3       	ldi	r18, 0x30	; 48
    36a2:	26 0f       	add	r18, r22
    36a4:	d8 01       	movw	r26, r16
    36a6:	2d 93       	st	X+, r18
    36a8:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    36aa:	07 2e       	mov	r0, r23
    36ac:	00 0c       	add	r0, r0
    36ae:	88 0b       	sbc	r24, r24
    36b0:	99 0b       	sbc	r25, r25
    36b2:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__floatsisf>
    36b6:	9b 01       	movw	r18, r22
    36b8:	ac 01       	movw	r20, r24
    36ba:	6f 89       	ldd	r22, Y+23	; 0x17
    36bc:	78 8d       	ldd	r23, Y+24	; 0x18
    36be:	89 8d       	ldd	r24, Y+25	; 0x19
    36c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    36c2:	0e 94 30 1c 	call	0x3860	; 0x3860 <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    36c6:	0e 15       	cp	r16, r14
    36c8:	1f 05       	cpc	r17, r15
    36ca:	f1 f6       	brne	.-68     	; 0x3688 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    36cc:	25 e6       	ldi	r18, 0x65	; 101
    36ce:	f3 01       	movw	r30, r6
    36d0:	26 83       	std	Z+6, r18	; 0x06
    36d2:	b3 01       	movw	r22, r6
    36d4:	69 5f       	subi	r22, 0xF9	; 249
    36d6:	7f 4f       	sbci	r23, 0xFF	; 255
    36d8:	4a e0       	ldi	r20, 0x0A	; 10
    36da:	8c 8d       	ldd	r24, Y+28	; 0x1c
    36dc:	9d 8d       	ldd	r25, Y+29	; 0x1d
    36de:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <__itoa_ncheck>
    36e2:	94 01       	movw	r18, r8
    36e4:	f4 01       	movw	r30, r8
    36e6:	ec 56       	subi	r30, 0x6C	; 108
    36e8:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    36ea:	48 ea       	ldi	r20, 0xA8	; 168
    36ec:	5c e2       	ldi	r21, 0x2C	; 44
    36ee:	80 e0       	ldi	r24, 0x00	; 0
    36f0:	90 e0       	ldi	r25, 0x00	; 0
    36f2:	05 c0       	rjmp	.+10     	; 0x36fe <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    36f4:	da 01       	movw	r26, r20
    36f6:	6d 91       	ld	r22, X+
    36f8:	ad 01       	movw	r20, r26
    36fa:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    36fc:	01 96       	adiw	r24, 0x01	; 1
    36fe:	d6 01       	movw	r26, r12
    3700:	0d 90       	ld	r0, X+
    3702:	00 20       	and	r0, r0
    3704:	e9 f7       	brne	.-6      	; 0x3700 <vDisplayWriteStringAtPos+0x632>
    3706:	11 97       	sbiw	r26, 0x01	; 1
    3708:	a8 5a       	subi	r26, 0xA8	; 168
    370a:	bc 42       	sbci	r27, 0x2C	; 44
    370c:	8a 17       	cp	r24, r26
    370e:	9b 07       	cpc	r25, r27
    3710:	88 f3       	brcs	.-30     	; 0x36f4 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3712:	4d 01       	movw	r8, r26
    3714:	82 0e       	add	r8, r18
    3716:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3718:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    371a:	d2 01       	movw	r26, r4
    371c:	11 c0       	rjmp	.+34     	; 0x3740 <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    371e:	8a 30       	cpi	r24, 0x0A	; 10
    3720:	29 f0       	breq	.+10     	; 0x372c <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    3722:	f4 01       	movw	r30, r8
    3724:	ec 56       	subi	r30, 0x6C	; 108
    3726:	f3 4d       	sbci	r31, 0xD3	; 211
    3728:	80 83       	st	Z, r24
    372a:	04 c0       	rjmp	.+8      	; 0x3734 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    372c:	f4 01       	movw	r30, r8
    372e:	ec 56       	subi	r30, 0x6C	; 108
    3730:	f3 4d       	sbci	r31, 0xD3	; 211
    3732:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3734:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3736:	ef ef       	ldi	r30, 0xFF	; 255
    3738:	8e 1a       	sub	r8, r30
    373a:	9e 0a       	sbc	r9, r30
    373c:	01 c0       	rjmp	.+2      	; 0x3740 <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    373e:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3740:	8c 91       	ld	r24, X
    3742:	81 11       	cpse	r24, r1
    3744:	01 cd       	rjmp	.-1534   	; 0x3148 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    3746:	8d a9       	ldd	r24, Y+53	; 0x35
    3748:	9e a9       	ldd	r25, Y+54	; 0x36
    374a:	88 0d       	add	r24, r8
    374c:	99 1d       	adc	r25, r9
    374e:	44 97       	sbiw	r24, 0x14	; 20
    3750:	3c f0       	brlt	.+14     	; 0x3760 <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    3752:	84 e1       	ldi	r24, 0x14	; 20
    3754:	90 e0       	ldi	r25, 0x00	; 0
    3756:	4c 01       	movw	r8, r24
    3758:	2d a9       	ldd	r18, Y+53	; 0x35
    375a:	3e a9       	ldd	r19, Y+54	; 0x36
    375c:	82 1a       	sub	r8, r18
    375e:	93 0a       	sbc	r9, r19
    3760:	fe 01       	movw	r30, r28
    3762:	33 96       	adiw	r30, 0x03	; 3
    3764:	ce 01       	movw	r24, r28
    3766:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3768:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    376a:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    376c:	a8 17       	cp	r26, r24
    376e:	b9 07       	cpc	r27, r25
    3770:	e1 f7       	brne	.-8      	; 0x376a <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    3772:	3b 8d       	ldd	r19, Y+27	; 0x1b
    3774:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    3776:	8d a9       	ldd	r24, Y+53	; 0x35
    3778:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    377a:	18 14       	cp	r1, r8
    377c:	19 04       	cpc	r1, r9
    377e:	5c f4       	brge	.+22     	; 0x3796 <vDisplayWriteStringAtPos+0x6c8>
    3780:	ce 01       	movw	r24, r28
    3782:	88 0d       	add	r24, r8
    3784:	99 1d       	adc	r25, r9
    3786:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3788:	d5 01       	movw	r26, r10
    378a:	2d 91       	ld	r18, X+
    378c:	5d 01       	movw	r10, r26
    378e:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    3790:	8e 17       	cp	r24, r30
    3792:	9f 07       	cpc	r25, r31
    3794:	c9 f7       	brne	.-14     	; 0x3788 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3796:	00 e0       	ldi	r16, 0x00	; 0
    3798:	2f ef       	ldi	r18, 0xFF	; 255
    379a:	3f ef       	ldi	r19, 0xFF	; 255
    379c:	a9 01       	movw	r20, r18
    379e:	be 01       	movw	r22, r28
    37a0:	6f 5f       	subi	r22, 0xFF	; 255
    37a2:	7f 4f       	sbci	r23, 0xFF	; 255
    37a4:	80 91 c1 2c 	lds	r24, 0x2CC1	; 0x802cc1 <displayLineQueue>
    37a8:	90 91 c2 2c 	lds	r25, 0x2CC2	; 0x802cc2 <displayLineQueue+0x1>
    37ac:	0e 94 20 07 	call	0xe40	; 0xe40 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    37b0:	1b c0       	rjmp	.+54     	; 0x37e8 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    37b2:	2d ec       	ldi	r18, 0xCD	; 205
    37b4:	3c ec       	ldi	r19, 0xCC	; 204
    37b6:	4c ec       	ldi	r20, 0xCC	; 204
    37b8:	5d e3       	ldi	r21, 0x3D	; 61
    37ba:	6f 89       	ldd	r22, Y+23	; 0x17
    37bc:	78 8d       	ldd	r23, Y+24	; 0x18
    37be:	89 8d       	ldd	r24, Y+25	; 0x19
    37c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    37c2:	0e 94 9d 1c 	call	0x393a	; 0x393a <__cmpsf2>
    37c6:	88 23       	and	r24, r24
    37c8:	0c f4       	brge	.+2      	; 0x37cc <vDisplayWriteStringAtPos+0x6fe>
    37ca:	d6 cd       	rjmp	.-1108   	; 0x3378 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    37cc:	80 e0       	ldi	r24, 0x00	; 0
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	26 ce       	rjmp	.-948    	; 0x341e <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    37d2:	20 e3       	ldi	r18, 0x30	; 48
    37d4:	ec 8d       	ldd	r30, Y+28	; 0x1c
    37d6:	fd 8d       	ldd	r31, Y+29	; 0x1d
    37d8:	20 83       	st	Z, r18

    *buffer++ = '.';
    37da:	7f 01       	movw	r14, r30
    37dc:	32 e0       	ldi	r19, 0x02	; 2
    37de:	e3 0e       	add	r14, r19
    37e0:	f1 1c       	adc	r15, r1
    37e2:	8e e2       	ldi	r24, 0x2E	; 46
    37e4:	81 83       	std	Z+1, r24	; 0x01
    37e6:	46 ce       	rjmp	.-884    	; 0x3474 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    37e8:	6d 96       	adiw	r28, 0x1d	; 29
    37ea:	cd bf       	out	0x3d, r28	; 61
    37ec:	de bf       	out	0x3e, r29	; 62
    37ee:	df 91       	pop	r29
    37f0:	cf 91       	pop	r28
    37f2:	1f 91       	pop	r17
    37f4:	0f 91       	pop	r16
    37f6:	ff 90       	pop	r15
    37f8:	ef 90       	pop	r14
    37fa:	df 90       	pop	r13
    37fc:	cf 90       	pop	r12
    37fe:	bf 90       	pop	r11
    3800:	af 90       	pop	r10
    3802:	9f 90       	pop	r9
    3804:	8f 90       	pop	r8
    3806:	7f 90       	pop	r7
    3808:	6f 90       	pop	r6
    380a:	5f 90       	pop	r5
    380c:	4f 90       	pop	r4
    380e:	3f 90       	pop	r3
    3810:	2f 90       	pop	r2
    3812:	08 95       	ret

00003814 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3814:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3818:	85 ff       	sbrs	r24, 5
    381a:	05 c0       	rjmp	.+10     	; 0x3826 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    381c:	80 e2       	ldi	r24, 0x20	; 32
    381e:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3826:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    382a:	80 ff       	sbrs	r24, 0
    382c:	05 c0       	rjmp	.+10     	; 0x3838 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    382e:	81 e0       	ldi	r24, 0x01	; 1
    3830:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3834:	82 e0       	ldi	r24, 0x02	; 2
    3836:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3838:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    383c:	84 ff       	sbrs	r24, 4
    383e:	05 c0       	rjmp	.+10     	; 0x384a <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3840:	80 e1       	ldi	r24, 0x10	; 16
    3842:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3846:	83 e0       	ldi	r24, 0x03	; 3
    3848:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    384a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    384e:	81 ff       	sbrs	r24, 1
    3850:	05 c0       	rjmp	.+10     	; 0x385c <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3852:	82 e0       	ldi	r24, 0x02	; 2
    3854:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3858:	84 e0       	ldi	r24, 0x04	; 4
    385a:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    385c:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    385e:	08 95       	ret

00003860 <__subsf3>:
    3860:	50 58       	subi	r21, 0x80	; 128

00003862 <__addsf3>:
    3862:	bb 27       	eor	r27, r27
    3864:	aa 27       	eor	r26, r26
    3866:	0e 94 48 1c 	call	0x3890	; 0x3890 <__addsf3x>
    386a:	0c 94 c2 1d 	jmp	0x3b84	; 0x3b84 <__fp_round>
    386e:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <__fp_pscA>
    3872:	38 f0       	brcs	.+14     	; 0x3882 <__addsf3+0x20>
    3874:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <__fp_pscB>
    3878:	20 f0       	brcs	.+8      	; 0x3882 <__addsf3+0x20>
    387a:	39 f4       	brne	.+14     	; 0x388a <__addsf3+0x28>
    387c:	9f 3f       	cpi	r25, 0xFF	; 255
    387e:	19 f4       	brne	.+6      	; 0x3886 <__addsf3+0x24>
    3880:	26 f4       	brtc	.+8      	; 0x388a <__addsf3+0x28>
    3882:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <__fp_nan>
    3886:	0e f4       	brtc	.+2      	; 0x388a <__addsf3+0x28>
    3888:	e0 95       	com	r30
    388a:	e7 fb       	bst	r30, 7
    388c:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <__fp_inf>

00003890 <__addsf3x>:
    3890:	e9 2f       	mov	r30, r25
    3892:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <__fp_split3>
    3896:	58 f3       	brcs	.-42     	; 0x386e <__addsf3+0xc>
    3898:	ba 17       	cp	r27, r26
    389a:	62 07       	cpc	r22, r18
    389c:	73 07       	cpc	r23, r19
    389e:	84 07       	cpc	r24, r20
    38a0:	95 07       	cpc	r25, r21
    38a2:	20 f0       	brcs	.+8      	; 0x38ac <__addsf3x+0x1c>
    38a4:	79 f4       	brne	.+30     	; 0x38c4 <__addsf3x+0x34>
    38a6:	a6 f5       	brtc	.+104    	; 0x3910 <__addsf3x+0x80>
    38a8:	0c 94 f5 1d 	jmp	0x3bea	; 0x3bea <__fp_zero>
    38ac:	0e f4       	brtc	.+2      	; 0x38b0 <__addsf3x+0x20>
    38ae:	e0 95       	com	r30
    38b0:	0b 2e       	mov	r0, r27
    38b2:	ba 2f       	mov	r27, r26
    38b4:	a0 2d       	mov	r26, r0
    38b6:	0b 01       	movw	r0, r22
    38b8:	b9 01       	movw	r22, r18
    38ba:	90 01       	movw	r18, r0
    38bc:	0c 01       	movw	r0, r24
    38be:	ca 01       	movw	r24, r20
    38c0:	a0 01       	movw	r20, r0
    38c2:	11 24       	eor	r1, r1
    38c4:	ff 27       	eor	r31, r31
    38c6:	59 1b       	sub	r21, r25
    38c8:	99 f0       	breq	.+38     	; 0x38f0 <__addsf3x+0x60>
    38ca:	59 3f       	cpi	r21, 0xF9	; 249
    38cc:	50 f4       	brcc	.+20     	; 0x38e2 <__addsf3x+0x52>
    38ce:	50 3e       	cpi	r21, 0xE0	; 224
    38d0:	68 f1       	brcs	.+90     	; 0x392c <__addsf3x+0x9c>
    38d2:	1a 16       	cp	r1, r26
    38d4:	f0 40       	sbci	r31, 0x00	; 0
    38d6:	a2 2f       	mov	r26, r18
    38d8:	23 2f       	mov	r18, r19
    38da:	34 2f       	mov	r19, r20
    38dc:	44 27       	eor	r20, r20
    38de:	58 5f       	subi	r21, 0xF8	; 248
    38e0:	f3 cf       	rjmp	.-26     	; 0x38c8 <__addsf3x+0x38>
    38e2:	46 95       	lsr	r20
    38e4:	37 95       	ror	r19
    38e6:	27 95       	ror	r18
    38e8:	a7 95       	ror	r26
    38ea:	f0 40       	sbci	r31, 0x00	; 0
    38ec:	53 95       	inc	r21
    38ee:	c9 f7       	brne	.-14     	; 0x38e2 <__addsf3x+0x52>
    38f0:	7e f4       	brtc	.+30     	; 0x3910 <__addsf3x+0x80>
    38f2:	1f 16       	cp	r1, r31
    38f4:	ba 0b       	sbc	r27, r26
    38f6:	62 0b       	sbc	r22, r18
    38f8:	73 0b       	sbc	r23, r19
    38fa:	84 0b       	sbc	r24, r20
    38fc:	ba f0       	brmi	.+46     	; 0x392c <__addsf3x+0x9c>
    38fe:	91 50       	subi	r25, 0x01	; 1
    3900:	a1 f0       	breq	.+40     	; 0x392a <__addsf3x+0x9a>
    3902:	ff 0f       	add	r31, r31
    3904:	bb 1f       	adc	r27, r27
    3906:	66 1f       	adc	r22, r22
    3908:	77 1f       	adc	r23, r23
    390a:	88 1f       	adc	r24, r24
    390c:	c2 f7       	brpl	.-16     	; 0x38fe <__addsf3x+0x6e>
    390e:	0e c0       	rjmp	.+28     	; 0x392c <__addsf3x+0x9c>
    3910:	ba 0f       	add	r27, r26
    3912:	62 1f       	adc	r22, r18
    3914:	73 1f       	adc	r23, r19
    3916:	84 1f       	adc	r24, r20
    3918:	48 f4       	brcc	.+18     	; 0x392c <__addsf3x+0x9c>
    391a:	87 95       	ror	r24
    391c:	77 95       	ror	r23
    391e:	67 95       	ror	r22
    3920:	b7 95       	ror	r27
    3922:	f7 95       	ror	r31
    3924:	9e 3f       	cpi	r25, 0xFE	; 254
    3926:	08 f0       	brcs	.+2      	; 0x392a <__addsf3x+0x9a>
    3928:	b0 cf       	rjmp	.-160    	; 0x388a <__addsf3+0x28>
    392a:	93 95       	inc	r25
    392c:	88 0f       	add	r24, r24
    392e:	08 f0       	brcs	.+2      	; 0x3932 <__addsf3x+0xa2>
    3930:	99 27       	eor	r25, r25
    3932:	ee 0f       	add	r30, r30
    3934:	97 95       	ror	r25
    3936:	87 95       	ror	r24
    3938:	08 95       	ret

0000393a <__cmpsf2>:
    393a:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__fp_cmp>
    393e:	08 f4       	brcc	.+2      	; 0x3942 <__cmpsf2+0x8>
    3940:	81 e0       	ldi	r24, 0x01	; 1
    3942:	08 95       	ret

00003944 <__divsf3>:
    3944:	0e 94 b6 1c 	call	0x396c	; 0x396c <__divsf3x>
    3948:	0c 94 c2 1d 	jmp	0x3b84	; 0x3b84 <__fp_round>
    394c:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <__fp_pscB>
    3950:	58 f0       	brcs	.+22     	; 0x3968 <__divsf3+0x24>
    3952:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <__fp_pscA>
    3956:	40 f0       	brcs	.+16     	; 0x3968 <__divsf3+0x24>
    3958:	29 f4       	brne	.+10     	; 0x3964 <__divsf3+0x20>
    395a:	5f 3f       	cpi	r21, 0xFF	; 255
    395c:	29 f0       	breq	.+10     	; 0x3968 <__divsf3+0x24>
    395e:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <__fp_inf>
    3962:	51 11       	cpse	r21, r1
    3964:	0c 94 f6 1d 	jmp	0x3bec	; 0x3bec <__fp_szero>
    3968:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <__fp_nan>

0000396c <__divsf3x>:
    396c:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <__fp_split3>
    3970:	68 f3       	brcs	.-38     	; 0x394c <__divsf3+0x8>

00003972 <__divsf3_pse>:
    3972:	99 23       	and	r25, r25
    3974:	b1 f3       	breq	.-20     	; 0x3962 <__divsf3+0x1e>
    3976:	55 23       	and	r21, r21
    3978:	91 f3       	breq	.-28     	; 0x395e <__divsf3+0x1a>
    397a:	95 1b       	sub	r25, r21
    397c:	55 0b       	sbc	r21, r21
    397e:	bb 27       	eor	r27, r27
    3980:	aa 27       	eor	r26, r26
    3982:	62 17       	cp	r22, r18
    3984:	73 07       	cpc	r23, r19
    3986:	84 07       	cpc	r24, r20
    3988:	38 f0       	brcs	.+14     	; 0x3998 <__divsf3_pse+0x26>
    398a:	9f 5f       	subi	r25, 0xFF	; 255
    398c:	5f 4f       	sbci	r21, 0xFF	; 255
    398e:	22 0f       	add	r18, r18
    3990:	33 1f       	adc	r19, r19
    3992:	44 1f       	adc	r20, r20
    3994:	aa 1f       	adc	r26, r26
    3996:	a9 f3       	breq	.-22     	; 0x3982 <__divsf3_pse+0x10>
    3998:	35 d0       	rcall	.+106    	; 0x3a04 <__divsf3_pse+0x92>
    399a:	0e 2e       	mov	r0, r30
    399c:	3a f0       	brmi	.+14     	; 0x39ac <__divsf3_pse+0x3a>
    399e:	e0 e8       	ldi	r30, 0x80	; 128
    39a0:	32 d0       	rcall	.+100    	; 0x3a06 <__divsf3_pse+0x94>
    39a2:	91 50       	subi	r25, 0x01	; 1
    39a4:	50 40       	sbci	r21, 0x00	; 0
    39a6:	e6 95       	lsr	r30
    39a8:	00 1c       	adc	r0, r0
    39aa:	ca f7       	brpl	.-14     	; 0x399e <__divsf3_pse+0x2c>
    39ac:	2b d0       	rcall	.+86     	; 0x3a04 <__divsf3_pse+0x92>
    39ae:	fe 2f       	mov	r31, r30
    39b0:	29 d0       	rcall	.+82     	; 0x3a04 <__divsf3_pse+0x92>
    39b2:	66 0f       	add	r22, r22
    39b4:	77 1f       	adc	r23, r23
    39b6:	88 1f       	adc	r24, r24
    39b8:	bb 1f       	adc	r27, r27
    39ba:	26 17       	cp	r18, r22
    39bc:	37 07       	cpc	r19, r23
    39be:	48 07       	cpc	r20, r24
    39c0:	ab 07       	cpc	r26, r27
    39c2:	b0 e8       	ldi	r27, 0x80	; 128
    39c4:	09 f0       	breq	.+2      	; 0x39c8 <__divsf3_pse+0x56>
    39c6:	bb 0b       	sbc	r27, r27
    39c8:	80 2d       	mov	r24, r0
    39ca:	bf 01       	movw	r22, r30
    39cc:	ff 27       	eor	r31, r31
    39ce:	93 58       	subi	r25, 0x83	; 131
    39d0:	5f 4f       	sbci	r21, 0xFF	; 255
    39d2:	3a f0       	brmi	.+14     	; 0x39e2 <__divsf3_pse+0x70>
    39d4:	9e 3f       	cpi	r25, 0xFE	; 254
    39d6:	51 05       	cpc	r21, r1
    39d8:	78 f0       	brcs	.+30     	; 0x39f8 <__divsf3_pse+0x86>
    39da:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <__fp_inf>
    39de:	0c 94 f6 1d 	jmp	0x3bec	; 0x3bec <__fp_szero>
    39e2:	5f 3f       	cpi	r21, 0xFF	; 255
    39e4:	e4 f3       	brlt	.-8      	; 0x39de <__divsf3_pse+0x6c>
    39e6:	98 3e       	cpi	r25, 0xE8	; 232
    39e8:	d4 f3       	brlt	.-12     	; 0x39de <__divsf3_pse+0x6c>
    39ea:	86 95       	lsr	r24
    39ec:	77 95       	ror	r23
    39ee:	67 95       	ror	r22
    39f0:	b7 95       	ror	r27
    39f2:	f7 95       	ror	r31
    39f4:	9f 5f       	subi	r25, 0xFF	; 255
    39f6:	c9 f7       	brne	.-14     	; 0x39ea <__divsf3_pse+0x78>
    39f8:	88 0f       	add	r24, r24
    39fa:	91 1d       	adc	r25, r1
    39fc:	96 95       	lsr	r25
    39fe:	87 95       	ror	r24
    3a00:	97 f9       	bld	r25, 7
    3a02:	08 95       	ret
    3a04:	e1 e0       	ldi	r30, 0x01	; 1
    3a06:	66 0f       	add	r22, r22
    3a08:	77 1f       	adc	r23, r23
    3a0a:	88 1f       	adc	r24, r24
    3a0c:	bb 1f       	adc	r27, r27
    3a0e:	62 17       	cp	r22, r18
    3a10:	73 07       	cpc	r23, r19
    3a12:	84 07       	cpc	r24, r20
    3a14:	ba 07       	cpc	r27, r26
    3a16:	20 f0       	brcs	.+8      	; 0x3a20 <__divsf3_pse+0xae>
    3a18:	62 1b       	sub	r22, r18
    3a1a:	73 0b       	sbc	r23, r19
    3a1c:	84 0b       	sbc	r24, r20
    3a1e:	ba 0b       	sbc	r27, r26
    3a20:	ee 1f       	adc	r30, r30
    3a22:	88 f7       	brcc	.-30     	; 0x3a06 <__divsf3_pse+0x94>
    3a24:	e0 95       	com	r30
    3a26:	08 95       	ret

00003a28 <__fixsfsi>:
    3a28:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <__fixunssfsi>
    3a2c:	68 94       	set
    3a2e:	b1 11       	cpse	r27, r1
    3a30:	0c 94 f6 1d 	jmp	0x3bec	; 0x3bec <__fp_szero>
    3a34:	08 95       	ret

00003a36 <__fixunssfsi>:
    3a36:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <__fp_splitA>
    3a3a:	88 f0       	brcs	.+34     	; 0x3a5e <__fixunssfsi+0x28>
    3a3c:	9f 57       	subi	r25, 0x7F	; 127
    3a3e:	98 f0       	brcs	.+38     	; 0x3a66 <__fixunssfsi+0x30>
    3a40:	b9 2f       	mov	r27, r25
    3a42:	99 27       	eor	r25, r25
    3a44:	b7 51       	subi	r27, 0x17	; 23
    3a46:	b0 f0       	brcs	.+44     	; 0x3a74 <__fixunssfsi+0x3e>
    3a48:	e1 f0       	breq	.+56     	; 0x3a82 <__fixunssfsi+0x4c>
    3a4a:	66 0f       	add	r22, r22
    3a4c:	77 1f       	adc	r23, r23
    3a4e:	88 1f       	adc	r24, r24
    3a50:	99 1f       	adc	r25, r25
    3a52:	1a f0       	brmi	.+6      	; 0x3a5a <__fixunssfsi+0x24>
    3a54:	ba 95       	dec	r27
    3a56:	c9 f7       	brne	.-14     	; 0x3a4a <__fixunssfsi+0x14>
    3a58:	14 c0       	rjmp	.+40     	; 0x3a82 <__fixunssfsi+0x4c>
    3a5a:	b1 30       	cpi	r27, 0x01	; 1
    3a5c:	91 f0       	breq	.+36     	; 0x3a82 <__fixunssfsi+0x4c>
    3a5e:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <__fp_zero>
    3a62:	b1 e0       	ldi	r27, 0x01	; 1
    3a64:	08 95       	ret
    3a66:	0c 94 f5 1d 	jmp	0x3bea	; 0x3bea <__fp_zero>
    3a6a:	67 2f       	mov	r22, r23
    3a6c:	78 2f       	mov	r23, r24
    3a6e:	88 27       	eor	r24, r24
    3a70:	b8 5f       	subi	r27, 0xF8	; 248
    3a72:	39 f0       	breq	.+14     	; 0x3a82 <__fixunssfsi+0x4c>
    3a74:	b9 3f       	cpi	r27, 0xF9	; 249
    3a76:	cc f3       	brlt	.-14     	; 0x3a6a <__fixunssfsi+0x34>
    3a78:	86 95       	lsr	r24
    3a7a:	77 95       	ror	r23
    3a7c:	67 95       	ror	r22
    3a7e:	b3 95       	inc	r27
    3a80:	d9 f7       	brne	.-10     	; 0x3a78 <__fixunssfsi+0x42>
    3a82:	3e f4       	brtc	.+14     	; 0x3a92 <__fixunssfsi+0x5c>
    3a84:	90 95       	com	r25
    3a86:	80 95       	com	r24
    3a88:	70 95       	com	r23
    3a8a:	61 95       	neg	r22
    3a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    3a8e:	8f 4f       	sbci	r24, 0xFF	; 255
    3a90:	9f 4f       	sbci	r25, 0xFF	; 255
    3a92:	08 95       	ret

00003a94 <__floatunsisf>:
    3a94:	e8 94       	clt
    3a96:	09 c0       	rjmp	.+18     	; 0x3aaa <__floatsisf+0x12>

00003a98 <__floatsisf>:
    3a98:	97 fb       	bst	r25, 7
    3a9a:	3e f4       	brtc	.+14     	; 0x3aaa <__floatsisf+0x12>
    3a9c:	90 95       	com	r25
    3a9e:	80 95       	com	r24
    3aa0:	70 95       	com	r23
    3aa2:	61 95       	neg	r22
    3aa4:	7f 4f       	sbci	r23, 0xFF	; 255
    3aa6:	8f 4f       	sbci	r24, 0xFF	; 255
    3aa8:	9f 4f       	sbci	r25, 0xFF	; 255
    3aaa:	99 23       	and	r25, r25
    3aac:	a9 f0       	breq	.+42     	; 0x3ad8 <__floatsisf+0x40>
    3aae:	f9 2f       	mov	r31, r25
    3ab0:	96 e9       	ldi	r25, 0x96	; 150
    3ab2:	bb 27       	eor	r27, r27
    3ab4:	93 95       	inc	r25
    3ab6:	f6 95       	lsr	r31
    3ab8:	87 95       	ror	r24
    3aba:	77 95       	ror	r23
    3abc:	67 95       	ror	r22
    3abe:	b7 95       	ror	r27
    3ac0:	f1 11       	cpse	r31, r1
    3ac2:	f8 cf       	rjmp	.-16     	; 0x3ab4 <__floatsisf+0x1c>
    3ac4:	fa f4       	brpl	.+62     	; 0x3b04 <__floatsisf+0x6c>
    3ac6:	bb 0f       	add	r27, r27
    3ac8:	11 f4       	brne	.+4      	; 0x3ace <__floatsisf+0x36>
    3aca:	60 ff       	sbrs	r22, 0
    3acc:	1b c0       	rjmp	.+54     	; 0x3b04 <__floatsisf+0x6c>
    3ace:	6f 5f       	subi	r22, 0xFF	; 255
    3ad0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ad2:	8f 4f       	sbci	r24, 0xFF	; 255
    3ad4:	9f 4f       	sbci	r25, 0xFF	; 255
    3ad6:	16 c0       	rjmp	.+44     	; 0x3b04 <__floatsisf+0x6c>
    3ad8:	88 23       	and	r24, r24
    3ada:	11 f0       	breq	.+4      	; 0x3ae0 <__floatsisf+0x48>
    3adc:	96 e9       	ldi	r25, 0x96	; 150
    3ade:	11 c0       	rjmp	.+34     	; 0x3b02 <__floatsisf+0x6a>
    3ae0:	77 23       	and	r23, r23
    3ae2:	21 f0       	breq	.+8      	; 0x3aec <__floatsisf+0x54>
    3ae4:	9e e8       	ldi	r25, 0x8E	; 142
    3ae6:	87 2f       	mov	r24, r23
    3ae8:	76 2f       	mov	r23, r22
    3aea:	05 c0       	rjmp	.+10     	; 0x3af6 <__floatsisf+0x5e>
    3aec:	66 23       	and	r22, r22
    3aee:	71 f0       	breq	.+28     	; 0x3b0c <__floatsisf+0x74>
    3af0:	96 e8       	ldi	r25, 0x86	; 134
    3af2:	86 2f       	mov	r24, r22
    3af4:	70 e0       	ldi	r23, 0x00	; 0
    3af6:	60 e0       	ldi	r22, 0x00	; 0
    3af8:	2a f0       	brmi	.+10     	; 0x3b04 <__floatsisf+0x6c>
    3afa:	9a 95       	dec	r25
    3afc:	66 0f       	add	r22, r22
    3afe:	77 1f       	adc	r23, r23
    3b00:	88 1f       	adc	r24, r24
    3b02:	da f7       	brpl	.-10     	; 0x3afa <__floatsisf+0x62>
    3b04:	88 0f       	add	r24, r24
    3b06:	96 95       	lsr	r25
    3b08:	87 95       	ror	r24
    3b0a:	97 f9       	bld	r25, 7
    3b0c:	08 95       	ret

00003b0e <__fp_cmp>:
    3b0e:	99 0f       	add	r25, r25
    3b10:	00 08       	sbc	r0, r0
    3b12:	55 0f       	add	r21, r21
    3b14:	aa 0b       	sbc	r26, r26
    3b16:	e0 e8       	ldi	r30, 0x80	; 128
    3b18:	fe ef       	ldi	r31, 0xFE	; 254
    3b1a:	16 16       	cp	r1, r22
    3b1c:	17 06       	cpc	r1, r23
    3b1e:	e8 07       	cpc	r30, r24
    3b20:	f9 07       	cpc	r31, r25
    3b22:	c0 f0       	brcs	.+48     	; 0x3b54 <__fp_cmp+0x46>
    3b24:	12 16       	cp	r1, r18
    3b26:	13 06       	cpc	r1, r19
    3b28:	e4 07       	cpc	r30, r20
    3b2a:	f5 07       	cpc	r31, r21
    3b2c:	98 f0       	brcs	.+38     	; 0x3b54 <__fp_cmp+0x46>
    3b2e:	62 1b       	sub	r22, r18
    3b30:	73 0b       	sbc	r23, r19
    3b32:	84 0b       	sbc	r24, r20
    3b34:	95 0b       	sbc	r25, r21
    3b36:	39 f4       	brne	.+14     	; 0x3b46 <__fp_cmp+0x38>
    3b38:	0a 26       	eor	r0, r26
    3b3a:	61 f0       	breq	.+24     	; 0x3b54 <__fp_cmp+0x46>
    3b3c:	23 2b       	or	r18, r19
    3b3e:	24 2b       	or	r18, r20
    3b40:	25 2b       	or	r18, r21
    3b42:	21 f4       	brne	.+8      	; 0x3b4c <__fp_cmp+0x3e>
    3b44:	08 95       	ret
    3b46:	0a 26       	eor	r0, r26
    3b48:	09 f4       	brne	.+2      	; 0x3b4c <__fp_cmp+0x3e>
    3b4a:	a1 40       	sbci	r26, 0x01	; 1
    3b4c:	a6 95       	lsr	r26
    3b4e:	8f ef       	ldi	r24, 0xFF	; 255
    3b50:	81 1d       	adc	r24, r1
    3b52:	81 1d       	adc	r24, r1
    3b54:	08 95       	ret

00003b56 <__fp_inf>:
    3b56:	97 f9       	bld	r25, 7
    3b58:	9f 67       	ori	r25, 0x7F	; 127
    3b5a:	80 e8       	ldi	r24, 0x80	; 128
    3b5c:	70 e0       	ldi	r23, 0x00	; 0
    3b5e:	60 e0       	ldi	r22, 0x00	; 0
    3b60:	08 95       	ret

00003b62 <__fp_nan>:
    3b62:	9f ef       	ldi	r25, 0xFF	; 255
    3b64:	80 ec       	ldi	r24, 0xC0	; 192
    3b66:	08 95       	ret

00003b68 <__fp_pscA>:
    3b68:	00 24       	eor	r0, r0
    3b6a:	0a 94       	dec	r0
    3b6c:	16 16       	cp	r1, r22
    3b6e:	17 06       	cpc	r1, r23
    3b70:	18 06       	cpc	r1, r24
    3b72:	09 06       	cpc	r0, r25
    3b74:	08 95       	ret

00003b76 <__fp_pscB>:
    3b76:	00 24       	eor	r0, r0
    3b78:	0a 94       	dec	r0
    3b7a:	12 16       	cp	r1, r18
    3b7c:	13 06       	cpc	r1, r19
    3b7e:	14 06       	cpc	r1, r20
    3b80:	05 06       	cpc	r0, r21
    3b82:	08 95       	ret

00003b84 <__fp_round>:
    3b84:	09 2e       	mov	r0, r25
    3b86:	03 94       	inc	r0
    3b88:	00 0c       	add	r0, r0
    3b8a:	11 f4       	brne	.+4      	; 0x3b90 <__fp_round+0xc>
    3b8c:	88 23       	and	r24, r24
    3b8e:	52 f0       	brmi	.+20     	; 0x3ba4 <__fp_round+0x20>
    3b90:	bb 0f       	add	r27, r27
    3b92:	40 f4       	brcc	.+16     	; 0x3ba4 <__fp_round+0x20>
    3b94:	bf 2b       	or	r27, r31
    3b96:	11 f4       	brne	.+4      	; 0x3b9c <__fp_round+0x18>
    3b98:	60 ff       	sbrs	r22, 0
    3b9a:	04 c0       	rjmp	.+8      	; 0x3ba4 <__fp_round+0x20>
    3b9c:	6f 5f       	subi	r22, 0xFF	; 255
    3b9e:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba0:	8f 4f       	sbci	r24, 0xFF	; 255
    3ba2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ba4:	08 95       	ret

00003ba6 <__fp_split3>:
    3ba6:	57 fd       	sbrc	r21, 7
    3ba8:	90 58       	subi	r25, 0x80	; 128
    3baa:	44 0f       	add	r20, r20
    3bac:	55 1f       	adc	r21, r21
    3bae:	59 f0       	breq	.+22     	; 0x3bc6 <__fp_splitA+0x10>
    3bb0:	5f 3f       	cpi	r21, 0xFF	; 255
    3bb2:	71 f0       	breq	.+28     	; 0x3bd0 <__fp_splitA+0x1a>
    3bb4:	47 95       	ror	r20

00003bb6 <__fp_splitA>:
    3bb6:	88 0f       	add	r24, r24
    3bb8:	97 fb       	bst	r25, 7
    3bba:	99 1f       	adc	r25, r25
    3bbc:	61 f0       	breq	.+24     	; 0x3bd6 <__fp_splitA+0x20>
    3bbe:	9f 3f       	cpi	r25, 0xFF	; 255
    3bc0:	79 f0       	breq	.+30     	; 0x3be0 <__fp_splitA+0x2a>
    3bc2:	87 95       	ror	r24
    3bc4:	08 95       	ret
    3bc6:	12 16       	cp	r1, r18
    3bc8:	13 06       	cpc	r1, r19
    3bca:	14 06       	cpc	r1, r20
    3bcc:	55 1f       	adc	r21, r21
    3bce:	f2 cf       	rjmp	.-28     	; 0x3bb4 <__fp_split3+0xe>
    3bd0:	46 95       	lsr	r20
    3bd2:	f1 df       	rcall	.-30     	; 0x3bb6 <__fp_splitA>
    3bd4:	08 c0       	rjmp	.+16     	; 0x3be6 <__fp_splitA+0x30>
    3bd6:	16 16       	cp	r1, r22
    3bd8:	17 06       	cpc	r1, r23
    3bda:	18 06       	cpc	r1, r24
    3bdc:	99 1f       	adc	r25, r25
    3bde:	f1 cf       	rjmp	.-30     	; 0x3bc2 <__fp_splitA+0xc>
    3be0:	86 95       	lsr	r24
    3be2:	71 05       	cpc	r23, r1
    3be4:	61 05       	cpc	r22, r1
    3be6:	08 94       	sec
    3be8:	08 95       	ret

00003bea <__fp_zero>:
    3bea:	e8 94       	clt

00003bec <__fp_szero>:
    3bec:	bb 27       	eor	r27, r27
    3bee:	66 27       	eor	r22, r22
    3bf0:	77 27       	eor	r23, r23
    3bf2:	cb 01       	movw	r24, r22
    3bf4:	97 f9       	bld	r25, 7
    3bf6:	08 95       	ret

00003bf8 <__gesf2>:
    3bf8:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__fp_cmp>
    3bfc:	08 f4       	brcc	.+2      	; 0x3c00 <__gesf2+0x8>
    3bfe:	8f ef       	ldi	r24, 0xFF	; 255
    3c00:	08 95       	ret

00003c02 <__mulsf3>:
    3c02:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <__mulsf3x>
    3c06:	0c 94 c2 1d 	jmp	0x3b84	; 0x3b84 <__fp_round>
    3c0a:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <__fp_pscA>
    3c0e:	38 f0       	brcs	.+14     	; 0x3c1e <__mulsf3+0x1c>
    3c10:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <__fp_pscB>
    3c14:	20 f0       	brcs	.+8      	; 0x3c1e <__mulsf3+0x1c>
    3c16:	95 23       	and	r25, r21
    3c18:	11 f0       	breq	.+4      	; 0x3c1e <__mulsf3+0x1c>
    3c1a:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <__fp_inf>
    3c1e:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <__fp_nan>
    3c22:	11 24       	eor	r1, r1
    3c24:	0c 94 f6 1d 	jmp	0x3bec	; 0x3bec <__fp_szero>

00003c28 <__mulsf3x>:
    3c28:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <__fp_split3>
    3c2c:	70 f3       	brcs	.-36     	; 0x3c0a <__mulsf3+0x8>

00003c2e <__mulsf3_pse>:
    3c2e:	95 9f       	mul	r25, r21
    3c30:	c1 f3       	breq	.-16     	; 0x3c22 <__mulsf3+0x20>
    3c32:	95 0f       	add	r25, r21
    3c34:	50 e0       	ldi	r21, 0x00	; 0
    3c36:	55 1f       	adc	r21, r21
    3c38:	62 9f       	mul	r22, r18
    3c3a:	f0 01       	movw	r30, r0
    3c3c:	72 9f       	mul	r23, r18
    3c3e:	bb 27       	eor	r27, r27
    3c40:	f0 0d       	add	r31, r0
    3c42:	b1 1d       	adc	r27, r1
    3c44:	63 9f       	mul	r22, r19
    3c46:	aa 27       	eor	r26, r26
    3c48:	f0 0d       	add	r31, r0
    3c4a:	b1 1d       	adc	r27, r1
    3c4c:	aa 1f       	adc	r26, r26
    3c4e:	64 9f       	mul	r22, r20
    3c50:	66 27       	eor	r22, r22
    3c52:	b0 0d       	add	r27, r0
    3c54:	a1 1d       	adc	r26, r1
    3c56:	66 1f       	adc	r22, r22
    3c58:	82 9f       	mul	r24, r18
    3c5a:	22 27       	eor	r18, r18
    3c5c:	b0 0d       	add	r27, r0
    3c5e:	a1 1d       	adc	r26, r1
    3c60:	62 1f       	adc	r22, r18
    3c62:	73 9f       	mul	r23, r19
    3c64:	b0 0d       	add	r27, r0
    3c66:	a1 1d       	adc	r26, r1
    3c68:	62 1f       	adc	r22, r18
    3c6a:	83 9f       	mul	r24, r19
    3c6c:	a0 0d       	add	r26, r0
    3c6e:	61 1d       	adc	r22, r1
    3c70:	22 1f       	adc	r18, r18
    3c72:	74 9f       	mul	r23, r20
    3c74:	33 27       	eor	r19, r19
    3c76:	a0 0d       	add	r26, r0
    3c78:	61 1d       	adc	r22, r1
    3c7a:	23 1f       	adc	r18, r19
    3c7c:	84 9f       	mul	r24, r20
    3c7e:	60 0d       	add	r22, r0
    3c80:	21 1d       	adc	r18, r1
    3c82:	82 2f       	mov	r24, r18
    3c84:	76 2f       	mov	r23, r22
    3c86:	6a 2f       	mov	r22, r26
    3c88:	11 24       	eor	r1, r1
    3c8a:	9f 57       	subi	r25, 0x7F	; 127
    3c8c:	50 40       	sbci	r21, 0x00	; 0
    3c8e:	9a f0       	brmi	.+38     	; 0x3cb6 <__mulsf3_pse+0x88>
    3c90:	f1 f0       	breq	.+60     	; 0x3cce <__mulsf3_pse+0xa0>
    3c92:	88 23       	and	r24, r24
    3c94:	4a f0       	brmi	.+18     	; 0x3ca8 <__mulsf3_pse+0x7a>
    3c96:	ee 0f       	add	r30, r30
    3c98:	ff 1f       	adc	r31, r31
    3c9a:	bb 1f       	adc	r27, r27
    3c9c:	66 1f       	adc	r22, r22
    3c9e:	77 1f       	adc	r23, r23
    3ca0:	88 1f       	adc	r24, r24
    3ca2:	91 50       	subi	r25, 0x01	; 1
    3ca4:	50 40       	sbci	r21, 0x00	; 0
    3ca6:	a9 f7       	brne	.-22     	; 0x3c92 <__mulsf3_pse+0x64>
    3ca8:	9e 3f       	cpi	r25, 0xFE	; 254
    3caa:	51 05       	cpc	r21, r1
    3cac:	80 f0       	brcs	.+32     	; 0x3cce <__mulsf3_pse+0xa0>
    3cae:	0c 94 ab 1d 	jmp	0x3b56	; 0x3b56 <__fp_inf>
    3cb2:	0c 94 f6 1d 	jmp	0x3bec	; 0x3bec <__fp_szero>
    3cb6:	5f 3f       	cpi	r21, 0xFF	; 255
    3cb8:	e4 f3       	brlt	.-8      	; 0x3cb2 <__mulsf3_pse+0x84>
    3cba:	98 3e       	cpi	r25, 0xE8	; 232
    3cbc:	d4 f3       	brlt	.-12     	; 0x3cb2 <__mulsf3_pse+0x84>
    3cbe:	86 95       	lsr	r24
    3cc0:	77 95       	ror	r23
    3cc2:	67 95       	ror	r22
    3cc4:	b7 95       	ror	r27
    3cc6:	f7 95       	ror	r31
    3cc8:	e7 95       	ror	r30
    3cca:	9f 5f       	subi	r25, 0xFF	; 255
    3ccc:	c1 f7       	brne	.-16     	; 0x3cbe <__mulsf3_pse+0x90>
    3cce:	fe 2b       	or	r31, r30
    3cd0:	88 0f       	add	r24, r24
    3cd2:	91 1d       	adc	r25, r1
    3cd4:	96 95       	lsr	r25
    3cd6:	87 95       	ror	r24
    3cd8:	97 f9       	bld	r25, 7
    3cda:	08 95       	ret

00003cdc <__tablejump2__>:
    3cdc:	ee 0f       	add	r30, r30
    3cde:	ff 1f       	adc	r31, r31
    3ce0:	88 1f       	adc	r24, r24
    3ce2:	8b bf       	out	0x3b, r24	; 59
    3ce4:	07 90       	elpm	r0, Z+
    3ce6:	f6 91       	elpm	r31, Z
    3ce8:	e0 2d       	mov	r30, r0
    3cea:	19 94       	eijmp

00003cec <memcpy>:
    3cec:	fb 01       	movw	r30, r22
    3cee:	dc 01       	movw	r26, r24
    3cf0:	02 c0       	rjmp	.+4      	; 0x3cf6 <memcpy+0xa>
    3cf2:	01 90       	ld	r0, Z+
    3cf4:	0d 92       	st	X+, r0
    3cf6:	41 50       	subi	r20, 0x01	; 1
    3cf8:	50 40       	sbci	r21, 0x00	; 0
    3cfa:	d8 f7       	brcc	.-10     	; 0x3cf2 <memcpy+0x6>
    3cfc:	08 95       	ret

00003cfe <memset>:
    3cfe:	dc 01       	movw	r26, r24
    3d00:	01 c0       	rjmp	.+2      	; 0x3d04 <memset+0x6>
    3d02:	6d 93       	st	X+, r22
    3d04:	41 50       	subi	r20, 0x01	; 1
    3d06:	50 40       	sbci	r21, 0x00	; 0
    3d08:	e0 f7       	brcc	.-8      	; 0x3d02 <memset+0x4>
    3d0a:	08 95       	ret

00003d0c <__itoa_ncheck>:
    3d0c:	bb 27       	eor	r27, r27
    3d0e:	4a 30       	cpi	r20, 0x0A	; 10
    3d10:	31 f4       	brne	.+12     	; 0x3d1e <__itoa_ncheck+0x12>
    3d12:	99 23       	and	r25, r25
    3d14:	22 f4       	brpl	.+8      	; 0x3d1e <__itoa_ncheck+0x12>
    3d16:	bd e2       	ldi	r27, 0x2D	; 45
    3d18:	90 95       	com	r25
    3d1a:	81 95       	neg	r24
    3d1c:	9f 4f       	sbci	r25, 0xFF	; 255
    3d1e:	0c 94 92 1e 	jmp	0x3d24	; 0x3d24 <__utoa_common>

00003d22 <__utoa_ncheck>:
    3d22:	bb 27       	eor	r27, r27

00003d24 <__utoa_common>:
    3d24:	fb 01       	movw	r30, r22
    3d26:	55 27       	eor	r21, r21
    3d28:	aa 27       	eor	r26, r26
    3d2a:	88 0f       	add	r24, r24
    3d2c:	99 1f       	adc	r25, r25
    3d2e:	aa 1f       	adc	r26, r26
    3d30:	a4 17       	cp	r26, r20
    3d32:	10 f0       	brcs	.+4      	; 0x3d38 <__utoa_common+0x14>
    3d34:	a4 1b       	sub	r26, r20
    3d36:	83 95       	inc	r24
    3d38:	50 51       	subi	r21, 0x10	; 16
    3d3a:	b9 f7       	brne	.-18     	; 0x3d2a <__utoa_common+0x6>
    3d3c:	a0 5d       	subi	r26, 0xD0	; 208
    3d3e:	aa 33       	cpi	r26, 0x3A	; 58
    3d40:	08 f0       	brcs	.+2      	; 0x3d44 <__utoa_common+0x20>
    3d42:	a9 5d       	subi	r26, 0xD9	; 217
    3d44:	a1 93       	st	Z+, r26
    3d46:	00 97       	sbiw	r24, 0x00	; 0
    3d48:	79 f7       	brne	.-34     	; 0x3d28 <__utoa_common+0x4>
    3d4a:	b1 11       	cpse	r27, r1
    3d4c:	b1 93       	st	Z+, r27
    3d4e:	11 92       	st	Z+, r1
    3d50:	cb 01       	movw	r24, r22
    3d52:	0c 94 ab 1e 	jmp	0x3d56	; 0x3d56 <strrev>

00003d56 <strrev>:
    3d56:	dc 01       	movw	r26, r24
    3d58:	fc 01       	movw	r30, r24
    3d5a:	67 2f       	mov	r22, r23
    3d5c:	71 91       	ld	r23, Z+
    3d5e:	77 23       	and	r23, r23
    3d60:	e1 f7       	brne	.-8      	; 0x3d5a <strrev+0x4>
    3d62:	32 97       	sbiw	r30, 0x02	; 2
    3d64:	04 c0       	rjmp	.+8      	; 0x3d6e <strrev+0x18>
    3d66:	7c 91       	ld	r23, X
    3d68:	6d 93       	st	X+, r22
    3d6a:	70 83       	st	Z, r23
    3d6c:	62 91       	ld	r22, -Z
    3d6e:	ae 17       	cp	r26, r30
    3d70:	bf 07       	cpc	r27, r31
    3d72:	c8 f3       	brcs	.-14     	; 0x3d66 <strrev+0x10>
    3d74:	08 95       	ret

00003d76 <_exit>:
    3d76:	f8 94       	cli

00003d78 <__stop_program>:
    3d78:	ff cf       	rjmp	.-2      	; 0x3d78 <__stop_program>
